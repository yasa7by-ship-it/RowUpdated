-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Actual Price Range to Daily Watchlist
-- #
-- # Purpose: This script updates the get_the_coming_trend_data function
-- # to include actual low/high price range using multiple sources in priority:
-- # 1. forecast_check_history (for specific dates like 2025-10-31)
-- # 2. forecast_check_latest (latest evaluation results)
-- # 3. historical_data (raw historical data as fallback)
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Update the existing RPC function to include actual price range
-- Using CREATE OR REPLACE to update the function that already exists from migration_153
CREATE OR REPLACE FUNCTION public.get_the_coming_trend_data()
RETURNS TABLE (
    -- Stock info
    symbol TEXT,
    stock_name TEXT,
    last_price REAL,
    daily_change REAL,
    daily_change_percent REAL,
    
    -- Next upcoming forecast
    next_forecast_date DATE,
    next_predicted_lo REAL,
    next_predicted_hi REAL,
    
    -- Latest technical indicators
    indicator_date DATE,
    rsi REAL,
    macd REAL,
    macd_signal REAL,
    sma20 REAL,
    sma50 REAL,

    -- Latest candle pattern
    pattern_name TEXT,
    bullish BOOLEAN,
    
    -- Actual price range from historical_data for indicator_date
    actual_low REAL,
    actual_high REAL
)
LANGUAGE plpgsql STABLE AS $$
DECLARE
    latest_historical_date DATE;
BEGIN
    -- Find the date of the latest available historical data. This represents "today" or the last trading day.
    SELECT MAX(date) INTO latest_historical_date FROM public.historical_data;

    RETURN QUERY
    SELECT
        s.symbol,
        s.name AS stock_name,
        s.price AS last_price,
        s.change AS daily_change,
        s.change_percent AS daily_change_percent,
        
        -- Next upcoming forecast (the one with the date after the latest historical date)
        nf.forecast_date AS next_forecast_date,
        nf.predicted_lo AS next_predicted_lo,
        nf.predicted_hi AS next_predicted_hi,
        
        -- Latest technical indicators (for the latest historical day)
        ti.date AS indicator_date,
        ti.rsi::real,
        ti.macd::real,
        ti.macd_signal::real,
        ti.sma20::real,
        ti.sma50::real,

        -- Latest candle pattern
        cp.pattern_name,
        cp.bullish,
        
        -- Actual price range: prefer forecast_check_history (for specific dates like 2025-10-31)
        -- Then forecast_check_latest, then historical_data as fallback
        COALESCE(
            fch.actual_low::real, 
            fcl.actual_low::real, 
            hd.low::real
        ) AS actual_low,
        COALESCE(
            fch.actual_high::real, 
            fcl.actual_high::real, 
            hd.high::real
        ) AS actual_high
        
    FROM public.stocks s
    
    LEFT JOIN LATERAL (
        SELECT *
        FROM public.forecasts
        WHERE stock_symbol = s.symbol AND forecast_date > latest_historical_date
        ORDER BY forecast_date ASC
        LIMIT 1
    ) nf ON true
    
    LEFT JOIN public.technical_indicators ti ON s.symbol = ti.stock_symbol AND ti.date = latest_historical_date

    -- Use forecast_check_history first: try exact match with indicator_date,
    -- then fallback to latest available record
    LEFT JOIN LATERAL (
        SELECT fch_inner.actual_low, fch_inner.actual_high, fch_inner.forecast_date
        FROM public.forecast_check_history fch_inner
        WHERE fch_inner.stock_symbol = s.symbol
        ORDER BY 
            -- Priority 1: exact match with indicator_date
            CASE WHEN fch_inner.forecast_date = latest_historical_date THEN 0 ELSE 1 END,
            -- Priority 2: latest available date
            fch_inner.forecast_date DESC
        LIMIT 1
    ) fch ON true
    
    -- Fallback to forecast_check_latest if no history record exists
    LEFT JOIN public.forecast_check_latest fcl ON s.symbol = fcl.stock_symbol 
        AND fch.forecast_date IS NULL
    
    -- Final fallback to historical_data for indicator_date
    LEFT JOIN public.historical_data hd ON s.symbol = hd.stock_symbol 
        AND hd.date = latest_historical_date
        AND fch.forecast_date IS NULL
        AND fcl.stock_symbol IS NULL

    LEFT JOIN LATERAL (
        -- Get only the first/most relevant pattern for the indicator date to avoid duplicate rows
        SELECT cp_inner.pattern_name, cp_inner.bullish
        FROM public.candle_patterns cp_inner
        WHERE cp_inner.stock_symbol = s.symbol AND cp_inner.date = latest_historical_date
        ORDER BY cp_inner.confidence DESC NULLS LAST
        LIMIT 1
    ) cp ON true
    
    WHERE s.is_tracked = true
    ORDER BY s.symbol;
END;
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_the_coming_trend_data" updated to include actual price range.';

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################

