-- #############################################################################
-- #
-- # Secure Admin Dashboard - Fresh Setup Script
-- # Version: 2.0 (Clean Build)
-- #
-- #############################################################################

-- -----------------------------------------------------------------------------
-- 1. EXTENSIONS & SCHEMA SETUP
-- -----------------------------------------------------------------------------
CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";

-- -----------------------------------------------------------------------------
-- 2. CREATE TABLES (Order is important due to foreign keys)
-- -----------------------------------------------------------------------------
 
-- ROLES: Defines user roles like 'Admin', 'User'.
CREATE TABLE IF NOT EXISTS "public"."roles" (
    "id" uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    "name" text NOT NULL UNIQUE,
    "description" text,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL
);
COMMENT ON TABLE public.roles IS 'Stores user roles and their descriptions.';

-- PERMISSIONS: Defines specific actions a user can take, e.g., 'manage:users'.
CREATE TABLE IF NOT EXISTS "public"."permissions" (
    "id" uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    "action" text NOT NULL UNIQUE,
    "description" text,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL
);
COMMENT ON TABLE public.permissions IS 'Stores discrete actions that can be permitted.';

-- ROLE_PERMISSIONS: Maps permissions to roles (many-to-many relationship).
CREATE TABLE IF NOT EXISTS "public"."role_permissions" (
    "role_id" uuid NOT NULL REFERENCES public.roles(id) ON DELETE CASCADE,
    "permission_id" uuid NOT NULL REFERENCES public.permissions(id) ON DELETE CASCADE,
    PRIMARY KEY (role_id, permission_id)
);
COMMENT ON TABLE public.role_permissions IS 'Maps roles to their granted permissions.';

-- PROFILES: Stores public user data, linked to auth.users.
CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    "full_name" text,
    "email" text UNIQUE,
    "role_id" uuid REFERENCES public.roles(id) ON DELETE SET NULL,
    "updated_at" timestamp with time zone DEFAULT now() NOT NULL
);
COMMENT ON TABLE public.profiles IS 'Stores public-facing user profile information.';

-- TRANSLATIONS: For internationalization (i1n).
CREATE TABLE IF NOT EXISTS "public"."translations" (
    "id" bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "lang_id" text NOT NULL,
    "key" text NOT NULL,
    "value" text NOT NULL,
    UNIQUE (lang_id, key)
);
COMMENT ON TABLE public.translations IS 'Stores key-value translations for different languages.';

-- APP_SETTINGS: For global, non-translatable application settings.
CREATE TABLE IF NOT EXISTS "public"."app_settings" (
    "key" text PRIMARY KEY,
    "value" text
);
COMMENT ON TABLE public.app_settings IS 'Stores global application settings like a site logo.';

-- -----------------------------------------------------------------------------
-- 3. ROW LEVEL SECURITY (RLS)
-- -----------------------------------------------------------------------------

-- Enable RLS on all tables
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;

-- Helper function to check if the current user has a specific permission.
CREATE OR REPLACE FUNCTION public.has_permission(permission_action text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM public.profiles p
    JOIN public.role_permissions rp ON p.role_id = rp.role_id
    JOIN public.permissions perm ON rp.permission_id = perm.id
    WHERE p.id = auth.uid() AND perm.action = permission_action
  );
END;
$$;

-- PROFILES POLICIES
DROP POLICY IF EXISTS "Allow individual read/update access on profiles" ON "public"."profiles";
CREATE POLICY "Allow individual read/update access on profiles" ON "public"."profiles"
FOR ALL USING (auth.uid() = id);

DROP POLICY IF EXISTS "Allow managers read access on profiles" ON "public"."profiles";
CREATE POLICY "Allow managers read access on profiles" ON "public"."profiles"
FOR SELECT USING (public.has_permission('manage:users'));

-- ROLES, PERMISSIONS, ROLE_PERMISSIONS POLICIES
DROP POLICY IF EXISTS "Allow authenticated read access" ON "public"."roles";
CREATE POLICY "Allow authenticated read access" ON "public"."roles" FOR SELECT USING (auth.role() = 'authenticated');
DROP POLICY IF EXISTS "Allow authenticated read access" ON "public"."permissions";
CREATE POLICY "Allow authenticated read access" ON "public"."permissions" FOR SELECT USING (auth.role() = 'authenticated');
DROP POLICY IF EXISTS "Allow authenticated read access" ON "public"."role_permissions";
CREATE POLICY "Allow authenticated read access" ON "public"."role_permissions" FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Allow managers full access" ON "public"."roles";
CREATE POLICY "Allow managers full access" ON "public"."roles" FOR ALL USING (public.has_permission('manage:roles'));
DROP POLICY IF EXISTS "Allow managers full access" ON "public"."role_permissions";
CREATE POLICY "Allow managers full access" ON "public"."role_permissions" FOR ALL USING (public.has_permission('manage:roles'));

-- TRANSLATIONS & APP_SETTINGS POLICIES
DROP POLICY IF EXISTS "Allow public read access" ON "public"."translations";
CREATE POLICY "Allow public read access" ON "public"."translations" FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow public read access" ON "public"."app_settings";
CREATE POLICY "Allow public read access" ON "public"."app_settings" FOR SELECT USING (true);

DROP POLICY IF EXISTS "Allow managers full access" ON "public"."translations";
CREATE POLICY "Allow managers full access" ON "public"."translations" FOR ALL USING (public.has_permission('manage:settings'));
DROP POLICY IF EXISTS "Allow managers full access" ON "public"."app_settings";
CREATE POLICY "Allow managers full access" ON "public"."app_settings" FOR ALL USING (public.has_permission('manage:settings'));

-- -----------------------------------------------------------------------------
-- 4. FUNCTIONS & TRIGGERS
-- -----------------------------------------------------------------------------

-- The core of the automatic setup. This trigger creates a profile for a new user.
-- CRUCIALLY, if it's the very first user, it automatically assigns them the 'Admin' role.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
  user_count integer;
  admin_role_id uuid;
BEGIN
  -- Create the profile entry
  INSERT INTO public.profiles (id, full_name, email)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.email);

  -- Check if this is the first user in the system
  SELECT count(*) INTO user_count FROM auth.users;

  -- If it is the first user, make them an admin.
  IF user_count = 1 THEN
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    IF admin_role_id IS NOT NULL THEN
      UPDATE public.profiles
      SET role_id = admin_role_id
      WHERE id = new.id;
    END IF;
  END IF;

  RETURN new;
END;
$$;

-- Trigger to call the function after a new user is created.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- -----------------------------------------------------------------------------
-- 5. SEED DATA (Initial data to get started)
-- -----------------------------------------------------------------------------
BEGIN;

-- Temporarily disable RLS to insert seed data
ALTER TABLE public.roles DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.permissions DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_settings DISABLE ROW LEVEL SECURITY;

-- Seed Roles (Idempotent: will not fail if roles already exist)
INSERT INTO public.roles (name, description) VALUES
('Admin', 'Has full access to all system features and settings.'),
('User', 'Standard user with basic permissions.')
ON CONFLICT (name) DO NOTHING;

-- Seed Permissions (Idempotent: will not fail if permissions already exist)
INSERT INTO public.permissions (action, description) VALUES
('manage:users', 'Can view the user list and change user roles.'),
('manage:roles', 'Can view the role list and change role permissions.'),
('view:dashboard', 'Can view the main dashboard and statistics.'),
('manage:settings', 'Can update site-wide application settings.')
ON CONFLICT (action) DO NOTHING;

-- Seed Role-Permission Mappings (Idempotent)
DO $$
DECLARE
    admin_role_id uuid;
    user_role_id uuid;
    manage_users_perm_id uuid;
    manage_roles_perm_id uuid;
    view_dashboard_perm_id uuid;
    manage_settings_perm_id uuid;
BEGIN
    -- Get IDs
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    SELECT id INTO user_role_id FROM public.roles WHERE name = 'User';
    SELECT id INTO manage_users_perm_id FROM public.permissions WHERE action = 'manage:users';
    SELECT id INTO manage_roles_perm_id FROM public.permissions WHERE action = 'manage:roles';
    SELECT id INTO view_dashboard_perm_id FROM public.permissions WHERE action = 'view:dashboard';
    SELECT id INTO manage_settings_perm_id FROM public.permissions WHERE action = 'manage:settings';

    -- Assign all permissions to Admin
    INSERT INTO public.role_permissions (role_id, permission_id) VALUES
    (admin_role_id, manage_users_perm_id),
    (admin_role_id, manage_roles_perm_id),
    (admin_role_id, view_dashboard_perm_id),
    (admin_role_id, manage_settings_perm_id)
    ON CONFLICT (role_id, permission_id) DO NOTHING;
    
    -- Assign basic permission to User
    INSERT INTO public.role_permissions (role_id, permission_id) VALUES
    (user_role_id, view_dashboard_perm_id)
    ON CONFLICT (role_id, permission_id) DO NOTHING;
END $$;

-- Seed App Settings (Idempotent: will update if key exists)
INSERT INTO public.app_settings (key, value) VALUES
('site_logo', '<svg width="24" height="24" viewBox="0 0 24 24"><path fill="#f25022" d="M1 1h10v10H1z"></path><path fill="#7fba00" d="M13 1h10v10H13z"></path><path fill="#00a4ef" d="M1 13h10v10H1z"></path><path fill="#ffb900" d="M13 13h10v10H13z"></path></svg>')
ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value;

-- Seed Basic Translations (Idempotent: will update if key exists)
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'site_title', 'Admin Panel'), ('ar', 'site_title', 'لوحة التحكم'),
('en', 'dashboard', 'Dashboard'), ('ar', 'dashboard', 'لوحة التحكم'),
('en', 'user_management', 'User Management'), ('ar', 'user_management', 'إدارة المستخدمين'),
('en', 'role_management', 'Role Management'), ('ar', 'role_management', 'إدارة الصلاحيات'),
('en', 'welcome_message', 'Welcome back! Here''s an overview.'), ('ar', 'welcome_message', 'أهلاً بعودتك! هذه نظرة عامة.'),
('en', 'total_users', 'Total Users'), ('ar', 'total_users', 'إجمالي المستخدمين'),
('en', 'total_roles', 'Total Roles'), ('ar', 'total_roles', 'إجمالي الصلاحيات'),
('en', 'save', 'Save'), ('ar', 'save', 'حفظ'),
('en', 'cancel', 'Cancel'), ('ar', 'cancel', 'إلغاء'),
('en', 'email', 'Email'), ('ar', 'email', 'البريد الإلكتروني'),
('en', 'full_name', 'Full Name'), ('ar', 'full_name', 'الاسم الكامل'),
('en', 'role', 'Role'), ('ar', 'role', 'الصلاحية'),
('en', 'actions', 'Actions'), ('ar', 'actions', 'الإجراءات'),
('en', 'roles', 'Roles'), ('ar', 'roles', 'الصلاحيات'),
('en', 'permissions', 'Permissions'), ('ar', 'permissions', 'الأذونات'),
('en', 'sign_out', 'Sign Out'), ('ar', 'sign_out', 'تسجيل الخروج'),
('en', 'dark_theme', 'Dark Theme'), ('ar', 'dark_theme', 'الوضع الداكن'),
('en', 'light_theme', 'Light Theme'), ('ar', 'light_theme', 'الوضع الفاتح'),
('en', 'select_language', 'Select Language'), ('ar', 'select_language', 'اختر اللغة'),
('en', 'password', 'Password'), ('ar', 'password', 'كلمة المرور'),
('en', 'access_denied', 'Access Denied'), ('ar', 'access_denied', 'الوصول مرفوض'),
('en', 'no_permission_message', 'You do not have permission to view this page.'), ('ar', 'no_permission_message', 'ليس لديك الصلاحية لعرض هذه الصفحة.'),
('en', 'loading', 'Loading'), ('ar', 'loading', 'جاري التحميل'),
('en', 'no_role', 'No Role'), ('ar', 'no_role', 'بدون صلاحية'),
('en', 'select_role', 'Select Role'), ('ar', 'select_role', 'اختر صلاحية'),
('en', 'edit_role', 'Edit Role'), ('ar', 'edit_role', 'تعديل الصلاحية'),
('en', 'create_account', 'Create Account'), ('ar', 'create_account', 'إنشاء حساب'),
('en', 'sign_up', 'Sign Up'), ('ar', 'sign_up', 'تسجيل'),
('en', 'login', 'Login'), ('ar', 'login', 'تسجيل الدخول'),
('en', 'remember_me', 'Remember me'), ('ar', 'remember_me', 'تذكرني'),
('en', 'already_have_account', 'Already have an account? Log in'), ('ar', 'already_have_account', 'لديك حساب بالفعل؟ سجل الدخول'),
('en', 'create_new_account', 'Need an account? Sign up'), ('ar', 'create_new_account', 'تحتاج حساب؟ قم بالتسجيل'),
('en', 'signup_success', 'Account created! Please check your email to confirm.'), ('ar', 'signup_success', 'تم إنشاء الحساب! يرجى التحقق من بريدك الإلكتروني للتأكيد.'),
('en', 'site_settings', 'Site Settings'), ('ar', 'site_settings', 'إعدادات الموقع'),
('en', 'site_title_en', 'Site Title (English)'), ('ar', 'site_title_en', 'عنوان الموقع (انجليزي)'),
('en', 'site_title_ar', 'Site Title (Arabic)'), ('ar', 'site_title_ar', 'عنوان الموقع (عربي)'),
('en', 'site_logo', 'Site Logo (SVG Code)'), ('ar', 'site_logo', 'شعار الموقع (كود SVG)'),
('en', 'save_success', 'Settings saved successfully!'), ('ar', 'save_success', 'تم حفظ الإعدادات بنجاح!'),
('en', 'save_error', 'Failed to save settings.'), ('ar', 'save_error', 'فشل حفظ الإعدادات.'),
('en', 'saving', 'Saving'), ('ar', 'saving', 'جاري الحفظ'),
('en', 'n_a', 'N/A'), ('ar', 'n_a', 'غير متوفر'),
('en', 'cannot_edit_last_admin', 'Cannot change the role of the last admin.'), ('ar', 'cannot_edit_last_admin', 'لا يمكن تغيير صلاحية آخر مدير.'),
('en', 'select_role_to_manage', 'Select a role to manage its permissions.'), ('ar', 'select_role_to_manage', 'اختر صلاحية لإدارة أذوناتها.'),
('en', 'admin_role_note', 'Admin permissions cannot be changed.'), ('ar', 'admin_role_note', 'لا يمكن تغيير أذونات صلاحية المدير.'),
('en', 'add_new_user', 'Add New User'), ('ar', 'add_new_user', 'إضافة مستخدم جديد'),
('en', 'edit_user', 'Edit User'), ('ar', 'edit_user', 'تعديل المستخدم'),
('en', 'password_initial', 'Password (Initial)'), ('ar', 'password_initial', 'كلمة المرور (مبدئية)'),
('en', 'edit', 'Edit'), ('ar', 'edit', 'تعديل'),
('en', 'send_password_reset', 'Send Password Reset Email'), ('ar', 'send_password_reset', 'إرسال بريد إعادة تعيين كلمة المرور'),
('en', 'reset_password_email_sent', 'Reset email sent!'), ('ar', 'reset_password_email_sent', 'تم إرسال البريد!'),
('en', 'reset_password_email_error', 'Failed to send. Try again.'), ('ar', 'reset_password_email_error', 'فشل الإرسال. حاول مجدداً.'),
('en', 'landing_page_description', 'Welcome to your secure management portal.'), 
('ar', 'landing_page_description', 'أهلاً بك في بوابة الإدارة الآمنة.')
ON CONFLICT (lang_id, key) DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # USER NOTES FEATURE - ADDED 2024-08-01
-- #############################################################################
BEGIN;

-- Create the user_notes table.
CREATE TABLE IF NOT EXISTS public.user_notes (
  id BIGSERIAL PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  note_content TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.user_notes IS 'Stores notes and feedback submitted by users.';

-- Add the new permission to the permissions table.
INSERT INTO public.permissions (action, description)
VALUES
  ('manage:user_notes', 'Can view, manage, and export all user-submitted notes.'),
  ('submit:user_notes', 'Can access the "My Notes" page to submit feedback.')
ON CONFLICT (action) DO UPDATE SET description = EXCLUDED.description;

-- Assign the new permission to the Admin role.
DO $$
DECLARE
    admin_role_id UUID;
    user_role_id UUID;
    manage_notes_perm_id UUID;
    submit_notes_perm_id UUID;
BEGIN
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    SELECT id INTO user_role_id FROM public.roles WHERE name = 'User';
    SELECT id INTO manage_notes_perm_id FROM public.permissions WHERE action = 'manage:user_notes';
    SELECT id INTO submit_notes_perm_id FROM public.permissions WHERE action = 'submit:user_notes';

    -- Assign manage permission to Admin
    IF admin_role_id IS NOT NULL AND manage_notes_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, manage_notes_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
    END IF;

    -- Assign submit permission to BOTH Admin and User by default
    IF admin_role_id IS NOT NULL AND submit_notes_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, submit_notes_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
    END IF;

    IF user_role_id IS NOT NULL AND submit_notes_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (user_role_id, submit_notes_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
    END IF;

END $$;

-- Set up Row Level Security (RLS) on the new table.
ALTER TABLE public.user_notes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow users to insert their own notes" ON public.user_notes;
CREATE POLICY "Allow users to insert their own notes"
    ON public.user_notes FOR INSERT
    WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Allow managers to read all notes" ON public.user_notes;
CREATE POLICY "Allow managers to read all notes"
    ON public.user_notes FOR SELECT
    USING (public.has_permission('manage:user_notes'));

-- Create RPC functions for secure data access.
CREATE OR REPLACE FUNCTION public.submit_user_note(p_note_content TEXT)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO public.user_notes (user_id, note_content)
  VALUES (auth.uid(), p_note_content);
END;
$$;

CREATE OR REPLACE FUNCTION public.get_all_user_notes(page_num INT, page_size INT, search_query TEXT DEFAULT '')
RETURNS TABLE (
    id bigint,
    created_at timestamptz,
    user_id uuid,
    note_content text,
    user_full_name text,
    user_email text,
    total_count bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
  query_offset INT;
BEGIN
  IF NOT public.has_permission('manage:user_notes') THEN
    RETURN;
  END IF;

  query_offset := (page_num - 1) * page_size;

  RETURN QUERY
  WITH filtered_notes AS (
    SELECT
      un.id,
      un.created_at,
      un.user_id,
      un.note_content,
      p.full_name AS user_full_name,
      p.email AS user_email
    FROM public.user_notes un
    JOIN public.profiles p ON un.user_id = p.id
    WHERE
      (search_query = '' OR search_query IS NULL OR p.email ILIKE '%' || search_query || '%' OR p.full_name ILIKE '%' || search_query || '%' OR un.note_content ILIKE '%' || search_query || '%')
  )
  SELECT
    fn.id,
    fn.created_at,
    fn.user_id,
    fn.note_content,
    fn.user_full_name,
    fn.user_email,
    count(*) OVER() AS total_count
  FROM filtered_notes fn
  ORDER BY fn.created_at DESC
  OFFSET query_offset
  LIMIT page_size;
END;
$$;

-- Add required UI translations.
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'user_notes', 'My Notes'),
('ar', 'user_notes', 'ملاحظاتي'),
('en', 'manage_user_notes', 'Manage User Notes'),
('ar', 'manage_user_notes', 'إدارة ملاحظات المستخدمين'),
('en', 'perm_manage_user_notes', 'Manage User Notes'),
('ar', 'perm_manage_user_notes', 'إدارة ملاحظات المستخدمين'),
('en', 'perm_manage_user_notes_desc', 'Can view, manage, and export all user-submitted notes.'),
('ar', 'perm_manage_user_notes_desc', 'يمكنه عرض وإدارة وتصدير جميع الملاحظات المقدمة من المستخدمين.'),
('en', 'perm_submit_user_notes', 'Submit User Notes'),
('ar', 'perm_submit_user_notes', 'إرسال ملاحظات المستخدم'),
('en', 'perm_submit_user_notes_desc', 'Can access the "My Notes" page to submit feedback.'),
('ar', 'perm_submit_user_notes_desc', 'يمكنه الوصول إلى صفحة "ملاحظاتي" لإرسال الملاحظات.'),
('en', 'submit_your_notes', 'Submit Your Notes'),
('ar', 'submit_your_notes', 'أرسل ملاحظاتك'),
('en', 'write_your_notes_here', 'Write your notes here...'),
('ar', 'write_your_notes_here', 'اكتب ملاحظاتك هنا...'),
('en', 'save_and_send', 'Save and Send'),
('ar', 'save_and_send', 'حفظ وإرسال'),
('en', 'note_submitted_successfully', 'Your note has been submitted successfully. Thank you!'),
('ar', 'note_submitted_successfully', 'تم إرسال ملاحظتك بنجاح. شكراً لك!'),
('en', 'note_submission_failed', 'Failed to submit your note. Please try again.'),
('ar', 'note_submission_failed', 'فشل إرسال ملاحظتك. يرجى المحاولة مرة أخرى.'),
('en', 'note_content', 'Note Content'),
('ar', 'note_content', 'محتوى الملاحظة'),
('en', 'submitted_by', 'Submitted By'),
('ar', 'submitted_by', 'مقدمة من'),
('en', 'submission_date', 'Date'),
('ar', 'submission_date', 'التاريخ'),
('en', 'export_csv', 'Export CSV'),
('ar', 'export_csv', 'تصدير CSV'),
('en', 'print', 'Print'),
('ar', 'print', 'طباعة'),
('en', 'search_notes', 'Search by user or note content...'),
('ar', 'search_notes', 'ابحث بالمستخدم أو محتوى الملاحظة...')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
CREATE TABLE IF NOT EXISTS public.nasdaq_daily_snapshot (
  trading_date        DATE PRIMARY KEY,
  close_price         NUMERIC(12,2),
  change_points       NUMERIC(12,2),
  change_percent      NUMERIC(6,2),
  open_price          NUMERIC(12,2),
  high_price          NUMERIC(12,2),
  low_price           NUMERIC(12,2),
  volume              BIGINT,
  advancers_count     INTEGER,
  decliners_count     INTEGER,
  leading_sector      TEXT,
  lagging_sector      TEXT,
  headline            TEXT,
  headline_source     TEXT,
  heatmap_json        JSONB,
  sectors_json        JSONB,
  metadata_json       JSONB,
  created_at          TIMESTAMP WITH TIME ZONE DEFAULT now()
);

COMMENT ON TABLE public.nasdaq_daily_snapshot IS 'Stores end-of-day snapshot metrics for the NASDAQ index.';
COMMENT ON COLUMN public.nasdaq_daily_snapshot.heatmap_json IS 'JSON array describing top contributing symbols (e.g. symbol, weight, change_percent).';
COMMENT ON COLUMN public.nasdaq_daily_snapshot.sectors_json IS 'JSON array describing sector performance for the session.';
COMMENT ON COLUMN public.nasdaq_daily_snapshot.metadata_json IS 'Additional free-form metadata collected with the snapshot.';

CREATE INDEX IF NOT EXISTS idx_nasdaq_daily_snapshot_created_at
  ON public.nasdaq_daily_snapshot (created_at DESC);

CREATE OR REPLACE FUNCTION public.upsert_nasdaq_daily_snapshot(
  p_trading_date        DATE,
  p_close_price         NUMERIC,
  p_change_points       NUMERIC,
  p_change_percent      NUMERIC,
  p_open_price          NUMERIC,
  p_high_price          NUMERIC,
  p_low_price           NUMERIC,
  p_volume              BIGINT,
  p_advancers_count     INTEGER,
  p_decliners_count     INTEGER,
  p_leading_sector      TEXT,
  p_lagging_sector      TEXT,
  p_headline            TEXT,
  p_headline_source     TEXT,
  p_heatmap_json        JSONB,
  p_sectors_json        JSONB,
  p_metadata_json       JSONB
)
RETURNS public.nasdaq_daily_snapshot
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS
$$
DECLARE
  v_record public.nasdaq_daily_snapshot;
BEGIN
  INSERT INTO public.nasdaq_daily_snapshot AS s (
    trading_date,
    close_price,
    change_points,
    change_percent,
    open_price,
    high_price,
    low_price,
    volume,
    advancers_count,
    decliners_count,
    leading_sector,
    lagging_sector,
    headline,
    headline_source,
    heatmap_json,
    sectors_json,
    metadata_json,
    created_at
  ) VALUES (
    p_trading_date,
    p_close_price,
    p_change_points,
    p_change_percent,
    p_open_price,
    p_high_price,
    p_low_price,
    p_volume,
    p_advancers_count,
    p_decliners_count,
    p_leading_sector,
    p_lagging_sector,
    p_headline,
    p_headline_source,
    COALESCE(p_heatmap_json, '[]'::jsonb),
    COALESCE(p_sectors_json, '[]'::jsonb),
    COALESCE(p_metadata_json, '{}'::jsonb),
    now()
  )
  ON CONFLICT (trading_date) DO UPDATE
  SET close_price = EXCLUDED.close_price,
      change_points = EXCLUDED.change_points,
      change_percent = EXCLUDED.change_percent,
      open_price = EXCLUDED.open_price,
      high_price = EXCLUDED.high_price,
      low_price = EXCLUDED.low_price,
      volume = EXCLUDED.volume,
      advancers_count = EXCLUDED.advancers_count,
      decliners_count = EXCLUDED.decliners_count,
      leading_sector = EXCLUDED.leading_sector,
      lagging_sector = EXCLUDED.lagging_sector,
      headline = EXCLUDED.headline,
      headline_source = EXCLUDED.headline_source,
      heatmap_json = EXCLUDED.heatmap_json,
      sectors_json = EXCLUDED.sectors_json,
      metadata_json = EXCLUDED.metadata_json,
      created_at = now()
  RETURNING * INTO v_record;

  RETURN v_record;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_latest_nasdaq_snapshot()
RETURNS public.nasdaq_daily_snapshot
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS
$$
  SELECT s.*
  FROM public.nasdaq_daily_snapshot s
  ORDER BY s.trading_date DESC
  LIMIT 1;
$$;

GRANT SELECT ON public.nasdaq_daily_snapshot TO anon, authenticated;
GRANT INSERT, UPDATE, DELETE ON public.nasdaq_daily_snapshot TO service_role;
GRANT EXECUTE ON FUNCTION public.get_latest_nasdaq_snapshot() TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.upsert_nasdaq_daily_snapshot(
  DATE, NUMERIC, NUMERIC, NUMERIC, NUMERIC, NUMERIC, NUMERIC, BIGINT,
  INTEGER, INTEGER, TEXT, TEXT, TEXT, TEXT, JSONB, JSONB, JSONB
) TO service_role;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Email to Profiles Table
-- #
-- # Purpose: This script safely updates an existing database to fix the
-- # "column profiles.email does not exist" error.
-- #
-- # It performs two actions:
-- # 1. Adds the `email` column to the `profiles` table if it does not exist.
-- # 2. Populates the new `email` column with data from `auth.users`.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

-- Step 1: Add the 'email' column to the 'profiles' table if it's missing.
-- This uses a DO block to conditionally add the column, preventing errors if run again.
DO $$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM information_schema.columns WHERE table_schema = 'public' AND table_name='profiles' AND column_name='email') THEN
       ALTER TABLE public.profiles ADD COLUMN email text UNIQUE;
       RAISE NOTICE 'SUCCESS: Column "email" added to "profiles" table.';
    ELSE
       RAISE NOTICE 'INFO: Column "email" already exists in "profiles" table. No action taken.';
    END IF;
END $$;


-- Step 2: Populate the 'email' column for any existing users.
-- This updates profiles where the email is currently NULL, fetching the correct
-- email from the corresponding user in `auth.users`.
DO $$
DECLARE
    rows_updated integer;
BEGIN
    UPDATE public.profiles p
    SET email = u.email
    FROM auth.users u
    WHERE p.id = u.id AND p.email IS NULL;

    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    RAISE NOTICE 'SUCCESS: Populated email for % existing user(s).', rows_updated;
END $$;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update RLS Policies for Permission-Based Access
-- #
-- # Purpose: This script replaces the old role-name-based security rules
-- # with a more flexible and secure permission-based system. This will fix
-- # issues where users (like Supervisors) couldn't see the user list.
-- #
-- # It performs three main actions:
-- # 1. Creates a new helper function `has_permission(permission_action text)`.
-- # 2. Drops the old, restrictive policies on several tables.
-- # 3. Creates new, permission-based policies.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

-- Step 1: Create the permission-checking helper function.
-- This function checks if the currently logged-in user has a specific permission
-- through their assigned role.
CREATE OR REPLACE FUNCTION public.has_permission(permission_action text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    user_role_id UUID;
    permission_id_to_check UUID;
BEGIN
    -- Get the current user's role_id from their profile
    SELECT role_id INTO user_role_id FROM public.profiles WHERE id = auth.uid();
    
    IF user_role_id IS NULL THEN
        RETURN FALSE;
    END IF;

    -- Get the permission's id from its action name
    SELECT id INTO permission_id_to_check FROM public.permissions WHERE action = permission_action;

    IF permission_id_to_check IS NULL THEN
        RETURN FALSE;
    END IF;

    -- Check if a mapping exists in role_permissions
    RETURN EXISTS (
        SELECT 1
        FROM public.role_permissions
        WHERE role_id = user_role_id AND permission_id = permission_id_to_check
    );
END;
$$;
-- RAISE NOTICE 'SUCCESS: Helper function `has_permission` created or updated.';

-- Step 2: Update RLS policies for the 'profiles' table.
-- This allows users with 'manage:users' permission to manage all profiles.
DROP POLICY IF EXISTS "Allow admin read access on profiles" ON "public"."profiles";
DROP POLICY IF EXISTS "Allow admin full access on profiles" ON "public"."profiles";

CREATE POLICY "Allow managers full access on profiles" ON "public"."profiles"
FOR ALL USING (public.has_permission('manage:users'));
-- RAISE NOTICE 'SUCCESS: Updated RLS policies for "profiles" table.';

-- Step 3: Update RLS policies for roles & permissions management tables.
-- This allows users with 'manage:roles' permission to manage them.
DROP POLICY IF EXISTS "Allow admin full access on roles" ON "public"."roles";
CREATE POLICY "Allow role managers full access on roles" ON "public"."roles"
FOR ALL USING (public.has_permission('manage:roles'));

DROP POLICY IF EXISTS "Allow admin full access on permissions" ON "public"."permissions";
CREATE POLICY "Allow role managers full access on permissions" ON "public"."permissions"
FOR ALL USING (public.has_permission('manage:roles'));

DROP POLICY IF EXISTS "Allow admin full access on role_permissions" ON "public"."role_permissions";
CREATE POLICY "Allow role managers full access on role_permissions" ON "public"."role_permissions"
FOR ALL USING (public.has_permission('manage:roles'));
-- RAISE NOTICE 'SUCCESS: Updated RLS policies for roles and permissions tables.';


-- Step 4: Update RLS policies for settings management tables.
-- This allows users with 'manage:settings' permission to manage them.
DROP POLICY IF EXISTS "Allow admin write access on translations" ON "public"."translations";
CREATE POLICY "Allow settings managers full access on translations" ON "public"."translations"
FOR ALL USING (public.has_permission('manage:settings'));

DROP POLICY IF EXISTS "Allow admin write access on app_settings" ON "public"."app_settings";
CREATE POLICY "Allow settings managers full access on app_settings" ON "public"."app_settings"
FOR ALL USING (public.has_permission('manage:settings'));
-- RAISE NOTICE 'SUCCESS: Updated RLS policies for settings and translations tables.';
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Ensure At Least One Admin User Exists
-- #
-- # Purpose: This script addresses the common setup issue where no user has
-- # the 'Admin' role, preventing them from seeing the user list.
-- #
-- # It performs one key action:
-- # 1. It finds the OLDEST user in the system (the first one to sign up).
-- # 2. If NO users currently have the 'Admin' role, it assigns the 'Admin'
-- #    role to that oldest user.
-- #
-- # This is a safe, one-time operation to ensure the dashboard is usable
-- # after initial setup. It will not change anything if an Admin already exists.
-- #
-- #############################################################################

DO $$
DECLARE
    admin_role_id UUID;
    first_user_id UUID;
    admin_count INTEGER;
BEGIN
    -- Step 1: Find the ID for the 'Admin' role.
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin' LIMIT 1;

    IF NOT FOUND THEN
        RAISE WARNING 'Could not find the "Admin" role. Please ensure the initial setup script has been run. Aborting.';
        RETURN;
    END IF;

    -- Step 2: Check if any user already has the Admin role.
    SELECT count(*) INTO admin_count FROM public.profiles WHERE role_id = admin_role_id;

    IF admin_count > 0 THEN
        RAISE NOTICE 'INFO: An Admin user already exists. No changes needed.';
        RETURN;
    END IF;

    -- Step 3: If no admin exists, find the first user who signed up.
    RAISE NOTICE 'No admin user found. Attempting to assign the role to the first user.';
    SELECT u.id INTO first_user_id FROM auth.users u ORDER BY u.created_at ASC LIMIT 1;

    IF NOT FOUND THEN
        RAISE WARNING 'Could not find any users in the auth.users table. Aborting.';
        RETURN;
    END IF;

    -- Step 4: Assign the 'Admin' role to the first user.
    UPDATE public.profiles
    SET role_id = admin_role_id
    WHERE id = first_user_id;

    RAISE NOTICE 'SUCCESS: Assigned the "Admin" role to the user with ID %. They can now manage the dashboard.', first_user_id;

END $$;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Grant Super Admin privileges to the First User
-- #
-- # Purpose: This script provides a robust, automatic fix for the initial setup
-- # problem where no user can manage the dashboard. It grants the very first
-- # user who signed up full administrative privileges, ensuring the dashboard
-- # is always manageable.
-- #
-- # It performs three main actions:
-- # 1. Creates a new helper function `is_first_user()` to identify the system's
-- #    first registered user.
-- # 2. Updates the security policies on all managed tables (`profiles`, `roles`,
-- #    `permissions`, `settings`, etc.) to grant access if the current user
-- #    EITHER has the required permission OR is the first user.
-- #
-- # This script makes the system self-configuring and is safe to run multiple times.
-- #
-- #############################################################################

-- Step 1: Create the `is_first_user` helper function.
-- This function checks if the currently logged-in user is the one with the
-- oldest `created_at` timestamp in the `auth.users` table.
CREATE OR REPLACE FUNCTION public.is_first_user()
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
-- IMPORTANT: The search_path is required for security definer functions
-- to find tables in other schemas, like `auth.users`.
SET search_path = auth, public
AS $$
    SELECT auth.uid() = (SELECT id FROM auth.users ORDER BY created_at ASC LIMIT 1);
$$;
-- RAISE NOTICE 'SUCCESS: Helper function `is_first_user` created or updated.';


-- Step 2: Update RLS policy for the 'profiles' table.
-- Allows access for users with 'manage:users' OR the first user.
DROP POLICY IF EXISTS "Allow managers full access on profiles" ON "public"."profiles";
CREATE POLICY "Allow managers full access on profiles" ON "public"."profiles"
FOR ALL USING (public.has_permission('manage:users') OR public.is_first_user());
-- RAISE NOTICE 'SUCCESS: Updated RLS policies for "profiles" table.';

ش
-- Step 3: Update RLS policies for roles & permissions management tables.
-- Allows access for users with 'manage:roles' OR the first user.
DROP POLICY IF EXISTS "Allow role managers full access on roles" ON "public"."roles";
CREATE POLICY "Allow role managers full access on roles" ON "public"."roles"
FOR ALL USING (public.has_permission('manage:roles') OR public.is_first_user());

DROP POLICY IF EXISTS "Allow role managers full access on permissions" ON "public"."permissions";
CREATE POLICY "Allow role managers full access on permissions" ON "public"."permissions"
FOR ALL USING (public.has_permission('manage:roles') OR public.is_first_user());

DROP POLICY IF EXISTS "Allow role managers full access on role_permissions" ON "public"."role_permissions";
CREATE POLICY "Allow role managers full access on role_permissions" ON "public"."role_permissions"
FOR ALL USING (public.has_permission('manage:roles') OR public.is_first_user());
-- RAISE NOTICE 'SUCCESS: Updated RLS policies for roles and permissions tables.';


-- Step 4: Update RLS policies for settings management tables.
-- Allows access for users with 'manage:settings' OR the first user.
DROP POLICY IF EXISTS "Allow settings managers full access on translations" ON "public"."translations";
CREATE POLICY "Allow settings managers full access on translations" ON "public"."translations"
FOR ALL USING (public.has_permission('manage:settings') OR public.is_first_user());

DROP POLICY IF EXISTS "Allow settings managers full access on app_settings" ON "public"."app_settings";
CREATE POLICY "Allow settings managers full access on app_settings" ON "public"."app_settings"
FOR ALL USING (public.has_permission('manage:settings') OR public.is_first_user());
-- RAISE NOTICE 'SUCCESS: Updated RLS policies for settings and translations tables.';
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Revert "First User as Super Admin" Logic
-- #
-- # Purpose: This script completely removes the special "super admin" logic
-- # for the first user and reverts the security policies back to a simple,
-- # permission-based system.
-- #
-- # It performs two main actions:
-- # 1. It drops the `is_first_user()` helper function.
-- # 2. It reverts the security policies on all tables to ONLY use the
-- #    `has_permission()` check, removing the "OR is_first_user()" clause.
-- #
-- # This script restores the simple, database-driven security model.
-- #
-- #############################################################################

-- Step 1: Drop the `is_first_user` helper function.
DROP FUNCTION IF EXISTS public.is_first_user();
RAISE NOTICE 'SUCCESS: Helper function `is_first_user` has been removed.';


-- Step 2: Revert RLS policy for the 'profiles' table.
-- Allows access ONLY for users with 'manage:users'.
DROP POLICY IF EXISTS "Allow managers full access on profiles" ON "public"."profiles";
CREATE POLICY "Allow managers full access on profiles" ON "public"."profiles"
FOR ALL USING (public.has_permission('manage:users'));
RAISE NOTICE 'SUCCESS: Reverted RLS policies for "profiles" table.';


-- Step 3: Revert RLS policies for roles & permissions management tables.
-- Allows access ONLY for users with 'manage:roles'.
DROP POLICY IF EXISTS "Allow role managers full access on roles" ON "public"."roles";
CREATE POLICY "Allow role managers full access on roles" ON "public"."roles"
FOR ALL USING (public.has_permission('manage:roles'));

DROP POLICY IF EXISTS "Allow role managers full access on permissions" ON "public"."permissions";
CREATE POLICY "Allow role managers full access on permissions" ON "public"."permissions"
FOR ALL USING (public.has_permission('manage:roles'));

DROP POLICY IF EXISTS "Allow role managers full access on role_permissions" ON "public"."role_permissions";
CREATE POLICY "Allow role managers full access on role_permissions" ON "public"."role_permissions"
FOR ALL USING (public.has_permission('manage:roles'));
RAISE NOTICE 'SUCCESS: Reverted RLS policies for roles and permissions tables.';


-- Step 4: Revert RLS policies for settings management tables.
-- Allows access ONLY for users with 'manage:settings'.
DROP POLICY IF EXISTS "Allow settings managers full access on translations" ON "public"."translations";
CREATE POLICY "Allow settings managers full access on translations" ON "public"."translations"
FOR ALL USING (public.has_permission('manage:settings'));

DROP POLICY IF EXISTS "Allow settings managers full access on app_settings" ON "public"."app_settings";
CREATE POLICY "Allow settings managers full access on app_settings" ON "public"."app_settings"
FOR ALL USING (public.has_permission('manage:settings'));
RAISE NOTICE 'SUCCESS: Reverted RLS policies for settings and translations tables.';

RAISE NOTICE '----------------------------------------------------------';
RAISE NOTICE 'REVERSION COMPLETE: "Super Admin" logic has been removed.';
RAISE NOTICE '----------------------------------------------------------';
-- #############################################################################
-- #
-- # MIGRATION SCRIPT (V6): Definitive User & Admin Fix
-- #
-- # Purpose: This is the primary script to fix all common permission and user
-- # creation issues. It is safe to run multiple times on an existing database.
-- #
-- # It performs two critical actions:
-- # 1. ENSURE ADMIN: It checks if an 'Admin' user exists. If not, it
-- #    promotes the very first user who signed up to be an Admin. This
-- #    guarantees the dashboard is always manageable.
-- #
-- # 2. FIX USER CREATION: It updates the `handle_new_user` trigger to be
-- #    smarter. It will still make the first user ever an Admin, but it will
-- #    also assign a default 'User' role to all subsequent new users,
-- #    preventing them from being created without any role.
-- #
-- #############################################################################

-- Step 1: Ensure at least one admin user exists.
DO $$
DECLARE
    admin_role_id UUID;
    first_user_id UUID;
    admin_count INTEGER;
BEGIN
    -- Find the ID for the 'Admin' role.
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin' LIMIT 1;
    IF NOT FOUND THEN
        RAISE WARNING 'CRITICAL: The "Admin" role does not exist. Cannot proceed.';
        RETURN;
    END IF;

    -- Check if any user already has the Admin role.
    SELECT count(*) INTO admin_count FROM public.profiles WHERE role_id = admin_role_id;
    IF admin_count > 0 THEN
        RAISE NOTICE 'INFO: An Admin user already exists. No changes needed for admin promotion.';
    ELSE
        -- If no admin exists, find the first user who ever signed up.
        RAISE NOTICE 'WARNING: No admin user found. Attempting to promote the first user.';
        SELECT u.id INTO first_user_id FROM auth.users u ORDER BY u.created_at ASC LIMIT 1;

        IF NOT FOUND THEN
            RAISE WARNING 'CRITICAL: No users found in the system. Cannot promote an admin.';
            RETURN;
        END IF;

        -- Assign the 'Admin' role to that first user's profile.
        UPDATE public.profiles
        SET role_id = admin_role_id
        WHERE id = first_user_id;
        RAISE NOTICE 'SUCCESS: Assigned the "Admin" role to user ID %. The dashboard is now manageable.', first_user_id;
    END IF;
END $$;


-- Step 2: Update the user creation trigger for robust role assignment.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
  user_count integer;
  admin_role_id uuid;
  default_user_role_id uuid;
  target_role_id uuid;
BEGIN
  -- Always create the profile entry first
  INSERT INTO public.profiles (id, full_name, email)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.email);

  -- Check the total number of users in the system
  SELECT count(*) INTO user_count FROM auth.users;

  -- Determine which role to assign
  IF user_count = 1 THEN
    -- This is the very first user. They become Admin.
    RAISE NOTICE 'First user detected. Assigning Admin role.';
    SELECT id INTO target_role_id FROM public.roles WHERE name = 'Admin';
  ELSE
    -- This is a subsequent user. They get the default 'User' role.
    RAISE NOTICE 'New user detected. Assigning default User role.';
    SELECT id INTO target_role_id FROM public.roles WHERE name = 'User';
  END IF;

  -- Assign the determined role
  IF target_role_id IS NOT NULL THEN
    UPDATE public.profiles
    SET role_id = target_role_id
    WHERE id = new.id;
  ELSE
     RAISE WARNING 'Could not find a suitable role (Admin or User) to assign to the new user %.', new.id;
  END IF;

  RETURN new;
END;
$$;
RAISE NOTICE 'SUCCESS: The `handle_new_user` trigger has been updated to robustly assign roles.';

-- The trigger is already associated with the auth.users table via the setup script.
-- Using `CREATE OR REPLACE` here ensures it is updated safely.
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add User Modal Translations
-- #
-- # Purpose: This is a safe, additive-only script. It inserts the new
-- # translation keys required for the user add/edit modal features.
-- # It will not delete or alter any existing tables or data.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to insert system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Seed the new translations for English and Arabic.
-- The ON CONFLICT clause ensures that if a key already exists, it will be
-- updated instead of causing an error, making the script safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'add_new_user', 'Add New User'),
('ar', 'add_new_user', 'إضافة مستخدم جديد'),
('en', 'edit_user', 'Edit User'),
('ar', 'edit_user', 'تعديل المستخدم'),
('en', 'password_initial', 'Password (Initial)'),
('ar', 'password_initial', 'كلمة المرور (مبدئية)'),
('en', 'edit', 'Edit'),
('ar', 'edit', 'تعديل'),
('en', 'send_password_reset', 'Send Password Reset Email'),
('ar', 'send_password_reset', 'إرسال بريد إعادة تعيين كلمة المرور'),
('en', 'reset_password_email_sent', 'Reset email sent!'),
('ar', 'reset_password_email_sent', 'تم إرسال البريد!'),
('en', 'reset_password_email_error', 'Failed to send. Try again.'),
('ar', 'reset_password_email_error', 'فشل الإرسال. حاول مجدداً.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Landing Page Translations
-- #
-- # Purpose: This is a safe, additive-only script. It inserts the new
-- # translation keys required for the new public landing page.
-- # It will not delete or alter any existing tables or data.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to insert system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Seed the new translations for English and Arabic.
-- The ON CONFLICT clause ensures that if a key already exists, it will be
-- updated instead of causing an error, making the script safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'landing_page_description', 'Welcome to your secure management portal.'),
('ar', 'landing_page_description', 'أهلاً بك في بوابة الإدارة الآمنة.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update "Login" Translation
-- #
-- # Purpose: This is a safe, data-only script. It updates the Arabic
-- # translation for the 'login' key to be more accurate ('تسجيل الدخول').
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Update the Arabic translation for the 'login' key.
-- The ON CONFLICT clause ensures this works as an upsert, which is safe.
INSERT INTO public.translations (lang_id, key, value) VALUES
('ar', 'login', 'تسجيل الدخول')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Remove "admin_login" Translation
-- #
-- # Purpose: This script removes the now-unused 'admin_login' translation key
-- # from the database to keep it clean.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Delete the 'admin_login' key for all languages.
DELETE FROM public.translations WHERE key = 'admin_login';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Email Confirmation Notification Translations
-- #
-- # Purpose: This is a safe, data-only script. It adds the translation
-- # key needed for the improved "Email not confirmed" message on the login page.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'email_not_confirmed_message', 'Please check your email for a confirmation link to activate your account.'),
('ar', 'email_not_confirmed_message', 'يرجى التحقق من بريدك الإلكتروني والنقر على رابط التأكيد لتفعيل حسابك.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Manual User Activation Functionality
-- #
-- # Purpose: This script adds the necessary database structures to allow
-- # an admin to manually confirm/activate a user's email from the dashboard.
-- #
-- # It performs four key actions:
-- # 1. Adds an `email_confirmed_at` column to the `public.profiles` table.
-- # 2. Creates a trigger to automatically keep this new column in sync with
-- #    the master `auth.users` table.
-- # 3. Backfills the data for all existing users to ensure consistency.
-- # 4. Creates a secure PostgreSQL function `manually_confirm_user` that can
-- #    be called from the app to perform the activation.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Add the `email_confirmed_at` column to the `profiles` table if it doesn't exist.
DO $$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM information_schema.columns WHERE table_schema = 'public' AND table_name='profiles' AND column_name='email_confirmed_at') THEN
       ALTER TABLE public.profiles ADD COLUMN email_confirmed_at timestamp with time zone;
       RAISE NOTICE 'SUCCESS: Column "email_confirmed_at" added to "profiles" table.';
    ELSE
       RAISE NOTICE 'INFO: Column "email_confirmed_at" already exists in "profiles" table. No action taken.';
    END IF;
END $$;


-- Step 2: Create the trigger function to sync confirmation status from auth.users to profiles.
CREATE OR REPLACE FUNCTION public.sync_user_confirmation_to_profile()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
-- IMPORTANT: Set the search_path to handle schemas correctly.
SET search_path = public
AS $$
BEGIN
  -- When a user's confirmation status changes in auth.users, update the corresponding profile.
  UPDATE public.profiles
  SET email_confirmed_at = NEW.email_confirmed_at
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$;
RAISE NOTICE 'SUCCESS: Trigger function `sync_user_confirmation_to_profile` created or updated.';

-- Step 3: Create the trigger on the `auth.users` table.
-- This ensures that whenever a user is created or updated (e.g., confirms their email),
-- the change is mirrored to their public profile.
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;
CREATE TRIGGER on_auth_user_updated
  AFTER INSERT OR UPDATE OF email_confirmed_at ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.sync_user_confirmation_to_profile();
RAISE NOTICE 'SUCCESS: Trigger `on_auth_user_updated` created on `auth.users` table.';


-- Step 4: Backfill the `email_confirmed_at` for existing users.
-- This ensures all current users have the correct status reflected in their profile.
DO $$
DECLARE
    rows_updated integer;
BEGIN
    UPDATE public.profiles p
    SET email_confirmed_at = u.email_confirmed_at
    FROM auth.users u
    WHERE p.id = u.id AND p.email_confirmed_at IS DISTINCT FROM u.email_confirmed_at;

    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    RAISE NOTICE 'SUCCESS: Backfilled email confirmation status for % existing user(s).', rows_updated;
END $$;


-- Step 5: Create the secure RPC function for manual activation.
CREATE OR REPLACE FUNCTION public.manually_confirm_user(user_id_to_confirm uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Security Check: Only allow users with 'manage:users' permission to run this.
  IF NOT public.has_permission('manage:users') THEN
    RAISE EXCEPTION 'Insufficient permissions: You need the "manage:users" permission to perform this action.';
  END IF;

  -- Perform the privileged action: Update the user's status in the auth schema.
  UPDATE auth.users
  SET email_confirmed_at = now()
  WHERE id = user_id_to_confirm;
END;
$$;
RAISE NOTICE 'SUCCESS: Secure RPC function `manually_confirm_user` created or updated.';


COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add User Activation UI Translations
-- #
-- # Purpose: This is a safe, data-only script. It adds all the translation
-- # keys needed for the new manual user activation feature, including table
-- # headers, status badges, button tooltips, and success/error notifications.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'status', 'Status'),
('ar', 'status', 'الحالة'),
('en', 'confirmed', 'Confirmed'),
('ar', 'confirmed', 'مؤكد'),
('en', 'pending_confirmation', 'Pending Confirmation'),
('ar', 'pending_confirmation', 'بانتظار التأكيد'),
('en', 'activate_user', 'Activate User'),
('ar', 'activate_user', 'تفعيل المستخدم'),
('en', 'user_activated_successfully', 'User has been activated successfully!'),
('ar', 'user_activated_successfully', 'تم تفعيل المستخدم بنجاح!'),
('en', 'user_activation_failed', 'Failed to activate user. Please try again.'),
('ar', 'user_activation_failed', 'فشل تفعيل المستخدم. يرجى المحاولة مرة أخرى.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Auto-Confirm First User & Fix Existing State
-- #
-- # Purpose: This script solves the "catch-22" problem where an admin cannot
-- # log in to activate users because their own account is unconfirmed and
-- # emails are not being sent.
-- #
-- # It performs two key actions:
-- # 1. FIX EXISTING STATE: It finds the first user ever created. If they are
-- #    not yet confirmed, it confirms them immediately.
-- # 2. FIX FUTURE STATE: It updates the `handle_new_user` trigger to
-- #    automatically confirm the email of any new *first user*, allowing them
-- #    to log in immediately and manage the dashboard.
-- #
-- # This script is safe to run multiple times and fixes the issue for both
-- # existing and new installations.
-- #
-- #############################################################################

BEGIN;

-- Part 1: Fix the existing state by confirming the first-ever user if they are unconfirmed.
DO $$
DECLARE
    first_user_id UUID;
BEGIN
    RAISE NOTICE 'Checking confirmation status of the first user...';

    -- Find the ID of the first user based on creation time.
    SELECT id INTO first_user_id
    FROM auth.users
    ORDER BY created_at ASC
    LIMIT 1;

    IF first_user_id IS NOT NULL THEN
        -- If a first user exists, check if they are confirmed.
        -- If not, confirm them now.
        UPDATE auth.users
        SET email_confirmed_at = now()
        WHERE id = first_user_id AND email_confirmed_at IS NULL;
        
        IF FOUND THEN
            RAISE NOTICE 'SUCCESS: The first user (ID: %) was unconfirmed and has now been activated.', first_user_id;
        ELSE
            RAISE NOTICE 'INFO: The first user (ID: %) is already confirmed. No changes needed.', first_user_id;
        END IF;
    ELSE
        RAISE NOTICE 'INFO: No users found in the system. Nothing to fix.';
    END IF;
END $$;


-- Part 2: Update the user creation trigger to handle future signups correctly.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
  user_count integer;
  target_role_id uuid;
BEGIN
  -- Create the profile entry for the new user
  INSERT INTO public.profiles (id, full_name, email)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.email);

  -- Check the total number of users
  SELECT count(*) INTO user_count FROM auth.users;

  -- Logic for the first user vs. subsequent users
  IF user_count = 1 THEN
    -- FIRST USER EVER: Make them an Admin and confirm their email instantly.
    RAISE NOTICE 'First user signing up. Assigning Admin role and auto-confirming email.';
    
    -- 1. Find the Admin role ID
    SELECT id INTO target_role_id FROM public.roles WHERE name = 'Admin';
    
    -- 2. Update the user in the auth schema to confirm them
    -- This is a privileged operation, allowed because the function is SECURITY DEFINER.
    UPDATE auth.users
    SET email_confirmed_at = now()
    WHERE id = new.id;

  ELSE
    -- SUBSEQUENT USERS: Assign the default 'User' role. They will need confirmation.
    RAISE NOTICE 'New user signing up. Assigning default User role.';
    SELECT id INTO target_role_id FROM public.roles WHERE name = 'User';
  END IF;

  -- Assign the determined role to the user's profile
  IF target_role_id IS NOT NULL THEN
    UPDATE public.profiles
    SET role_id = target_role_id
    WHERE id = new.id;
  ELSE
     RAISE WARNING 'Could not find a suitable role (Admin or User) to assign to the new user %.', new.id;
  END IF;

  RETURN new;
END;
$$;

RAISE NOTICE 'SUCCESS: The `handle_new_user` trigger has been updated to auto-confirm the first user upon creation.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add "Login Failed" Translation
-- #
-- # Purpose: This is a safe, data-only script. It adds the translation key
-- # needed for the error message when header login fails.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'login_failed', 'Invalid login credentials. Please try again.'),
('ar', 'login_failed', 'بيانات الدخول غير صحيحة. يرجى المحاولة مرة أخرى.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Global Announcements System
-- #
-- # Purpose: This script introduces a complete system for creating and
-- # displaying global announcements to all users.
-- #
-- # It performs four key actions:
-- # 1. Creates a new `global_announcements` table to store announcements.
-- # 2. Sets up Row Level Security (RLS) to allow public read access for
-- #    active announcements and restricted write access for managers.
-- # 3. Creates a new permission `manage:announcements` in the database.
-- # 4. Assigns the new permission to the 'Admin' role by default.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the global_announcements table.
CREATE TABLE IF NOT EXISTS public.global_announcements (
  id BIGSERIAL PRIMARY KEY,
  title JSONB NOT NULL,
  message JSONB NOT NULL,
  type TEXT NOT NULL DEFAULT 'info' CHECK (type IN ('info', 'warning', 'success', 'error')),
  start_date TIMESTAMPTZ NOT NULL,
  end_date TIMESTAMPTZ NOT NULL,
  is_enabled BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
COMMENT ON TABLE public.global_announcements IS 'Stores system-wide announcements for all users.';
RAISE NOTICE 'SUCCESS: Table "global_announcements" created or already exists.';


-- Step 2: Set up Row Level Security (RLS) on the new table.
ALTER TABLE public.global_announcements ENABLE ROW LEVEL SECURITY;

-- Policy 1: Allow anyone to read announcements that are currently active.
DROP POLICY IF EXISTS "Allow public read access for active announcements" ON public.global_announcements;
CREATE POLICY "Allow public read access for active announcements" ON public.global_announcements
FOR SELECT USING (
  is_enabled = true AND
  now() >= start_date AND
  now() <= end_date
);

-- Policy 2: Allow users with the 'manage:announcements' permission to do anything.
DROP POLICY IF EXISTS "Allow managers full access" ON public.global_announcements;
CREATE POLICY "Allow managers full access" ON public.global_announcements
FOR ALL USING (public.has_permission('manage:announcements'));
RAISE NOTICE 'SUCCESS: RLS policies for "global_announcements" created or updated.';


-- Step 3: Add the new permission to the permissions table.
INSERT INTO public.permissions (action, description)
VALUES ('manage:announcements', 'Can create, edit, and delete global announcements.')
ON CONFLICT (action) DO NOTHING;


-- Step 4: Assign the new permission to the Admin role.
DO $$
DECLARE
    admin_role_id UUID;
    manage_announcements_perm_id UUID;
BEGIN
    RAISE NOTICE 'SUCCESS: Permission "manage:announcements" added or already exists.';
    -- Get IDs
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    SELECT id INTO manage_announcements_perm_id FROM public.permissions WHERE action = 'manage:announcements';

    -- Assign the permission to Admin if both exist
    IF admin_role_id IS NOT NULL AND manage_announcements_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, manage_announcements_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
        
        IF FOUND THEN
             RAISE NOTICE 'SUCCESS: Assigned "manage:announcements" permission to Admin role.';
        ELSE
             RAISE NOTICE 'INFO: Admin role already has "manage:announcements" permission.';
        END IF;
    ELSE
        RAISE WARNING 'Could not assign "manage:announcements" permission. Admin role or permission not found.';
    END IF;
END $$;


COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Announcements System Translations
-- #
-- # Purpose: This is a safe, data-only script. It adds all the translation
-- # keys needed for the new global announcements feature, including page titles,
-- # form labels, button text, and notification messages.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'announcements', 'Announcements'),
('ar', 'announcements', 'الإعلانات'),
('en', 'announcement_management', 'Announcement Management'),
('ar', 'announcement_management', 'إدارة الإعلانات'),
('en', 'all_announcements', 'All Announcements'),
('ar', 'all_announcements', 'كل الإعلانات'),
('en', 'add_announcement', 'Add Announcement'),
('ar', 'add_announcement', 'إضافة إعلان'),
('en', 'edit_announcement', 'Edit Announcement'),
('ar', 'edit_announcement', 'تعديل الإعلان'),
('en', 'title', 'Title'),
('ar', 'title', 'العنوان'),
('en', 'message', 'Message'),
('ar', 'message', 'الرسالة'),
('en', 'announcement_type', 'Type'),
('ar', 'announcement_type', 'النوع'),
('en', 'start_date', 'Start Date'),
('ar', 'start_date', 'تاريخ البدء'),
('en', 'end_date', 'End Date'),
('ar', 'end_date', 'تاريخ الانتهاء'),
('en', 'is_enabled', 'Enabled'),
('ar', 'is_enabled', 'مُفعّل'),
('en', 'announcement_status', 'Status'),
('ar', 'announcement_status', 'الحالة'),
('en', 'active', 'Active'),
('ar', 'active', 'نشط'),
('en', 'inactive', 'Inactive'),
('ar', 'inactive', 'غير نشط'),
('en', 'scheduled', 'Scheduled'),
('ar', 'scheduled', 'مجدول'),
('en', 'expired', 'Expired'),
('ar', 'expired', 'منتهي الصلاحية'),
('en', 'title_en', 'Title (English)'),
('ar', 'title_en', 'العنوان (انجليزي)'),
('en', 'title_ar', 'Title (Arabic)'),
('ar', 'title_ar', 'العنوان (عربي)'),
('en', 'message_en', 'Message (English)'),
('ar', 'message_en', 'الرسالة (انجليزي)'),
('en', 'message_ar', 'Message (Arabic)'),
('ar', 'message_ar', 'الرسالة (عربي)'),
('en', 'announcement_saved_successfully', 'Announcement saved successfully!'),
('ar', 'announcement_saved_successfully', 'تم حفظ الإعلان بنجاح!'),
('en', 'announcement_deleted_successfully', 'Announcement deleted successfully.'),
('ar', 'announcement_deleted_successfully', 'تم حذف الإعلان بنجاح.'),
('en', 'announcement_delete_failed', 'Failed to delete announcement.'),
('ar', 'announcement_delete_failed', 'فشل حذف الإعلان.'),
('en', 'confirm_delete_announcement', 'Are you sure you want to delete this announcement?'),
('ar', 'confirm_delete_announcement', 'هل أنت متأكد من رغبتك في حذف هذا الإعلان؟'),
('en', 'delete', 'Delete'),
('ar', 'delete', 'حذف'),
('en', 'type_info', 'Info'),
('ar', 'type_info', 'معلومات'),
('en', 'type_warning', 'Warning'),
('ar', 'type_warning', 'تحذير'),
('en', 'type_success', 'Success'),
('ar', 'type_success', 'نجاح'),
('en', 'type_error', 'Error'),
('ar', 'type_error', 'خطأ')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add User Language Preference
-- #
-- # Purpose: This script adds the ability for each user to have a saved
-- # language preference, which will be automatically applied when they log in.
-- #
-- # It performs one key action:
-- # 1. It adds a `preferred_language` column to the `public.profiles` table.
-- #    This column will store the user's chosen language ('en' or 'ar').
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Add the `preferred_language` column to the `profiles` table.
-- It defaults to 'en' for all existing and new users.
-- This is safe to run multiple times as it checks for the column's existence first.
DO $$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM information_schema.columns WHERE table_schema = 'public' AND table_name='profiles' AND column_name='preferred_language') THEN
       ALTER TABLE public.profiles ADD COLUMN preferred_language TEXT NOT NULL DEFAULT 'en';
       RAISE NOTICE 'SUCCESS: Column "preferred_language" added to "profiles" table.';
    ELSE
       RAISE NOTICE 'INFO: Column "preferred_language" already exists in "profiles" table. No action taken.';
    END IF;
END $$;

COMMENT ON COLUMN public.profiles.preferred_language IS 'Stores the user''s preferred interface language (e.g., ''en'', ''ar'').';

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Permission Translations
-- #
-- # Purpose: This script adds the necessary translations to display permission
-- # names and descriptions in multiple languages on the Role Management page.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic for all permissions.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- manage:users
('en', 'perm_manage_users', 'Manage Users'),
('ar', 'perm_manage_users', 'إدارة المستخدمين'),
('en', 'perm_manage_users_desc', 'Can view the user list and change user roles.'),
('ar', 'perm_manage_users_desc', 'يمكنه عرض قائمة المستخدمين وتغيير صلاحياتهم.'),

-- manage:roles
('en', 'perm_manage_roles', 'Manage Roles & Permissions'),
('ar', 'perm_manage_roles', 'إدارة الصلاحيات والأذونات'),
('en', 'perm_manage_roles_desc', 'Can view the role list and change role permissions.'),
('ar', 'perm_manage_roles_desc', 'يمكنه عرض قائمة الصلاحيات وتغيير أذوناتها.'),

-- view:dashboard
('en', 'perm_view_dashboard', 'View Dashboard'),
('ar', 'perm_view_dashboard', 'عرض لوحة التحكم'),
('en', 'perm_view_dashboard_desc', 'Can view the main dashboard and statistics.'),
('ar', 'perm_view_dashboard_desc', 'يمكنه عرض لوحة التحكم الرئيسية والإحصائيات.'),

-- manage:settings
('en', 'perm_manage_settings', 'Manage Site Settings'),
('ar', 'perm_manage_settings', 'إدارة إعدادات الموقع'),
('en', 'perm_manage_settings_desc', 'Can update site-wide application settings.'),
('ar', 'perm_manage_settings_desc', 'يمكنه تحديث إعدادات التطبيق على مستوى الموقع.'),

-- manage:announcements
('en', 'perm_manage_announcements', 'Manage Announcements'),
('ar', 'perm_manage_announcements', 'إدارة الإعلانات'),
('en', 'perm_manage_announcements_desc', 'Can create, edit, and delete global announcements.'),
('ar', 'perm_manage_announcements_desc', 'يمكنه إنشاء وتعديل وحذف الإعلانات العامة.')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Sign-Up Flow Translations
-- #
-- # Purpose: This script adds the missing translation keys for the public
-- # sign-up modal and related notifications. This ensures that users who
-- # set up the dashboard via migrations (instead of a fresh install)
-- # will have a fully translated interface.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to insert system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Seed the new translations for English and Arabic.
-- The ON CONFLICT clause ensures that if a key already exists, it will be
-- updated instead of causing an error, making the script safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'create_account', 'Create Account'),
('ar', 'create_account', 'إنشاء حساب'),
('en', 'sign_up', 'Sign Up'),
('ar', 'sign_up', 'تسجيل'),
('en', 'signup_success', 'Account created! Please check your email to confirm.'),
('ar', 'signup_success', 'تم إنشاء الحساب! يرجى التحقق من بريدك الإلكتروني للتأكيد.')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Landing Page Content & Ad System
-- #
-- # Purpose: This script introduces a complete system for managing content
-- # on the public landing page, including a new advertisement system.
-- #
-- # It performs four key actions:
-- # 1. Creates a new `advertisements` table to store commercial ads.
-- # 2. Sets up Row Level Security (RLS) for public read and restricted write access.
-- # 3. Creates a new permission `manage:advertisements`.
-- # 4. Assigns the new permission to the 'Admin' role by default.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the advertisements table.
CREATE TABLE IF NOT EXISTS public.advertisements (
  id BIGSERIAL PRIMARY KEY,
  title JSONB NOT NULL,
  image_url TEXT,
  target_url TEXT,
  placement TEXT NOT NULL DEFAULT 'landing_sidebar' CHECK (placement IN ('landing_sidebar', 'landing_main')),
  start_date TIMESTAMPTZ NOT NULL,
  end_date TIMESTAMPTZ NOT NULL,
  is_enabled BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
COMMENT ON TABLE public.advertisements IS 'Stores commercial advertisements for display on public pages.';
RAISE NOTICE 'SUCCESS: Table "advertisements" created or already exists.';


-- Step 2: Set up Row Level Security (RLS) on the new table.
ALTER TABLE public.advertisements ENABLE ROW LEVEL SECURITY;

-- Policy 1: Allow anyone to read ads that are currently active and enabled.
DROP POLICY IF EXISTS "Allow public read access for active ads" ON public.advertisements;
CREATE POLICY "Allow public read access for active ads" ON public.advertisements
FOR SELECT USING (
  is_enabled = true AND
  now() >= start_date AND
  now() <= end_date
);

-- Policy 2: Allow users with the 'manage:advertisements' permission to do anything.
DROP POLICY IF EXISTS "Allow managers full access" ON public.advertisements;
CREATE POLICY "Allow managers full access" ON public.advertisements
FOR ALL USING (public.has_permission('manage:advertisements'));
RAISE NOTICE 'SUCCESS: RLS policies for "advertisements" created or updated.';


-- Step 3: Add the new permission to the permissions table.
INSERT INTO public.permissions (action, description)
VALUES ('manage:advertisements', 'Can create, edit, and delete commercial advertisements.')
ON CONFLICT (action) DO UPDATE SET description = EXCLUDED.description;


-- Step 4: Assign the new permission to the Admin role.
DO $$
DECLARE
    admin_role_id UUID;
    manage_ads_perm_id UUID;
BEGIN
    RAISE NOTICE 'SUCCESS: Permission "manage:advertisements" added or already exists.';
    -- Get IDs
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    SELECT id INTO manage_ads_perm_id FROM public.permissions WHERE action = 'manage:advertisements';

    -- Assign the permission to Admin if both exist
    IF admin_role_id IS NOT NULL AND manage_ads_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, manage_ads_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
        
        IF FOUND THEN
             RAISE NOTICE 'SUCCESS: Assigned "manage:advertisements" permission to Admin role.';
        ELSE
             RAISE NOTICE 'INFO: Admin role already has "manage:advertisements" permission.';
        END IF;
    ELSE
        RAISE WARNING 'Could not assign "manage:advertisements" permission. Admin role or permission not found.';
    END IF;
END $$;


COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Landing Page & Ad Management Translations
-- #
-- # Purpose: This is a safe, data-only script. It adds all the translation
-- # keys needed for the new landing page content and ad management features.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Settings on Dashboard
('en', 'general_settings', 'General Settings'),
('ar', 'general_settings', 'الإعدادات العامة'),
('en', 'landing_page_content', 'Landing Page Content'),
('ar', 'landing_page_content', 'محتوى الصفحة الرئيسية'),
('en', 'article_title_en', 'Article Title (English)'),
('ar', 'article_title_en', 'عنوان المقال (انجليزي)'),
('en', 'article_title_ar', 'Article Title (Arabic)'),
('ar', 'article_title_ar', 'عنوان المقال (عربي)'),
('en', 'article_body_en', 'Article Body (English)'),
('ar', 'article_body_en', 'نص المقال (انجليزي)'),
('en', 'article_body_ar', 'Article Body (Arabic)'),
('ar', 'article_body_ar', 'نص المقال (عربي)'),

-- Ad Management Page
('en', 'ad_management', 'Ad Management'),
('ar', 'ad_management', 'إدارة الإعلانات'),
('en', 'add_advertisement', 'Add Advertisement'),
('ar', 'add_advertisement', 'إضافة إعلان'),
('en', 'edit_advertisement', 'Edit Advertisement'),
('ar', 'edit_advertisement', 'تعديل الإعلان'),
('en', 'image_url', 'Image URL'),
('ar', 'image_url', 'رابط الصورة'),
('en', 'target_url', 'Target URL (Link)'),
('ar', 'target_url', 'الرابط الهدف'),
('en', 'placement', 'Placement'),
('ar', 'placement', 'الموضع'),
('en', 'ad_status', 'Status'),
('ar', 'ad_status', 'الحالة'),
('en', 'ad_saved_successfully', 'Advertisement saved successfully!'),
('ar', 'ad_saved_successfully', 'تم حفظ الإعلان بنجاح!'),
('en', 'ad_deleted_successfully', 'Advertisement deleted successfully.'),
('ar', 'ad_deleted_successfully', 'تم حذف الإعلان بنجاح.'),
('en', 'ad_delete_failed', 'Failed to delete advertisement.'),
('ar', 'ad_delete_failed', 'فشل حذف الإعلان.'),
('en', 'confirm_delete_ad', 'Are you sure you want to delete this advertisement?'),
('ar', 'confirm_delete_ad', 'هل أنت متأكد من رغبتك في حذف هذا الإعلان؟'),
('en', 'perm_manage_advertisements', 'Manage Advertisements'),
('ar', 'perm_manage_advertisements', 'إدارة الإعلانات'),
('en', 'perm_manage_advertisements_desc', 'Can create, edit, and delete commercial advertisements.'),
('ar', 'perm_manage_advertisements_desc', 'يمكنه إنشاء وتعديل وحذف الإعلانات التجارية.')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Advertisement Placement Note Translation
-- #
-- # Purpose: This script adds the translation key needed to display a helpful
-- # note in the ad creation/edit modal, telling the admin exactly where
-- # the ad will be placed. This improves user experience and prevents confusion.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'ad_placement_note', 'Note: This advertisement will appear in the sidebar of the public landing page.'),
('ar', 'ad_placement_note', 'ملاحظة: سيظهر هذا الإعلان في الشريط الجانبي للصفحة الرئيسية العامة.')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Core Permission Checking Function
-- #
-- # Purpose: This script fixes a critical bug in the `has_permission` database
-- # function that was causing pages to get stuck in a loading state. The
-- # function was missing the 'auth' schema in its search path, preventing it
-- # from correctly identifying the logged-in user.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.has_permission(permission_action text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
-- FIX: Added 'auth' to the search_path so the function can find `auth.uid()`.
SET search_path = public, auth
AS $$
BEGIN
  -- This query now works correctly because auth.uid() can be resolved.
  RETURN EXISTS (
    SELECT 1
    FROM public.profiles p
    JOIN public.role_permissions rp ON p.role_id = rp.role_id
    JOIN public.permissions perm ON rp.permission_id = perm.id
    WHERE p.id = uid() AND perm.action = permission_action
  );
END;
$$;

RAISE NOTICE 'SUCCESS: The `has_permission` function has been corrected.';

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fortify Advertisements Table
-- #
-- # Purpose: This script improves the structure of the `advertisements` table
-- # to support the new ad card design and ensure data integrity.
-- #
-- # It performs three key actions:
-- # 1. Adds a new `advertiser_name` column to store the brand name.
-- # 2. Enforces a `NOT NULL` constraint on `image_url`.
-- # 3. Enforces a `NOT NULL` constraint on `target_url`.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Add the new advertiser_name column with a default value.
-- This prevents errors on existing rows and ensures the column is always populated.
DO $$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM information_schema.columns WHERE table_schema = 'public' AND table_name='advertisements' AND column_name='advertiser_name') THEN
       ALTER TABLE public.advertisements ADD COLUMN advertiser_name JSONB NOT NULL DEFAULT '{"en": "Advertiser", "ar": "المعلن"}'::jsonb;
       RAISE NOTICE 'SUCCESS: Column "advertiser_name" added to "advertisements" table.';
    ELSE
       RAISE NOTICE 'INFO: Column "advertiser_name" already exists. No action taken.';
    END IF;
END $$;

-- Step 2: Enforce NOT NULL constraints on essential columns.
-- This ensures that all future advertisements will have an image and a link.
ALTER TABLE public.advertisements ALTER COLUMN image_url SET NOT NULL;
ALTER TABLE public.advertisements ALTER COLUMN target_url SET NOT NULL;

RAISE NOTICE 'SUCCESS: Enforced NOT NULL constraints on advertisements table.';

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Advertiser Name Translations
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # "Advertiser Name" field in the advertisement management modal.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'advertiser_name_en', 'Advertiser Name (English)'),
('ar', 'advertiser_name_en', 'اسم المعلن (انجليزي)'),
('en', 'advertiser_name_ar', 'Advertiser Name (Arabic)'),
('ar', 'advertiser_name_ar', 'اسم المعلن (عربي)')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Strengthen Advertisement Security Policies
-- #
-- # Purpose: This script provides a definitive fix for the issue where
-- # advertisements were not saving. The previous general-purpose security
-- # rule was failing silently on INSERT/UPDATE operations.
-- #
-- # This script replaces the single, ambiguous `FOR ALL` policy with four
-- # explicit, robust policies for SELECT, INSERT, UPDATE, and DELETE actions.
-- # This removes any ambiguity and ensures the database correctly enforces
-- # permissions for users with the 'manage:advertisements' role.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- First, remove the old, general-purpose policy that was causing silent failures.
DROP POLICY IF EXISTS "Allow managers full access" ON public.advertisements;
RAISE NOTICE 'INFO: Dropped old general-purpose security policy on advertisements table.';

-- Now, create four new, explicit policies that are not ambiguous.

-- 1. SELECT Policy: Allows users with the permission to read all advertisements.
DROP POLICY IF EXISTS "Allow managers to view advertisements" ON public.advertisements;
CREATE POLICY "Allow managers to view advertisements"
    ON public.advertisements FOR SELECT
    USING (public.has_permission('manage:advertisements'));

-- 2. INSERT Policy: Allows users with the permission to create new advertisements.
DROP POLICY IF EXISTS "Allow managers to create advertisements" ON public.advertisements;
CREATE POLICY "Allow managers to create advertisements"
    ON public.advertisements FOR INSERT
    WITH CHECK (public.has_permission('manage:advertisements'));

-- 3. UPDATE Policy: Allows users with the permission to update existing advertisements.
DROP POLICY IF EXISTS "Allow managers to update advertisements" ON public.advertisements;
CREATE POLICY "Allow managers to update advertisements"
    ON public.advertisements FOR UPDATE
    USING (public.has_permission('manage:advertisements'))
    WITH CHECK (public.has_permission('manage:advertisements'));

-- 4. DELETE Policy: Allows users with the permission to delete advertisements.
DROP POLICY IF EXISTS "Allow managers to delete advertisements" ON public.advertisements;
CREATE POLICY "Allow managers to delete advertisements"
    ON public.advertisements FOR DELETE
    USING (public.has_permission('manage:advertisements'));

RAISE NOTICE 'SUCCESS: Replaced old policy with four explicit, robust RLS policies for the advertisements table.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add URL Validation to Advertisements Table
-- #
-- # Purpose: This script adds a robust layer of data integrity to the
-- # `advertisements` table by adding database-level validation for the URL fields.
-- # While the frontend now cleans and validates URLs, this ensures that no
-- # malformed data can enter the database through other means (e.g., direct API calls).
-- #
-- # It adds a CHECK constraint using a regular expression to both `image_url`
-- # and `target_url` to ensure they start with http:// or https://.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- First, drop the old constraints if they exist, to ensure a clean update.
ALTER TABLE public.advertisements DROP CONSTRAINT IF EXISTS advertisements_image_url_check;
ALTER TABLE public.advertisements DROP CONSTRAINT IF EXISTS advertisements_target_url_check;

-- Now, add the new, more robust CHECK constraints.
-- This regex checks if the string starts with http:// or https:// in a case-insensitive way.
ALTER TABLE public.advertisements
ADD CONSTRAINT advertisements_image_url_check CHECK (image_url ~* '^https?://.+');

ALTER TABLE public.advertisements
ADD CONSTRAINT advertisements_target_url_check CHECK (target_url ~* '^https?://.+');

RAISE NOTICE 'SUCCESS: Added robust URL format validation to the advertisements table.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Completely Remove Advertisement Feature
-- #
-- # Purpose: This script removes all database objects related to the
-- # advertisement feature, including the table, permissions, and translations.
-- # This is part of a complete removal of the feature from the application.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Drop the advertisements table.
-- Using CASCADE will automatically remove any dependent objects like constraints.
DROP TABLE IF EXISTS public.advertisements CASCADE;
RAISE NOTICE 'SUCCESS: Table "advertisements" has been dropped.';

-- Step 2: Remove the 'manage:advertisements' permission from any roles that have it.
DO $$
DECLARE
    perm_id UUID;
BEGIN
    SELECT id INTO perm_id FROM public.permissions WHERE action = 'manage:advertisements';
    IF perm_id IS NOT NULL THEN
        DELETE FROM public.role_permissions WHERE permission_id = perm_id;
        RAISE NOTICE 'SUCCESS: Removed "manage:advertisements" from all roles.';
    ELSE
        RAISE NOTICE 'INFO: "manage:advertisements" permission not found in role_permissions. No action taken.';
    END IF;
END $$;

-- Step 3: Delete the 'manage:advertisements' permission itself.
DELETE FROM public.permissions WHERE action = 'manage:advertisements';
RAISE NOTICE 'SUCCESS: Deleted "manage:advertisements" from the permissions table.';

-- Step 4: Delete all advertisement-related translations.
DELETE FROM public.translations WHERE key LIKE 'ad_%';
DELETE FROM public.translations WHERE key LIKE 'perm_manage_advertisements%';
RAISE NOTICE 'SUCCESS: Deleted all advertisement-related translations.';


COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add System Documentation Feature
-- #
-- # Purpose: This script introduces a feature to auto-generate documentation
-- # for the database schema, accessible from within the app.
-- #
-- # It performs three key actions:
-- # 1. Creates a new permission `view:system_documentation`.
-- # 2. Assigns this new permission to the 'Admin' role.
-- # 3. Creates a secure PostgreSQL RPC function `get_database_documentation`
-- #    that queries the database's information schema and returns a structured
-- #    JSON object containing details about tables, functions, and policies.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Add the new permission to the permissions table.
INSERT INTO public.permissions (action, description)
VALUES ('view:system_documentation', 'Can view the auto-generated database and system documentation.')
ON CONFLICT (action) DO UPDATE SET description = EXCLUDED.description;


-- Step 2: Assign the new permission to the Admin role.
DO $$
DECLARE
    admin_role_id UUID;
    view_docs_perm_id UUID;
BEGIN
    RAISE NOTICE 'SUCCESS: Permission "view:system_documentation" added or already exists.';
    -- Get IDs
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    SELECT id INTO view_docs_perm_id FROM public.permissions WHERE action = 'view:system_documentation';

    -- Assign the permission to Admin if both exist
    IF admin_role_id IS NOT NULL AND view_docs_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, view_docs_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;

        IF FOUND THEN
             RAISE NOTICE 'SUCCESS: Assigned "view:system_documentation" permission to Admin role.';
        ELSE
             RAISE NOTICE 'INFO: Admin role already has "view:system_documentation" permission.';
        END IF;
    ELSE
        RAISE WARNING 'Could not assign "view:system_documentation" permission. Admin role or permission not found.';
    END IF;
END $$;


-- Step 3: Create the RPC function to fetch all schema information.
CREATE OR REPLACE FUNCTION public.get_database_documentation()
RETURNS json
LANGUAGE sql
SECURITY DEFINER
SET search_path = public, auth, pg_catalog, information_schema
AS $$
SELECT json_build_object(
    'tables', (
        SELECT COALESCE(json_agg(
            json_build_object(
                'name', t.table_name,
                'description', pg_catalog.obj_description(c.oid, 'pg_class'),
                'columns', (
                    SELECT COALESCE(json_agg(
                        json_build_object(
                            'name', col.column_name,
                            'type', col.udt_name,
                            'nullable', col.is_nullable,
                            'default', col.column_default,
                            'description', pg_catalog.col_description(c.oid, col.ordinal_position::int)
                        ) ORDER BY col.ordinal_position
                    ), '[]'::json)
                    FROM information_schema.columns col
                    WHERE col.table_schema = 'public' AND col.table_name = t.table_name
                )
            ) ORDER BY t.table_name
        ), '[]'::json)
        FROM information_schema.tables t
        JOIN pg_catalog.pg_class c ON c.relname = t.table_name
        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace AND n.nspname = 'public'
        WHERE t.table_schema = 'public' AND t.table_type = 'BASE TABLE'
    ),
    'functions', (
        SELECT COALESCE(json_agg(
            json_build_object(
                'name', p.proname,
                'definition', pg_catalog.pg_get_functiondef(p.oid)
            ) ORDER BY p.proname
        ), '[]'::json)
        FROM pg_catalog.pg_proc p
        JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
        WHERE n.nspname = 'public'
    ),
    'policies', (
        SELECT COALESCE(json_agg(
            json_build_object(
                'table', p.tablename,
                'name', p.policyname,
                'command', p.cmd,
                'definition', p.qual,
                'with_check', p.with_check
            ) ORDER BY p.tablename, p.policyname
        ), '[]'::json)
        FROM pg_catalog.pg_policies p
        WHERE p.schemaname = 'public'
    )
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_database_documentation" created or updated.';


COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add System Documentation UI Translations
-- #
-- # Purpose: This is a safe, data-only script. It adds all the translation
-- # keys needed for the new system documentation feature.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'system_documentation', 'System Documentation'),
('ar', 'system_documentation', 'توثيق النظام'),
('en', 'perm_view_system_documentation', 'View System Documentation'),
('ar', 'perm_view_system_documentation', 'عرض توثيق النظام'),
('en', 'perm_view_system_documentation_desc', 'Can view the auto-generated database and system documentation.'),
('ar', 'perm_view_system_documentation_desc', 'يمكنه عرض التوثيق التلقائي لقاعدة البيانات والنظام.'),
('en', 'refresh', 'Refresh'),
('ar', 'refresh', 'تحديث'),
('en', 'download_as_txt', 'Download as .txt'),
('ar', 'download_as_txt', 'تنزيل كملف نصي'),
('en', 'tables_and_views', 'Tables & Views'),
('ar', 'tables_and_views', 'الجداول والعروض'),
('en', 'columns', 'Columns'),
('ar', 'columns', 'الأعمدة'),
('en', 'column_name', 'Column Name'),
('ar', 'column_name', 'اسم العمود'),
('en', 'data_type', 'Data Type'),
('ar', 'data_type', 'نوع البيانات'),
('en', 'is_nullable', 'Nullable'),
('ar', 'is_nullable', 'يقبل NULL'),
('en', 'default_value', 'Default Value'),
('ar', 'default_value', 'القيمة الافتراضية'),
('en', 'description', 'Description'),
('ar', 'description', 'الوصف'),
('en', 'user_defined_functions', 'User-Defined Functions'),
('ar', 'user_defined_functions', 'الدوال المعرفة من المستخدم'),
('en', 'function_definition', 'Function Definition'),
('ar', 'function_definition', 'تعريف الدالة'),
('en', 'rls_policies', 'Row Level Security Policies'),
('ar', 'rls_policies', 'سياسات أمان مستوى الصف'),
('en', 'policy_name', 'Policy Name'),
('ar', 'policy_name', 'اسم السياسة'),
('en', 'applies_to', 'Applies To'),
('ar', 'applies_to', 'تنطبق على'),
('en', 'policy_definition', 'Definition (USING)'),
('ar', 'policy_definition', 'التعريف (USING)'),
('en', 'check_expression', 'CHECK Expression'),
('ar', 'check_expression', 'تعبير التحقق (WITH CHECK)'),
('en', 'no_description_available', 'No description available.'),
('ar', 'no_description_available', 'لا يوجد وصف متاح.'),
('en', 'no_policies_found', 'No policies found for this table.'),
('ar', 'no_policies_found', 'لم يتم العثور على سياسات لهذا الجدول.'),
('en', 'documentation_intro', 'This page provides live documentation of the database schema. All information is queried directly from the database catalog.'),
('ar', 'documentation_intro', 'توفر هذه الصفحة توثيقًا مباشرًا لمخطط قاعدة البيانات. يتم الاستعلام عن جميع المعلومات مباشرة من كتالوج قاعدة البيانات.')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Landing Page Article Content
-- #
-- # Purpose: This script updates the content of the article displayed on the
-- # public landing page as per the user's request.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.app_settings DISABLE ROW LEVEL SECURITY;

-- Upsert the values for the landing page article in both English and Arabic.
-- The ON CONFLICT clause ensures that if the keys already exist, they will be
-- updated instead of causing an error.
INSERT INTO public.app_settings (key, value) VALUES
('landing_article_title_en', 'In this website:'),
('landing_article_body_en', 'Professional and visually engaging stock price predictions for the U.S. markets, enabling users to explore daily and historical stock performance through multiple subscription plans.'),
('landing_article_title_ar', 'في هذا الموقع'),
('landing_article_body_ar', E'توقعات أسعار الأسهم في الأسواق الأمريكية بطريقة احترافية وبصرية جذابة\nتمكين المستخدمين من استعراض الأداء اليومي والتاريخي للأسهم وفق خطط اشتراك متعددة')
ON CONFLICT (key)
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Landing page content has been updated.';

-- Re-enable RLS
ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Refactor Landing Page Content Storage
-- #
-- # Purpose: This script refactors the way landing page content is stored in
-- # the `app_settings` table. It consolidates four separate language-specific
-- # keys into two keys that use JSON objects, making the system more robust
-- # and easier to manage. It safely migrates any existing content.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.app_settings DISABLE ROW LEVEL SECURITY;

-- Step 1: Create the new JSON-based settings by aggregating the old ones.
-- We use a CTE to fetch old values safely, handling cases where they might be NULL.
WITH old_values AS (
    SELECT
        (SELECT value FROM app_settings WHERE key = 'landing_article_title_en') as title_en,
        (SELECT value FROM app_settings WHERE key = 'landing_article_title_ar') as title_ar,
        (SELECT value FROM app_settings WHERE key = 'landing_article_body_en') as body_en,
        (SELECT value FROM app_settings WHERE key = 'landing_article_body_ar') as body_ar
)
INSERT INTO public.app_settings (key, value)
SELECT 'landing_article_title', json_build_object('en', COALESCE(title_en, ''), 'ar', COALESCE(title_ar, ''))::text FROM old_values
UNION ALL
SELECT 'landing_article_body', json_build_object('en', COALESCE(body_en, ''), 'ar', COALESCE(body_ar, ''))::text FROM old_values
ON CONFLICT (key)
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Consolidated landing page content into JSON format.';

-- Step 2: Delete the old, language-specific keys.
DELETE FROM public.app_settings
WHERE key IN (
    'landing_article_title_en',
    'landing_article_title_ar',
    'landing_article_body_en',
    'landing_article_body_ar'
);

RAISE NOTICE 'SUCCESS: Removed old language-specific landing page content keys.';

-- Re-enable RLS
ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Create Data Fetching Functions
-- #
-- # Purpose: This script refactors data access by creating a set of PostgreSQL
-- # functions. The application will call these functions via RPC instead of
-- # querying tables directly. This improves abstraction, security, and can
-- # centralize complex query logic for better performance and maintenance.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Function to get active announcements for the public banner
CREATE OR REPLACE FUNCTION public.get_active_announcements()
RETURNS SETOF public.global_announcements
LANGUAGE sql
STABLE
AS $$
  SELECT *
  FROM public.global_announcements
  WHERE is_enabled = true
    AND now() >= start_date
    AND now() <= end_date
  ORDER BY created_at DESC;
$$;
RAISE NOTICE 'Function "get_active_announcements" created or updated.';

-- Function to get all app settings
CREATE OR REPLACE FUNCTION public.get_all_app_settings()
RETURNS SETOF public.app_settings
LANGUAGE sql
STABLE
AS $$
  SELECT * FROM public.app_settings;
$$;
RAISE NOTICE 'Function "get_all_app_settings" created or updated.';

-- Function to get translations for a specific language
CREATE OR REPLACE FUNCTION public.get_translations(p_lang_code TEXT)
RETURNS SETOF public.translations
LANGUAGE sql
STABLE
AS $$
  SELECT id, lang_id, key, value
  FROM public.translations
  WHERE lang_id = p_lang_code;
$$;
RAISE NOTICE 'Function "get_translations" created or updated.';

-- Function to get a single user's profile with nested permissions
-- Returns a single JSON object to match the client-side type structure
CREATE OR REPLACE FUNCTION public.get_user_profile_and_permissions(p_user_id UUID)
RETURNS json
LANGUAGE sql
STABLE
AS $$
SELECT
    json_build_object(
        'id', p.id,
        'full_name', p.full_name,
        'email', p.email,
        'role_id', p.role_id,
        'email_confirmed_at', p.email_confirmed_at,
        'preferred_language', p.preferred_language,
        'roles', (
            SELECT
                json_build_object(
                    'name', r.name,
                    'permissions', (
                        SELECT COALESCE(json_agg(json_build_object('action', perm.action)), '[]'::json)
                        FROM public.role_permissions rp
                        JOIN public.permissions perm ON rp.permission_id = perm.id
                        WHERE rp.role_id = p.role_id
                    )
                )
            FROM public.roles r
            WHERE r.id = p.role_id
        )
    )
FROM
    public.profiles p
WHERE
    p.id = p_user_id
LIMIT 1;
$$;
RAISE NOTICE 'Function "get_user_profile_and_permissions" created or updated.';

-- Function to get dashboard statistics
CREATE OR REPLACE FUNCTION public.get_dashboard_stats()
RETURNS TABLE(user_count BIGINT, role_count BIGINT)
LANGUAGE sql
STABLE
AS $$
  SELECT
    (SELECT count(*) FROM public.profiles) AS user_count,
    (SELECT count(*) FROM public.roles) AS role_count;
$$;
RAISE NOTICE 'Function "get_dashboard_stats" created or updated.';

-- Function to get all users with their role name for the User Management page.
-- This function uses SECURITY DEFINER to bypass a circular dependency issue in RLS
-- where the policy on `profiles` needs to call a function that reads from `profiles`.
-- It is secure because it first checks if the calling user has the required permission.
CREATE OR REPLACE FUNCTION public.get_all_users_with_roles()
RETURNS TABLE (
    id uuid,
    full_name text,
    email text,
    role_id uuid,
    email_confirmed_at timestamptz,
    roles json
)
-- Must be plpgsql to use IF statements
LANGUAGE plpgsql
-- Use SECURITY DEFINER to bypass RLS, but check permissions inside
SECURITY DEFINER
-- Set search_path to ensure functions like has_permission can be found
SET search_path = public, auth
AS $$
BEGIN
  -- First, check if the *actual* calling user has the 'manage:users' permission.
  -- This is the security gate.
  IF public.has_permission('manage:users') THEN
    -- If they do, run the query without RLS (due to SECURITY DEFINER) and return all users.
    RETURN QUERY
      SELECT
          p.id,
          p.full_name,
          p.email,
          p.role_id,
          p.email_confirmed_at,
          json_build_object('name', r.name) as roles
      FROM
          public.profiles p
      LEFT JOIN
          public.roles r ON p.role_id = r.id;
  ELSE
    -- If the user does not have permission, they should not see any users.
    -- A simple RETURN exits the function, returning an empty table.
    RETURN;
  END IF;
END;
$$;
RAISE NOTICE 'Function "get_all_users_with_roles" has been updated to fix permission issues.';


-- Function to get all roles (used in User Management and Role Management)
CREATE OR REPLACE FUNCTION public.get_all_roles()
RETURNS SETOF public.roles
LANGUAGE sql
STABLE
AS $$
    SELECT id, name, description, created_at FROM public.roles;
$$;
RAISE NOTICE 'Function "get_all_roles" created or updated.';

-- Function to get all data needed for the Role Management page in a single call
CREATE OR REPLACE FUNCTION public.get_role_management_data()
RETURNS json
LANGUAGE sql
STABLE
AS $$
SELECT json_build_object(
    'roles', (SELECT COALESCE(json_agg(r), '[]'::json) FROM public.roles r),
    'permissions', (
        SELECT COALESCE(json_agg(p), '[]'::json)
        FROM public.permissions p
        WHERE p.action != 'manage:advertisements' -- Filter out obsolete permission
    ),
    'role_permissions', (SELECT COALESCE(json_agg(rp), '[]'::json) FROM public.role_permissions rp)
);
$$;
RAISE NOTICE 'Function "get_role_management_data" created or updated.';

-- Function to get all announcements for the management page
CREATE OR REPLACE FUNCTION public.get_all_announcements()
RETURNS SETOF public.global_announcements
LANGUAGE sql
STABLE
AS $$
  SELECT *
  FROM public.global_announcements
  ORDER BY start_date DESC;
$$;
RAISE NOTICE 'Function "get_all_announcements" created or updated.';


-- Function to get all users for Gemini analysis
CREATE OR REPLACE FUNCTION public.get_all_users_for_analysis()
RETURNS json
LANGUAGE sql
STABLE
AS $$
    SELECT COALESCE(json_agg(
        json_build_object(
            'full_name', p.full_name,
            'email', p.email,
            'roles', json_build_object('name', r.name)
        )
    ), '[]'::json)
    FROM public.profiles p
    LEFT JOIN public.roles r on p.role_id = r.id;
$$;
RAISE NOTICE 'Function "get_all_users_for_analysis" created or updated.';

-- Function to get specific translation values for a key across relevant languages
CREATE OR REPLACE FUNCTION public.get_translations_for_key(p_key TEXT)
RETURNS SETOF public.translations
LANGUAGE sql
STABLE
AS $$
  SELECT id, lang_id, key, value
  FROM public.translations
  WHERE key = p_key AND (lang_id = 'en' OR lang_id = 'ar');
$$;
RAISE NOTICE 'Function "get_translations_for_key" created or updated.';


COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Dashboard and Add Language Translations
-- #
-- # Purpose: This script updates the Arabic translation for 'site_settings'
-- # to match the user interface and adds new translation keys for language tabs.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- 1. Update the Arabic translation for 'site_settings'
INSERT INTO public.translations (lang_id, key, value) VALUES
('ar', 'site_settings', 'الإعدادات العامة')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- 2. Add new translations for language tabs
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'lang_english', 'English'),
('ar', 'lang_english', 'الإنجليزية'),
('en', 'lang_arabic', 'Arabic'),
('ar', 'lang_arabic', 'العربية')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Dashboard Field Translations
-- #
-- # Purpose: This script adds the missing Arabic translations for the field
-- # labels on the Dashboard's "Site Settings" section. This resolves an issue
-- # where translation keys were displayed instead of the translated text.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add translations for the dashboard's site settings fields.
-- The ON CONFLICT clause ensures this is safe to run multiple times and
-- will update existing keys if necessary.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'site_title_en', 'Site Title (English)'),
('ar', 'site_title_en', 'عنوان الموقع (انجليزي)'),
('en', 'site_title_ar', 'Site Title (Arabic)'),
('ar', 'site_title_ar', 'عنوان الموقع (عربي)'),
('en', 'site_logo', 'Site Logo (SVG Code)'),
('ar', 'site_logo', 'شعار الموقع (كود SVG)')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Added missing Arabic translations for dashboard settings fields.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Announcements Page Translations
-- #
-- # Purpose: This script ensures all necessary translations for the
-- # Announcements Management page are present in the database. It specifically
-- # fixes an issue where the "Add Announcement" button was not translated.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/update all translations for the announcements feature to ensure consistency.
-- The ON CONFLICT clause makes this script safe to re-run.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'announcements', 'Announcements'),
('ar', 'announcements', 'الإعلانات'),
('en', 'announcement_management', 'Announcement Management'),
('ar', 'announcement_management', 'إدارة الإعلانات'),
('en', 'all_announcements', 'All Announcements'),
('ar', 'all_announcements', 'كل الإعلانات'),
('en', 'add_announcement', 'Add Announcement'),
('ar', 'add_announcement', 'إضافة إعلان'),
('en', 'edit_announcement', 'Edit Announcement'),
('ar', 'edit_announcement', 'تعديل الإعلان'),
('en', 'title', 'Title'),
('ar', 'title', 'العنوان'),
('en', 'message', 'Message'),
('ar', 'message', 'الرسالة'),
('en', 'announcement_type', 'Type'),
('ar', 'announcement_type', 'النوع'),
('en', 'start_date', 'Start Date'),
('ar', 'start_date', 'تاريخ البدء'),
('en', 'end_date', 'End Date'),
('ar', 'end_date', 'تاريخ الانتهاء'),
('en', 'is_enabled', 'Enabled'),
('ar', 'is_enabled', 'مُفعّل'),
('en', 'announcement_status', 'Status'),
('ar', 'announcement_status', 'الحالة'),
('en', 'active', 'Active'),
('ar', 'active', 'نشط'),
('en', 'inactive', 'Inactive'),
('ar', 'inactive', 'غير نشط'),
('en', 'scheduled', 'Scheduled'),
('ar', 'scheduled', 'مجدول'),
('en', 'expired', 'Expired'),
('ar', 'expired', 'منتهي الصلاحية'),
('en', 'title_en', 'Title (English)'),
('ar', 'title_en', 'العنوان (انجليزي)'),
('en', 'title_ar', 'Title (Arabic)'),
('ar', 'title_ar', 'العنوان (عربي)'),
('en', 'message_en', 'Message (English)'),
('ar', 'message_en', 'الرسالة (انجليزي)'),
('en', 'message_ar', 'Message (Arabic)'),
('ar', 'message_ar', 'الرسالة (عربي)'),
('en', 'announcement_saved_successfully', 'Announcement saved successfully!'),
('ar', 'announcement_saved_successfully', 'تم حفظ الإعلان بنجاح!'),
('en', 'announcement_deleted_successfully', 'Announcement deleted successfully.'),
('ar', 'announcement_deleted_successfully', 'تم حذف الإعلان بنجاح.'),
('en', 'announcement_delete_failed', 'Failed to delete announcement.'),
('ar', 'announcement_delete_failed', 'فشل حذف الإعلان.'),
('en', 'confirm_delete_announcement', 'Are you sure you want to delete this announcement?'),
('ar', 'confirm_delete_announcement', 'هل أنت متأكد من رغبتك في حذف هذا الإعلان؟'),
('en', 'delete', 'Delete'),
('ar', 'delete', 'حذف'),
('en', 'type_info', 'Info'),
('ar', 'type_info', 'معلومات'),
('en', 'type_warning', 'Warning'),
('ar', 'type_warning', 'تحذير'),
('en', 'type_success', 'Success'),
('ar', 'type_success', 'نجاح'),
('en', 'type_error', 'Error'),
('ar', 'type_error', 'خطأ')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: All translations for the Announcements feature have been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Role Management Page Translations
-- #
-- # Purpose: This script adds the missing Arabic translations for the
-- # Role Management page, fixing untranslated UI elements like the
-- # "admin_role_note" and the page's dynamic title.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/update all translations for the role management page to ensure consistency.
-- The ON CONFLICT clause makes this script safe to re-run.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'admin_role_note', 'Admin permissions cannot be changed.'),
('ar', 'admin_role_note', 'لا يمكن تغيير أذونات صلاحية المدير.'),
('en', 'permissions_for_role', 'Permissions for {roleName}'),
('ar', 'permissions_for_role', 'الأذونات لصلاحية {roleName}')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: All translations for the Role Management page have been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Stocks Table and Tracking System
-- #
-- # Purpose: This script introduces the core table for storing stock data.
-- #
-- # It performs several key actions:
-- # 1. Enables the `pg_trgm` extension required for efficient text searching.
-- # 2. Creates the `stocks` table to store stock information.
-- # 3. Adds GIN indexes to the `symbol` and `name` columns for performance.
-- # 4. Sets up Row Level Security (RLS) for public read access and
-- #    restricted write access for managers.
-- # 5. Creates a new permission `manage:stocks` and assigns it to the 'Admin' role.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Enable the pg_trgm extension for text searching.
CREATE EXTENSION IF NOT EXISTS "pg_trgm" WITH SCHEMA "extensions";

-- Step 2: Create the stocks table.
-- The user-provided schema is used, wrapped in an IF NOT EXISTS block for safety.
CREATE TABLE IF NOT EXISTS public.stocks (
  symbol text NOT NULL,
  name text NOT NULL,
  price real NULL,
  change real NULL,
  change_percent real NULL,
  volume bigint NULL,
  market_cap bigint NULL,
  last_updated timestamp with time zone NULL,
  is_tracked boolean NULL DEFAULT true,
  CONSTRAINT stocks_pkey PRIMARY KEY (symbol)
);
COMMENT ON TABLE public.stocks IS 'Stores information about individual stocks.';


-- Step 3: Create indexes for efficient searching.
CREATE INDEX IF NOT EXISTS idx_stocks_symbol_trgm ON public.stocks USING gin (symbol extensions.gin_trgm_ops);
CREATE INDEX IF NOT EXISTS idx_stocks_name_trgm ON public.stocks USING gin (name extensions.gin_trgm_ops);


-- Step 4: Set up Row Level Security (RLS) on the new table.
ALTER TABLE public.stocks ENABLE ROW LEVEL SECURITY;

-- Policy 1: Allow anyone to read all stock data.
DROP POLICY IF EXISTS "Allow public read access on stocks" ON public.stocks;
CREATE POLICY "Allow public read access on stocks" ON public.stocks
FOR SELECT USING (true);

-- Policy 2: Allow users with 'manage:stocks' permission full access.
DROP POLICY IF EXISTS "Allow managers full access on stocks" ON public.stocks;
CREATE POLICY "Allow managers full access on stocks" ON public.stocks
FOR ALL USING (public.has_permission('manage:stocks'));


-- Step 5: Add the new permission to the permissions table.
INSERT INTO public.permissions (action, description)
VALUES ('manage:stocks', 'Can add, update, and track stocks.')
ON CONFLICT (action) DO UPDATE SET description = EXCLUDED.description;


-- Step 6: Assign the new permission to the Admin role.
DO $$
DECLARE
    admin_role_id UUID;
    manage_stocks_perm_id UUID;
BEGIN
    -- Get IDs
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    SELECT id INTO manage_stocks_perm_id FROM public.permissions WHERE action = 'manage:stocks';

    -- Assign the permission to Admin if both exist
    IF admin_role_id IS NOT NULL AND manage_stocks_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, manage_stocks_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
    END IF;
END $$;


COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Historical Stock Data Table
-- #
-- # Purpose: This script adds the `historical_data` table to store daily
-- # price information for stocks.
-- #
-- # It performs three key actions:
-- # 1. Creates the `historical_data` table with appropriate constraints and a
-- #    foreign key relationship to the `stocks` table.
-- # 2. Adds a composite B-tree index on `stock_symbol` and `date` for fast lookups.
-- # 3. Sets up Row Level Security (RLS) policies, allowing public read access
-- #    and write access for users with the 'manage:stocks' permission.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the historical_data table.
-- The IF NOT EXISTS clause prevents errors if the table already exists.
CREATE TABLE IF NOT EXISTS public.historical_data (
  id serial NOT NULL,
  stock_symbol text NULL,
  date date NOT NULL,
  open real NULL,
  high real NULL,
  low real NULL,
  close real NULL,
  volume bigint NULL,
  CONSTRAINT historical_data_pkey PRIMARY KEY (id),
  CONSTRAINT historical_data_stock_symbol_date_key UNIQUE (stock_symbol, date),
  CONSTRAINT historical_data_stock_symbol_fkey FOREIGN KEY (stock_symbol) REFERENCES stocks (symbol) ON DELETE CASCADE
);
COMMENT ON TABLE public.historical_data IS 'Stores daily open, high, low, close, and volume data for stocks.';


-- Step 2: Create a B-tree index for efficient querying by symbol and date.
CREATE INDEX IF NOT EXISTS idx_hist_symbol_date ON public.historical_data USING btree (stock_symbol, date);


-- Step 3: Set up Row Level Security (RLS) on the new table.
ALTER TABLE public.historical_data ENABLE ROW LEVEL SECURITY;

-- Policy 1: Allow anyone to read all historical data.
DROP POLICY IF EXISTS "Allow public read access on historical_data" ON public.historical_data;
CREATE POLICY "Allow public read access on historical_data" ON public.historical_data
FOR SELECT USING (true);

-- Policy 2: Allow users with 'manage:stocks' permission full access.
-- This reuses the existing permission for managing stocks, as it's related data.
DROP POLICY IF EXISTS "Allow managers full access on historical_data" ON public.historical_data;
CREATE POLICY "Allow managers full access on historical_data" ON public.historical_data
FOR ALL USING (public.has_permission('manage:stocks'));


COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Indicators, Forecasts, and Audit Tables
-- #
-- # Purpose: This script adds all the necessary tables for storing technical
-- # analysis data, model forecasts, and auditing results.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- #############################################################################
-- # Table: indicator_definitions
-- #############################################################################

CREATE TABLE IF NOT EXISTS public.indicator_definitions (
  id serial NOT NULL,
  name text NOT NULL,
  type text NOT NULL,
  description text NULL,
  period integer NULL,
  requires text NULL,
  bullish boolean NULL,
  confidence_range text NULL,
  CONSTRAINT indicator_definitions_pkey PRIMARY KEY (id),
  CONSTRAINT indicator_definitions_name_key UNIQUE (name),
  CONSTRAINT indicator_definitions_type_check CHECK (
    (
      type = ANY (ARRAY['technical'::text, 'candle'::text])
    )
  )
);
COMMENT ON TABLE public.indicator_definitions IS 'Stores definitions for technical indicators and candlestick patterns.';

ALTER TABLE public.indicator_definitions ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access on indicator_definitions" ON public.indicator_definitions;
CREATE POLICY "Allow public read access on indicator_definitions" ON public.indicator_definitions FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow managers full access on indicator_definitions" ON public.indicator_definitions;
CREATE POLICY "Allow managers full access on indicator_definitions" ON public.indicator_definitions FOR ALL USING (public.has_permission('manage:stocks'));


-- #############################################################################
-- # Table: technical_indicators
-- #############################################################################

CREATE TABLE IF NOT EXISTS public.technical_indicators (
  id serial NOT NULL,
  stock_symbol text NULL,
  date date NOT NULL,
  rsi real NULL,
  macd real NULL,
  macd_signal real NULL,
  macd_histogram real NULL,
  sma20 real NULL,
  sma50 real NULL,
  sma200 real NULL,
  ema12 real NULL,
  ema26 real NULL,
  boll_upper real NULL,
  boll_middle real NULL,
  boll_lower real NULL,
  stochastic_k real NULL,
  stochastic_d real NULL,
  williams_r real NULL,
  volatility_20 double precision NULL,
  atr14 double precision NULL,
  macd_cross smallint NULL,
  rsi_zone smallint NULL,
  CONSTRAINT technical_indicators_pkey PRIMARY KEY (id),
  CONSTRAINT technical_indicators_stock_symbol_date_key UNIQUE (stock_symbol, date),
  CONSTRAINT technical_indicators_stock_symbol_fkey FOREIGN KEY (stock_symbol) REFERENCES stocks (symbol) ON DELETE CASCADE
);
COMMENT ON TABLE public.technical_indicators IS 'Stores calculated daily technical indicator values for stocks.';

CREATE INDEX IF NOT EXISTS idx_ti_symbol_date ON public.technical_indicators USING btree (stock_symbol, date);

ALTER TABLE public.technical_indicators ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access on technical_indicators" ON public.technical_indicators;
CREATE POLICY "Allow public read access on technical_indicators" ON public.technical_indicators FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow managers full access on technical_indicators" ON public.technical_indicators;
CREATE POLICY "Allow managers full access on technical_indicators" ON public.technical_indicators FOR ALL USING (public.has_permission('manage:stocks'));


-- #############################################################################
-- # Table: candle_patterns
-- #############################################################################

CREATE TABLE IF NOT EXISTS public.candle_patterns (
  id serial NOT NULL,
  stock_symbol text NULL,
  date date NOT NULL,
  pattern_name text NOT NULL,
  description text NULL,
  bullish boolean NULL,
  confidence real NULL,
  CONSTRAINT candle_patterns_pkey PRIMARY KEY (id),
  CONSTRAINT candle_patterns_stock_symbol_date_pattern_name_key UNIQUE (stock_symbol, date, pattern_name),
  CONSTRAINT candle_patterns_stock_symbol_fkey FOREIGN KEY (stock_symbol) REFERENCES stocks (symbol) ON DELETE CASCADE,
  CONSTRAINT candle_patterns_confidence_check CHECK (
    (
      (confidence >= (0)::double precision)
      AND (confidence <= (1)::double precision)
    )
  )
);
COMMENT ON TABLE public.candle_patterns IS 'Stores detected candlestick patterns for stocks on a given day.';

CREATE INDEX IF NOT EXISTS idx_candle_symbol_date ON public.candle_patterns USING btree (stock_symbol, date);

ALTER TABLE public.candle_patterns ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access on candle_patterns" ON public.candle_patterns;
CREATE POLICY "Allow public read access on candle_patterns" ON public.candle_patterns FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow managers full access on candle_patterns" ON public.candle_patterns;
CREATE POLICY "Allow managers full access on candle_patterns" ON public.candle_patterns FOR ALL USING (public.has_permission('manage:stocks'));


-- #############################################################################
-- # Table: forecasts
-- #############################################################################

CREATE TABLE IF NOT EXISTS public.forecasts (
  id serial NOT NULL,
  stock_symbol text NULL,
  forecast_date date NOT NULL,
  predicted_price real NOT NULL,
  confidence real NULL,
  generated_at timestamp WITHOUT TIME ZONE NULL DEFAULT CURRENT_TIMESTAMP,
  predicted_lo real NULL,
  predicted_hi real NULL,
  coverage_target real NULL,
  model_version text NULL,
  CONSTRAINT forecasts_pkey PRIMARY KEY (id),
  CONSTRAINT forecasts_stock_symbol_forecast_date_key UNIQUE (stock_symbol, forecast_date),
  CONSTRAINT forecasts_stock_symbol_fkey FOREIGN KEY (stock_symbol) REFERENCES stocks (symbol) ON DELETE CASCADE,
  CONSTRAINT forecasts_confidence_check CHECK (
    (
      (confidence >= (0)::double precision)
      AND (confidence <= (1)::double precision)
    )
  ),
  CONSTRAINT forecasts_coverage_range_chk CHECK (
    (
      (coverage_target IS NULL)
      OR (
        (coverage_target >= (0.0)::double precision)
        AND (coverage_target <= (1.0)::double precision)
      )
    )
  ),
  CONSTRAINT forecasts_pred_interval_chk CHECK (
    (
      (
        (predicted_lo IS NULL)
        OR (predicted_price IS NULL)
        OR (predicted_lo <= predicted_price)
      )
      AND (
        (predicted_hi IS NULL)
        OR (predicted_price IS NULL)
        OR (predicted_price <= predicted_hi)
      )
    )
  )
);
COMMENT ON TABLE public.forecasts IS 'Stores price forecasts generated by machine learning models.';

CREATE INDEX IF NOT EXISTS idx_forecasts_symbol_date ON public.forecasts USING btree (stock_symbol, forecast_date);

ALTER TABLE public.forecasts ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access on forecasts" ON public.forecasts;
CREATE POLICY "Allow public read access on forecasts" ON public.forecasts FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow managers full access on forecasts" ON public.forecasts;
CREATE POLICY "Allow managers full access on forecasts" ON public.forecasts FOR ALL USING (public.has_permission('manage:stocks'));


-- #############################################################################
-- # Table: audit_runs
-- #############################################################################

CREATE TABLE IF NOT EXISTS public.audit_runs (
  id bigserial NOT NULL,
  started_at timestamp WITH TIME ZONE NULL DEFAULT now(),
  ended_at timestamp WITH TIME ZONE NULL,
  status text NULL DEFAULT 'success'::text,
  n_symbols integer NULL,
  n_forecasts integer NULL,
  n_evaluated integer NULL,
  n_missing_actuals integer NULL,
  n_duplicates integer NULL,
  n_anomalies integer NULL,
  mae double precision NULL,
  mape double precision NULL,
  notes text NULL,
  script_version text NULL,
  CONSTRAINT audit_runs_pkey PRIMARY KEY (id),
  CONSTRAINT audit_runs_status_check CHECK (
    (
      status = ANY (
        ARRAY['success'::text, 'partial'::text, 'error'::text]
      )
    )
  )
);
COMMENT ON TABLE public.audit_runs IS 'Logs the execution and results of data processing and auditing scripts.';

ALTER TABLE public.audit_runs ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow settings managers full access on audit_runs" ON public.audit_runs;
CREATE POLICY "Allow settings managers full access on audit_runs" ON public.audit_runs FOR ALL USING (public.has_permission('manage:settings'));


-- #############################################################################
-- # Table: Forcast_Result
-- #############################################################################

CREATE TABLE IF NOT EXISTS public."Forcast_Result" (
  stock_symbol text NOT NULL,
  stock_name text NOT NULL,
  forecast_date date NOT NULL,
  predicted_lo real NOT NULL,
  predicted_hi real NOT NULL,
  actual_low real NOT NULL,
  actual_high real NOT NULL,
  is_hit boolean NOT NULL,
  created_at timestamp WITHOUT TIME ZONE NOT NULL DEFAULT now(),
  CONSTRAINT forcast_result_pk UNIQUE (stock_symbol, forecast_date),
  CONSTRAINT forcast_result_symbol_fk FOREIGN KEY (stock_symbol) REFERENCES stocks (symbol) ON DELETE CASCADE,
  CONSTRAINT forcast_result_actual_range_chk CHECK ((actual_low <= actual_high)),
  CONSTRAINT forcast_result_pred_range_chk CHECK ((predicted_lo <= predicted_hi))
);
COMMENT ON TABLE public."Forcast_Result" IS 'Stores the results of forecast evaluations against actual market data.';

CREATE INDEX IF NOT EXISTS idx_forcast_result_symbol_date ON public."Forcast_Result" USING btree (stock_symbol, forecast_date);
CREATE INDEX IF NOT EXISTS idx_forcast_result_date ON public."Forcast_Result" USING btree (forecast_date);

ALTER TABLE public."Forcast_Result" ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access on Forcast_Result" ON public."Forcast_Result";
CREATE POLICY "Allow public read access on Forcast_Result" ON public."Forcast_Result" FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow managers full access on Forcast_Result" ON public."Forcast_Result";
CREATE POLICY "Allow managers full access on Forcast_Result" ON public."Forcast_Result" FOR ALL USING (public.has_permission('manage:stocks'));

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Audit Forecast Metrics Table
-- #
-- # Purpose: This script adds the `audit_forecast_metrics` table to store
-- # detailed metrics for each forecast during an audit run.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the audit_forecast_metrics table.
CREATE TABLE IF NOT EXISTS public.audit_forecast_metrics (
  run_id bigint NOT NULL,
  stock_symbol text NOT NULL,
  forecast_date date NOT NULL,
  predicted_price double precision NULL,
  predicted_lo double precision NULL,
  predicted_hi double precision NULL,
  confidence double precision NULL,
  actual_close double precision NULL,
  abs_error double precision NULL,
  pct_error double precision NULL,
  hit_range boolean NULL,
  anomaly text NULL,
  generated_at date NULL,
  CONSTRAINT audit_forecast_metrics_pkey PRIMARY KEY (run_id, stock_symbol, forecast_date),
  CONSTRAINT audit_forecast_metrics_run_id_fkey FOREIGN KEY (run_id) REFERENCES audit_runs (id) ON DELETE CASCADE,
  CONSTRAINT audit_forecast_metrics_stock_symbol_fkey FOREIGN KEY (stock_symbol) REFERENCES stocks (symbol) ON DELETE CASCADE
);
COMMENT ON TABLE public.audit_forecast_metrics IS 'Stores detailed metrics for each forecast evaluated during an audit run.';


-- Step 2: Create a B-tree index for efficient querying by symbol and date.
CREATE INDEX IF NOT EXISTS idx_afm_symbol_date ON public.audit_forecast_metrics USING btree (stock_symbol, forecast_date);


-- Step 3: Set up Row Level Security (RLS) on the new table.
ALTER TABLE public.audit_forecast_metrics ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users with 'manage:settings' permission full access to audit data.
-- Audit data is sensitive and should not be public.
DROP POLICY IF EXISTS "Allow settings managers full access on audit_forecast_metrics" ON public.audit_forecast_metrics;
CREATE POLICY "Allow settings managers full access on audit_forecast_metrics" ON public.audit_forecast_metrics
FOR ALL USING (public.has_permission('manage:settings'));


COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Stock Analysis System
-- #
-- # Purpose: This script introduces the backend components for the new
-- # Stock Analysis dashboard page.
-- #
-- # It performs three key actions:
-- # 1. Creates a new permission `view:stock_analysis`.
-- # 2. Assigns this permission to the 'Admin' role.
-- # 3. Creates a suite of secure RPC functions to fetch aggregated and
-- #    detailed data for the analysis page, improving performance and security.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Add the new permission to the permissions table.
INSERT INTO public.permissions (action, description)
VALUES ('view:stock_analysis', 'Can view the stock analysis and forecast performance dashboard.')
ON CONFLICT (action) DO UPDATE SET description = EXCLUDED.description;


-- Step 2: Assign the new permission to the Admin role.
DO $$
DECLARE
    admin_role_id UUID;
    view_analysis_perm_id UUID;
BEGIN
    RAISE NOTICE 'SUCCESS: Permission "view:stock_analysis" added or already exists.';
    -- Get IDs
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    SELECT id INTO view_analysis_perm_id FROM public.permissions WHERE action = 'view:stock_analysis';

    -- Assign the permission to Admin if both exist
    IF admin_role_id IS NOT NULL AND view_analysis_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, view_analysis_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;

        IF FOUND THEN
             RAISE NOTICE 'SUCCESS: Assigned "view:stock_analysis" permission to Admin role.';
        ELSE
             RAISE NOTICE 'INFO: Admin role already has "view:stock_analysis" permission.';
        END IF;
    ELSE
        RAISE WARNING 'Could not assign "view:stock_analysis" permission. Admin role or permission not found.';
    END IF;
END $$;


-- Step 3: Create RPC functions for the analysis page.

-- Function 1: Get high-level summary statistics.
CREATE OR REPLACE FUNCTION public.get_stock_analysis_summary()
RETURNS json
LANGUAGE sql
STABLE
AS $$
SELECT json_build_object(
    'tracked_stocks_count', (SELECT count(*) FROM public.stocks WHERE is_tracked = true),
    'latest_forecast_date', (SELECT max(forecast_date) FROM public.forecasts),
    'last_audit_mape', (SELECT mape FROM public.audit_runs ORDER BY started_at DESC LIMIT 1),
    'last_audit_hit_rate', (
        SELECT avg(CASE WHEN hit_range = true THEN 1 ELSE 0 END)
        FROM public.audit_forecast_metrics
        WHERE run_id = (SELECT id FROM public.audit_runs ORDER BY started_at DESC LIMIT 1)
    )
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_stock_analysis_summary" created or updated.';


-- Function 2: Get a list of tracked stocks for the search dropdown.
CREATE OR REPLACE FUNCTION public.get_tracked_stocks_list()
RETURNS TABLE(symbol TEXT, name TEXT)
LANGUAGE sql
STABLE
AS $$
  SELECT symbol, name
  FROM public.stocks
  WHERE is_tracked = true
  ORDER BY symbol;
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_tracked_stocks_list" created or updated.';


-- Function 3: Get detailed data for a specific stock for the deep-dive view.
CREATE OR REPLACE FUNCTION public.get_stock_deep_dive(p_symbol TEXT)
RETURNS json
LANGUAGE sql
STABLE
AS $$
SELECT json_build_object(
    'details', (
        SELECT row_to_json(s)
        FROM public.stocks s
        WHERE s.symbol = p_symbol
    ),
    'historical_data', (
        SELECT COALESCE(json_agg(h ORDER BY h.date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.historical_data
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 90
        ) h
    ),
    'technical_indicators', (
        SELECT COALESCE(json_agg(ti ORDER BY ti.date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.technical_indicators
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 90
        ) ti
    ),
    'candle_patterns', (
         SELECT COALESCE(json_agg(cp ORDER BY cp.date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.candle_patterns
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 30 -- Patterns are less frequent, limit to a smaller recent window
        ) cp
    ),
    'latest_forecast', (
        SELECT row_to_json(f)
        FROM public.forecasts f
        WHERE f.stock_symbol = p_symbol
        ORDER BY f.forecast_date DESC
        LIMIT 1
    ),
    'forecast_history', (
        SELECT COALESCE(json_agg(afm ORDER BY afm.forecast_date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.audit_forecast_metrics
            WHERE stock_symbol = p_symbol
            ORDER BY forecast_date DESC
            LIMIT 10
        ) afm
    )
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_stock_deep_dive" created or updated.';


COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Stock Analysis UI Translations
-- #
-- # Purpose: This script adds all the translation keys needed for the new
-- # Stock Analysis dashboard page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Page Title & Permission
('en', 'stock_analysis', 'Stock Analysis'),
('ar', 'stock_analysis', 'تحليل الأسهم'),
('en', 'perm_view_stock_analysis', 'View Stock Analysis'),
('ar', 'perm_view_stock_analysis', 'عرض تحليل الأسهم'),
('en', 'perm_view_stock_analysis_desc', 'Can view the stock analysis and forecast performance dashboard.'),
('ar', 'perm_view_stock_analysis_desc', 'يمكنه عرض لوحة معلومات تحليل الأسهم وأداء التوقعات.'),

-- Summary Cards
('en', 'analysis_overview', 'Analysis Overview'),
('ar', 'analysis_overview', 'نظرة عامة على التحليل'),
('en', 'tracked_stocks', 'Tracked Stocks'),
('ar', 'tracked_stocks', 'الأسهم المتعقبة'),
('en', 'latest_forecast', 'Latest Forecast Date'),
('ar', 'latest_forecast', 'تاريخ آخر توقع'),
('en', 'overall_accuracy', 'Overall Hit Rate'),
('ar', 'overall_accuracy', 'معدل الدقة الإجمالي'),
('en', 'avg_error_mape', 'Avg. Error (MAPE)'),
('ar', 'avg_error_mape', 'متوسط الخطأ (MAPE)'),

-- Stock Deep Dive Section
('en', 'stock_deep_dive', 'Stock Deep Dive'),
('ar', 'stock_deep_dive', 'تحليل معمق للسهم'),
('en', 'search_stock_symbol', 'Search for a stock symbol...'),
('ar', 'search_stock_symbol', 'ابحث عن رمز سهم...'),
('en', 'select_a_stock', 'Select a stock to view its detailed analysis.'),
('ar', 'select_a_stock', 'اختر سهماً لعرض تحليله التفصيلي.'),
('en', 'last_price', 'Last Price'),
('ar', 'last_price', 'آخر سعر'),
('en', 'change', 'Change'),
('ar', 'change', 'التغيير'),
('en', 'volume', 'Volume'),
('ar', 'volume', 'الحجم'),
('en', 'market_cap', 'Market Cap'),
('ar', 'market_cap', 'القيمة السوقية'),

-- Forecast History Table
('en', 'forecast_vs_actual', 'Forecast vs. Actual History'),
('ar', 'forecast_vs_actual', 'سجل التوقعات مقابل الأداء الفعلي'),
('en', 'forecast_date', 'Forecast Date'),
('ar', 'forecast_date', 'تاريخ التوقع'),
('en', 'predicted_price', 'Predicted'),
('ar', 'predicted_price', 'المتوقع'),
('en', 'actual_price', 'Actual'),
('ar', 'actual_price', 'الفعلي'),
('en', 'outcome', 'Outcome'),
('ar', 'outcome', 'النتيجة'),
('en', 'hit', 'Hit'),
('ar', 'hit', 'أصاب'),
('en', 'miss', 'Miss'),
('ar', 'miss', 'أخطأ'),

-- Recent Patterns
('en', 'recent_candle_patterns', 'Recent Candle Patterns'),
('ar', 'recent_candle_patterns', 'أنماط الشموع الأخيرة'),
('en', 'pattern', 'Pattern'),
('ar', 'pattern', 'النمط'),
('en', 'date', 'Date'),
('ar', 'date', 'التاريخ'),
('en', 'sentiment', 'Sentiment'),
('ar', 'sentiment', 'المؤشر'),
('en', 'bullish', 'Bullish'),
('ar', 'bullish', 'صاعد'),
('en', 'bearish', 'Bearish'),
('ar', 'bearish', 'هابط')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Forecast Hit Logic
-- #
-- # Purpose: This script updates the logic for determining a forecast "hit"
-- # in the stock analysis deep dive. The new logic considers a forecast a hit
-- # if the predicted range [predicted_lo, predicted_hi] overlaps with the
-- # actual daily range [actual_low, actual_high].
-- #
-- # It updates the `get_stock_deep_dive` function to perform this calculation
-- # on the fly by joining with the `historical_data` table.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Update the RPC function to fetch all schema information.
CREATE OR REPLACE FUNCTION public.get_stock_deep_dive(p_symbol TEXT)
RETURNS json
LANGUAGE sql
STABLE
AS $$
SELECT json_build_object(
    'details', (
        SELECT row_to_json(s)
        FROM public.stocks s
        WHERE s.symbol = p_symbol
    ),
    'historical_data', (
        SELECT COALESCE(json_agg(h ORDER BY h.date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.historical_data
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 90
        ) h
    ),
    'technical_indicators', (
        SELECT COALESCE(json_agg(ti ORDER BY ti.date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.technical_indicators
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 90
        ) ti
    ),
    'candle_patterns', (
         SELECT COALESCE(json_agg(cp ORDER BY cp.date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.candle_patterns
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 30
        ) cp
    ),
    'latest_forecast', (
        SELECT row_to_json(f)
        FROM public.forecasts f
        WHERE f.stock_symbol = p_symbol
        ORDER BY f.forecast_date DESC
        LIMIT 1
    ),
    'forecast_history', (
        SELECT COALESCE(json_agg(fc ORDER BY fc.forecast_date DESC), '[]'::json)
        FROM (
            SELECT
                afm.run_id,
                afm.stock_symbol,
                afm.forecast_date,
                afm.predicted_price,
                afm.actual_close,
                -- New hit logic: True if predicted range overlaps with actual daily range.
                (afm.predicted_lo <= hd.high AND hd.low <= afm.predicted_hi) as hit_range
            FROM
                public.audit_forecast_metrics afm
            JOIN
                public.historical_data hd ON afm.stock_symbol = hd.stock_symbol AND afm.forecast_date = hd.date
            WHERE
                afm.stock_symbol = p_symbol
            ORDER BY
                afm.forecast_date DESC
            LIMIT 10
        ) fc
    )
);
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_stock_deep_dive" updated with new forecast hit logic.';

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Stock Analysis Backend
-- #
-- # Purpose: This script enhances the backend functions for the Stock Analysis
-- # page to provide more detailed statistics and highlights.
-- #
-- # It performs two key actions:
-- # 1. Updates the `get_stock_analysis_summary` RPC function to include
-- #    counts for total hits, misses, and evaluated forecasts.
-- # 2. Creates a new `get_market_highlights` RPC function to fetch the most
-- #    recent hits and misses for a new UI component.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Update the summary function to include more stats.
CREATE OR REPLACE FUNCTION public.get_stock_analysis_summary()
RETURNS json
LANGUAGE sql
STABLE
AS $$
WITH last_run AS (
    SELECT id FROM public.audit_runs ORDER BY started_at DESC LIMIT 1
), metrics AS (
    SELECT hit_range FROM public.audit_forecast_metrics WHERE run_id = (SELECT id FROM last_run)
)
SELECT json_build_object(
    'tracked_stocks_count', (SELECT count(*) FROM public.stocks WHERE is_tracked = true),
    'latest_forecast_date', (SELECT max(forecast_date) FROM public.forecasts),
    'last_audit_mape', (SELECT mape FROM public.audit_runs WHERE id = (SELECT id FROM last_run)),
    'last_audit_hit_rate', (SELECT avg(CASE WHEN hit_range = true THEN 1 ELSE 0 END) FROM metrics),
    'last_audit_hits', (SELECT count(*) FROM metrics WHERE hit_range = true),
    'last_audit_misses', (SELECT count(*) FROM metrics WHERE hit_range = false),
    'last_audit_evaluated_count', (SELECT count(*) FROM metrics)
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_stock_analysis_summary" updated with hit/miss counts.';


-- Step 2: Create a new function to get market highlights (recent hits/misses).
CREATE OR REPLACE FUNCTION public.get_market_highlights()
RETURNS json
LANGUAGE sql STABLE AS $$
WITH last_run AS (
    SELECT id FROM public.audit_runs ORDER BY started_at DESC LIMIT 1
)
SELECT json_build_object(
    'recent_hits', (
        SELECT COALESCE(json_agg(hits.*), '[]'::json)
        FROM (
            SELECT
                afm.stock_symbol,
                s.name as stock_name,
                afm.forecast_date,
                afm.predicted_price,
                afm.actual_close
            FROM public.audit_forecast_metrics afm
            JOIN public.stocks s ON afm.stock_symbol = s.symbol
            WHERE afm.run_id = (SELECT id FROM last_run) AND afm.hit_range = true
            ORDER BY afm.forecast_date DESC
            LIMIT 5
        ) hits
    ),
    'recent_misses', (
        SELECT COALESCE(json_agg(misses.*), '[]'::json)
        FROM (
             SELECT
                afm.stock_symbol,
                s.name as stock_name,
                afm.forecast_date,
                afm.predicted_price,
                afm.actual_close
            FROM public.audit_forecast_metrics afm
            JOIN public.stocks s ON afm.stock_symbol = s.symbol
            WHERE afm.run_id = (SELECT id FROM last_run) AND afm.hit_range = false
            ORDER BY afm.forecast_date DESC
            LIMIT 5
        ) misses
    )
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_market_highlights" created.';


COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add V2 Stock Analysis UI Translations
-- #
-- # Purpose: This script adds all the new translation keys needed for the
-- # redesigned Stock Analysis dashboard page, including the new stat cards
-- # and the "Market Highlights" section.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- New Stat Cards
('en', 'correct_forecasts', 'Correct Forecasts'),
('ar', 'correct_forecasts', 'التوقعات الصحيحة'),
('en', 'incorrect_forecasts', 'Incorrect Forecasts'),
('ar', 'incorrect_forecasts', 'التوقعات غير الصحيحة'),

-- Market Highlights Section
('en', 'market_highlights', 'Market Highlights'),
('ar', 'market_highlights', 'أبرز ما في السوق'),
('en', 'recent_hits', 'Recent Hits'),
('ar', 'recent_hits', 'أحدث التوقعات الصحيحة'),
('en', 'recent_misses', 'Recent Misses'),
('ar', 'recent_misses', 'أحدث التوقعات الخاطئة'),
('en', 'stock', 'Stock'),
('ar', 'stock', 'السهم'),
('en', 'predicted', 'Predicted'),
('ar', 'predicted', 'المتوقع'),

-- Updated Description
('en', 'perm_view_stock_analysis_desc', 'Provides an overview of forecast accuracy and detailed analysis for individual stocks.'),
('ar', 'perm_view_stock_analysis_desc', 'يوفر نظرة عامة على دقة التوقعات وتحليلاً مفصلاً للأسهم الفردية.')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Stock Analysis UI Translations
-- #
-- # Purpose: This script updates the translation for "Tracked Stocks" to
-- # "Total Number of Companies" and adds the missing translation for the
-- # "Actual" table header on the Stock Analysis page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- 1. Update the Arabic translation for 'tracked_stocks'
INSERT INTO public.translations (lang_id, key, value) VALUES
('ar', 'tracked_stocks', 'عدد الشركات الاجمالي')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- 2. Add translation for 'actual' table header
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'actual', 'Actual'),
('ar', 'actual', 'الفعلي')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Stock Analysis translations have been updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Stock Permission Translations & Fix Role Management UI
-- #
-- # Purpose: This script adds missing translations for the "manage:stocks"
-- # permission and ensures other Role Management UI keys are correctly translated.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/update translations for the Role Management page.
-- The ON CONFLICT clause makes this script safe to re-run.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Key for the page title, ensuring it exists with a more natural translation
('en', 'permissions_for_role', 'Permissions for role: {roleName}'),
('ar', 'permissions_for_role', 'صلاحيات دور: {roleName}'),

-- New key for the 'manage:stocks' permission
('en', 'perm_manage_stocks', 'Manage Stocks'),
('ar', 'perm_manage_stocks', 'إدارة الأسهم'),
('en', 'perm_manage_stocks_desc', 'Can add, update, and track stocks.'),
('ar', 'perm_manage_stocks_desc', 'يمكنه إضافة وتحديث وتتبع الأسهم.')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for the Role Management and Stock permissions have been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Daily Stock Analysis Functions
-- #
-- # Purpose: This script creates a suite of new RPC functions to fetch
-- # forecast data and analysis specifically for the latest available day.
-- # This supports a redesigned, more focused "Stock Analysis" page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Function 1: Get the most recent date for which forecasts exist.
CREATE OR REPLACE FUNCTION public.get_latest_forecast_date()
RETURNS date
LANGUAGE sql STABLE AS $$
  SELECT max(forecast_date) FROM public.forecasts;
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_latest_forecast_date" created or updated.';


-- Function 2: Get high-level summary statistics for a specific date.
CREATE OR REPLACE FUNCTION public.get_daily_analysis_summary(p_date date)
RETURNS json
LANGUAGE sql STABLE AS $$
WITH daily_metrics AS (
    SELECT
        -- Use the pre-calculated hit_range for consistency
        afm.hit_range,
        afm.predicted_price,
        afm.actual_close
    FROM public.audit_forecast_metrics afm
    WHERE afm.forecast_date = p_date AND afm.actual_close IS NOT NULL
)
SELECT json_build_object(
    'forecast_date', p_date,
    'total_forecasts', (SELECT count(*) FROM daily_metrics),
    'hits', (SELECT count(*) FROM daily_metrics WHERE hit_range = true),
    'misses', (SELECT count(*) FROM daily_metrics WHERE hit_range = false),
    'hit_rate', (SELECT avg(CASE WHEN hit_range = true THEN 1 ELSE 0 END) FROM daily_metrics),
    'mape', (SELECT avg(abs(predicted_price - actual_close) / actual_close) FROM daily_metrics WHERE actual_close > 0)
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_daily_analysis_summary" created or updated.';


-- Function 3: Get the detailed list of all forecast results for a specific date.
CREATE OR REPLACE FUNCTION public.get_daily_forecast_results(p_date date)
RETURNS TABLE (
    stock_symbol text,
    stock_name text,
    predicted_price real,
    predicted_lo real,
    predicted_hi real,
    actual_close real,
    actual_low real,
    actual_high real,
    is_hit boolean
)
LANGUAGE sql STABLE AS $$
SELECT
    afm.stock_symbol,
    s.name as stock_name,
    afm.predicted_price::real,
    afm.predicted_lo::real,
    afm.predicted_hi::real,
    afm.actual_close::real,
    hd.low as actual_low,
    hd.high as actual_high,
    -- Use the pre-calculated hit_range from the audit table for consistency
    afm.hit_range as is_hit
FROM
    public.audit_forecast_metrics afm
JOIN
    public.stocks s ON afm.stock_symbol = s.symbol
-- Use LEFT JOIN on historical_data in case it's missing, but actual_close exists in audit
LEFT JOIN
    public.historical_data hd ON afm.stock_symbol = hd.stock_symbol AND afm.forecast_date = hd.date
WHERE
    afm.forecast_date = p_date
ORDER BY
    afm.stock_symbol;
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_daily_forecast_results" created or updated.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Daily Stock Analysis UI Translations
-- #
-- # Purpose: This script adds all the translation keys needed for the new
-- # daily-focused Stock Analysis dashboard page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'daily_forecast_analysis', 'Daily Forecast Analysis'),
('ar', 'daily_forecast_analysis', 'تحليل التوقعات اليومي'),
('en', 'forecasts_for_date', 'Forecasts for {date}'),
('ar', 'forecasts_for_date', 'توقعات ليوم {date}'),
('en', 'total_forecasts', 'Total Forecasts'),
('ar', 'total_forecasts', 'إجمالي التوقعات'),
('en', 'hit_rate', 'Hit Rate'),
('ar', 'hit_rate', 'معدل النجاح'),
('en', 'predicted_range', 'Predicted Range'),
('ar', 'predicted_range', 'النطاق المتوقع'),
('en', 'actual_range', 'Actual Range'),
('ar', 'actual_range', 'النطاق الفعلي'),
('en', 'no_forecasts_today', 'No forecast data is available for the latest date.'),
('ar', 'no_forecasts_today', 'لا توجد بيانات توقعات متاحة لآخر تاريخ.'),
('en', 'stock_symbol', 'Symbol'),
('ar', 'stock_symbol', 'الرمز')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Stock Analysis Page Title
-- #
-- # Purpose: This script updates the name of the "Stock Analysis" page to
-- # "Last Work Day" as requested.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- 1. Update the 'stock_analysis' key to the new name.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'stock_analysis', 'Last Work Day'),
('ar', 'stock_analysis', 'آخر يوم عمل')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- 2. Delete the now-redundant 'daily_forecast_analysis' key.
-- The page component has been updated to use 'stock_analysis' for its title.
DELETE FROM public.translations WHERE key = 'daily_forecast_analysis';

RAISE NOTICE 'SUCCESS: Stock Analysis page titles have been updated and unified.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Consolidate Stock Analysis Functions
-- #
-- # Purpose: This script refactors the data fetching for the Stock Analysis page
-- # by replacing three separate functions with a single, efficient RPC function.
-- # This improves performance by reducing network requests.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the new consolidated function.
CREATE OR REPLACE FUNCTION public.get_daily_stock_analysis_page_data()
RETURNS json
LANGUAGE sql STABLE AS $$
WITH latest_date AS (
    SELECT max(forecast_date) as value FROM public.forecasts
)
SELECT json_build_object(
    'summary', (
        WITH daily_metrics AS (
            SELECT
                afm.hit_range,
                afm.predicted_price,
                afm.actual_close
            FROM public.audit_forecast_metrics afm
            WHERE afm.forecast_date = (SELECT value FROM latest_date) AND afm.actual_close IS NOT NULL
        )
        SELECT json_build_object(
            'forecast_date', (SELECT value FROM latest_date),
            'total_forecasts', (SELECT count(*) FROM daily_metrics),
            'hits', (SELECT count(*) FROM daily_metrics WHERE hit_range = true),
            'misses', (SELECT count(*) FROM daily_metrics WHERE hit_range = false),
            'hit_rate', (SELECT avg(CASE WHEN hit_range = true THEN 1 ELSE 0 END) FROM daily_metrics)
        )
    ),
    'results', (
        SELECT COALESCE(json_agg(res), '[]'::json)
        FROM (
            SELECT
                afm.stock_symbol,
                s.name as stock_name,
                afm.forecast_date,
                afm.predicted_lo::real,
                afm.predicted_hi::real,
                afm.actual_close::real,
                hd.low as actual_low,
                hd.high as actual_high,
                afm.hit_range as is_hit
            FROM
                public.audit_forecast_metrics afm
            JOIN
                public.stocks s ON afm.stock_symbol = s.symbol
            LEFT JOIN
                public.historical_data hd ON afm.stock_symbol = hd.stock_symbol AND afm.forecast_date = hd.date
            WHERE
                afm.forecast_date = (SELECT value FROM latest_date)
            ORDER BY
                afm.stock_symbol
        ) res
    )
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_daily_stock_analysis_page_data" created or updated.';


-- Step 2: Drop the old, now redundant functions.
DROP FUNCTION IF EXISTS public.get_latest_forecast_date();
DROP FUNCTION IF EXISTS public.get_daily_analysis_summary(p_date date);
DROP FUNCTION IF EXISTS public.get_daily_forecast_results(p_date date);
RAISE NOTICE 'SUCCESS: Old stock analysis functions have been dropped.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translations for Stock Analysis Visuals
-- #
-- # Purpose: This script adds all the new translation keys needed for the
-- # redesigned Stock Analysis page with its new visual components.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'forecast_distribution', 'Forecast Distribution'),
('ar', 'forecast_distribution', 'توزيع التوقعات'),
('en', 'last_price_close', 'Last Price (Close)'),
('ar', 'last_price_close', 'آخر سعر (إغلاق)'),
('en', 'closing_date', 'Closing Date'),
('ar', 'closing_date', 'تاريخ الإغلاق'),
('en', 'actual_low', 'Actual Low'),
('ar', 'actual_low', 'أدنى سعر فعلي'),
('en', 'actual_high', 'Actual High'),
('ar', 'actual_high', 'أعلى سعر فعلي'),
('en', 'predicted_low', 'Predicted Low'),
('ar', 'predicted_low', 'أدنى سعر متوقع'),
('en', 'predicted_high', 'Predicted High'),
('ar', 'predicted_high', 'أعلى سعر متوقع'),
('en', 'forecast_result', 'Result'),
('ar', 'forecast_result', 'النتيجة')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Forecast Check Tables
-- #
-- # Purpose: This script creates two new tables, `forecast_check_latest` and
-- # `forecast_check_history`, to store the results of forecast evaluations.
-- # These tables replace the previous audit system.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Table 1: Latest forecast check results for each active stock
CREATE TABLE IF NOT EXISTS public.forecast_check_latest (
  stock_symbol    text PRIMARY KEY,
  forecast_date   date NOT NULL,
  predicted_price double precision,
  predicted_lo    double precision NOT NULL,
  predicted_hi    double precision NOT NULL,
  actual_low      double precision NOT NULL,
  actual_high     double precision NOT NULL,
  actual_close    double precision,
  hit_range       boolean NOT NULL,
  abs_error       double precision,
  pct_error       double precision,
  confidence      double precision,
  created_at      timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT forecast_check_latest_stock_symbol_fkey FOREIGN KEY (stock_symbol) REFERENCES stocks (symbol) ON DELETE CASCADE
);
COMMENT ON TABLE public.forecast_check_latest IS 'Stores the latest forecast check results for each active stock.';
CREATE INDEX IF NOT EXISTS idx_fcl_date ON public.forecast_check_latest(forecast_date);

-- RLS for forecast_check_latest
ALTER TABLE public.forecast_check_latest ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access on forecast_check_latest" ON public.forecast_check_latest;
CREATE POLICY "Allow public read access on forecast_check_latest" ON public.forecast_check_latest FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow managers full access on forecast_check_latest" ON public.forecast_check_latest;
CREATE POLICY "Allow managers full access on forecast_check_latest" ON public.forecast_check_latest FOR ALL USING (public.has_permission('manage:stocks'));
RAISE NOTICE 'SUCCESS: Table "forecast_check_latest" created and secured.';


-- Table 2: Historical forecast check results for all stocks
CREATE TABLE IF NOT EXISTS public.forecast_check_history (
  stock_symbol    text   NOT NULL,
  forecast_date   date   NOT NULL,
  predicted_price double precision,
  predicted_lo    double precision NOT NULL,
  predicted_hi    double precision NOT NULL,
  actual_low      double precision NOT NULL,
  actual_high     double precision NOT NULL,
  actual_close    double precision,
  hit_range       boolean NOT NULL,
  abs_error       double precision,
  pct_error       double precision,
  confidence      double precision,
  created_at      timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT forecast_check_history_pkey PRIMARY KEY (stock_symbol, forecast_date),
  CONSTRAINT forecast_check_history_stock_symbol_fkey FOREIGN KEY (stock_symbol) REFERENCES stocks (symbol) ON DELETE CASCADE
);
COMMENT ON TABLE public.forecast_check_history IS 'Stores all historical forecast check results.';
CREATE INDEX IF NOT EXISTS idx_fch_date ON public.forecast_check_history(forecast_date);
CREATE INDEX IF NOT EXISTS idx_fch_symbol ON public.forecast_check_history(stock_symbol);

-- RLS for forecast_check_history
ALTER TABLE public.forecast_check_history ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access on forecast_check_history" ON public.forecast_check_history;
CREATE POLICY "Allow public read access on forecast_check_history" ON public.forecast_check_history FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow managers full access on forecast_check_history" ON public.forecast_check_history;
CREATE POLICY "Allow managers full access on forecast_check_history" ON public.forecast_check_history FOR ALL USING (public.has_permission('manage:stocks'));
RAISE NOTICE 'SUCCESS: Table "forecast_check_history" created and secured.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Analysis Functions for New Tables
-- #
-- # Purpose: This script updates all stock analysis RPC functions to use the
-- # new `forecast_check_latest` and `forecast_check_history` tables,
-- # deprecating the old audit system.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Function 1: Update the main function for the "Last Work Day" page.
CREATE OR REPLACE FUNCTION public.get_daily_stock_analysis_page_data()
RETURNS json
LANGUAGE sql STABLE AS $$
WITH latest_date AS (
    SELECT max(forecast_date) as value FROM public.forecast_check_latest
)
SELECT json_build_object(
    'summary', (
        SELECT json_build_object(
            'forecast_date', (SELECT value FROM latest_date),
            'total_forecasts', count(*),
            'hits', count(*) FILTER (WHERE hit_range = true),
            'misses', count(*) FILTER (WHERE hit_range = false),
            'hit_rate', avg(CASE WHEN hit_range = true THEN 1 ELSE 0 END)
        )
        FROM public.forecast_check_latest
        WHERE forecast_date = (SELECT value FROM latest_date)
    ),
    'results', (
        SELECT COALESCE(json_agg(res), '[]'::json)
        FROM (
            SELECT
                fcl.stock_symbol,
                s.name as stock_name,
                fcl.predicted_price::real,
                fcl.predicted_lo::real,
                fcl.predicted_hi::real,
                fcl.actual_close::real,
                fcl.actual_low::real,
                fcl.actual_high::real,
                fcl.hit_range as is_hit
            FROM
                public.forecast_check_latest fcl
            JOIN
                public.stocks s ON fcl.stock_symbol = s.symbol
            WHERE
                fcl.forecast_date = (SELECT value FROM latest_date)
            ORDER BY
                fcl.stock_symbol
        ) res
    )
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_daily_stock_analysis_page_data" updated.';


-- Function 2: Update the summary function (used by old deep dive).
CREATE OR REPLACE FUNCTION public.get_stock_analysis_summary()
RETURNS json
LANGUAGE sql STABLE AS $$
WITH latest_date AS (
    SELECT max(forecast_date) as value FROM public.forecast_check_latest
)
SELECT json_build_object(
    'tracked_stocks_count', (SELECT count(*) FROM public.stocks WHERE is_tracked = true),
    'latest_forecast_date', (SELECT value FROM latest_date),
    'last_audit_mape', (SELECT avg(pct_error) FROM public.forecast_check_latest WHERE forecast_date = (SELECT value FROM latest_date)),
    'last_audit_hit_rate', (SELECT avg(CASE WHEN hit_range = true THEN 1 ELSE 0 END) FROM public.forecast_check_latest WHERE forecast_date = (SELECT value FROM latest_date)),
    'last_audit_hits', (SELECT count(*) FROM public.forecast_check_latest WHERE hit_range = true AND forecast_date = (SELECT value FROM latest_date)),
    'last_audit_misses', (SELECT count(*) FROM public.forecast_check_latest WHERE hit_range = false AND forecast_date = (SELECT value FROM latest_date)),
    'last_audit_evaluated_count', (SELECT count(*) FROM public.forecast_check_latest WHERE forecast_date = (SELECT value FROM latest_date))
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_stock_analysis_summary" updated.';


-- Function 3: Update the deep dive function.
CREATE OR REPLACE FUNCTION public.get_stock_deep_dive(p_symbol TEXT)
RETURNS json
LANGUAGE sql
STABLE
AS $$
SELECT json_build_object(
    'details', (SELECT row_to_json(s) FROM public.stocks s WHERE s.symbol = p_symbol),
    'historical_data', (
        SELECT COALESCE(json_agg(h ORDER BY h.date DESC), '[]'::json)
        FROM (SELECT * FROM public.historical_data WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 90) h
    ),
    'technical_indicators', (
        SELECT COALESCE(json_agg(ti ORDER BY ti.date DESC), '[]'::json)
        FROM (SELECT * FROM public.technical_indicators WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 90) ti
    ),
    'candle_patterns', (
         SELECT COALESCE(json_agg(cp ORDER BY cp.date DESC), '[]'::json)
        FROM (SELECT * FROM public.candle_patterns WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 30) cp
    ),
    'latest_forecast', (
        SELECT row_to_json(f) FROM public.forecasts f WHERE f.stock_symbol = p_symbol ORDER BY f.forecast_date DESC LIMIT 1
    ),
    'forecast_history', (
        SELECT COALESCE(json_agg(fch_sub), '[]'::json)
        FROM (
            SELECT
                -- The type ForecastHistory expects a run_id, which no longer exists.
                -- We'll return 0 as a placeholder since this function is not actively used.
                0 as run_id,
                fch.stock_symbol,
                fch.forecast_date,
                fch.predicted_price,
                fch.actual_close,
                fch.hit_range
            FROM
                public.forecast_check_history fch
            WHERE
                fch.stock_symbol = p_symbol
            ORDER BY
                fch.forecast_date DESC
            LIMIT 10
        ) fch_sub
    )
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_stock_deep_dive" updated.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Drop Old Audit Tables
-- #
-- # Purpose: This script removes the old, now-deprecated tables related to
-- # forecast auditing (`audit_runs`, `audit_forecast_metrics`). These have been
-- # replaced by the new `forecast_check_*` tables. The `Forcast_Result` table
-- # will be kept as requested.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Drop the old audit tables. Using CASCADE ensures that any dependent objects
-- (like indexes or foreign key constraints) are also removed.
DROP TABLE IF EXISTS public.audit_forecast_metrics CASCADE;
RAISE NOTICE 'SUCCESS: Table "audit_forecast_metrics" dropped.';

DROP TABLE IF EXISTS public.audit_runs CASCADE;
RAISE NOTICE 'SUCCESS: Table "audit_runs" dropped.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Sector to Stocks Table
-- #
-- # Purpose: This script adds a `sector` column to the `stocks` table to
-- # enable performance analysis by market sector.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Add the 'sector' column if it doesn't exist.
DO $$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM information_schema.columns WHERE table_schema = 'public' AND table_name='stocks' AND column_name='sector') THEN
       ALTER TABLE public.stocks ADD COLUMN sector TEXT;
       RAISE NOTICE 'SUCCESS: Column "sector" added to "stocks" table.';
    ELSE
       RAISE NOTICE 'INFO: Column "sector" already exists in "stocks" table.';
    END IF;
END $$;
COMMENT ON COLUMN public.stocks.sector IS 'The market sector the stock belongs to (e.g., Technology, Healthcare).';


-- Step 2: Populate with some sample data for visualization purposes.
-- This part of the script is safe to re-run.
UPDATE public.stocks SET sector = 'Technology' WHERE symbol IN ('AAPL', 'MSFT', 'GOOGL', 'NVDA', 'META', 'AMD', 'INTC', 'CRM');
UPDATE public.stocks SET sector = 'Consumer Cyclical' WHERE symbol IN ('AMZN', 'TSLA', 'NKE', 'MCD');
UPDATE public.stocks SET sector = 'Healthcare' WHERE symbol IN ('JNJ', 'PFE', 'LLY', 'UNH');
UPDATE public.stocks SET sector = 'Financial Services' WHERE symbol IN ('JPM', 'BAC', 'WFC', 'V', 'MA');
UPDATE public.stocks SET sector = 'Energy' WHERE symbol IN ('XOM', 'CVX');
UPDATE public.stocks SET sector = 'Communication Services' WHERE symbol IN ('GOOG', 'T', 'VZ');


-- Step 3: Set a default for any other stocks to avoid null values in charts.
UPDATE public.stocks SET sector = 'Miscellaneous' WHERE sector IS NULL;
RAISE NOTICE 'SUCCESS: Populated sample sector data for stocks.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Revert Add Sector to Stocks Table
-- #
-- # Purpose: This script removes the `sector` column from the `stocks` table,
-- # reverting a previous change as requested.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Drop the 'sector' column if it exists.
DO $$
BEGIN
    IF EXISTS(SELECT 1 FROM information_schema.columns WHERE table_schema = 'public' AND table_name='stocks' AND column_name='sector') THEN
       ALTER TABLE public.stocks DROP COLUMN sector;
       RAISE NOTICE 'SUCCESS: Column "sector" dropped from "stocks" table.';
    ELSE
       RAISE NOTICE 'INFO: Column "sector" does not exist in "stocks" table. No action taken.';
    END IF;
END $$;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Enhance Daily Stock Analysis Function
-- #
-- # Purpose: This script replaces the existing function for the "Last Work Day"
-- # page with a much more powerful version that returns a single, consolidated
-- # JSON object with all data needed for the new dashboard design.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.get_daily_stock_analysis_page_data()
RETURNS json
LANGUAGE sql STABLE AS $$
WITH latest_date AS (
    -- Use the definitive source for the last work day's data
    SELECT max(forecast_date) as value FROM public.forecast_check_latest
),
daily_results AS (
    -- Pre-calculate all necessary daily metrics in one place
    SELECT
        fcl.stock_symbol,
        s.name as stock_name,
        fcl.forecast_date,
        fcl.predicted_price,
        fcl.predicted_lo,
        fcl.predicted_hi,
        fcl.actual_low,
        fcl.actual_high,
        fcl.actual_close,
        fcl.hit_range,
        -- Ensure pct_error is not null and handle division by zero
        CASE
            WHEN fcl.actual_close IS NOT NULL AND fcl.actual_close > 0 THEN abs(fcl.predicted_price - fcl.actual_close) / fcl.actual_close
            ELSE 0
        END as pct_error
    FROM public.forecast_check_latest fcl
    JOIN public.stocks s ON fcl.stock_symbol = s.symbol
    WHERE fcl.forecast_date = (SELECT value FROM latest_date)
)
SELECT json_build_object(
    'summary', (
        SELECT json_build_object(
            'forecast_date', (SELECT value FROM latest_date),
            'total_forecasts', count(*),
            'hits', count(*) FILTER (WHERE hit_range = true),
            'misses', count(*) FILTER (WHERE hit_range = false),
            'hit_rate', avg(CASE WHEN hit_range = true THEN 1 ELSE 0 END)
        )
        FROM daily_results
    ),
    'results', (
        SELECT COALESCE(json_agg(res ORDER BY res.stock_symbol), '[]'::json)
        FROM (
            SELECT
                dr.stock_symbol,
                dr.stock_name,
                dr.predicted_price::real,
                dr.predicted_lo::real,
                dr.predicted_hi::real,
                dr.actual_close::real,
                dr.actual_low::real,
                dr.actual_high::real,
                dr.hit_range as is_hit,
                dr.pct_error::real
            FROM daily_results dr
        ) res
    ),
    'highlights', (
        SELECT json_build_object(
            'top_hits', (
                SELECT COALESCE(json_agg(hits ORDER BY hits.pct_error ASC), '[]'::json)
                FROM (
                    SELECT stock_symbol, stock_name, pct_error
                    FROM daily_results
                    WHERE hit_range = true
                    ORDER BY pct_error ASC
                    LIMIT 5
                ) hits
            ),
            'top_misses', (
                SELECT COALESCE(json_agg(misses ORDER BY misses.pct_error DESC), '[]'::json)
                FROM (
                    SELECT stock_symbol, stock_name, pct_error
                    FROM daily_results
                    WHERE hit_range = false
                    ORDER BY pct_error DESC
                    LIMIT 5
                ) misses
            )
        )
    ),
    'error_distribution', (
         SELECT COALESCE(json_agg(ed ORDER BY ed.min_error), '[]'::json)
         FROM (
            SELECT
                '0-1%' as bucket, 0 as min_error, count(*)
                FROM daily_results WHERE pct_error <= 0.01
            UNION ALL
            SELECT
                '1-3%' as bucket, 1 as min_error, count(*)
                FROM daily_results WHERE pct_error > 0.01 AND pct_error <= 0.03
            UNION ALL
            SELECT
                '3-5%' as bucket, 2 as min_error, count(*)
                FROM daily_results WHERE pct_error > 0.03 AND pct_error <= 0.05
            UNION ALL
            SELECT
                '>5%' as bucket, 3 as min_error, count(*)
                FROM daily_results WHERE pct_error > 0.05
         ) ed
    )
);
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_daily_stock_analysis_page_data" has been enhanced with highlights and breakdowns.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translations for New Stock Analysis Visuals
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # components on the redesigned Stock Analysis page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'todays_top_performers', 'Today''s Top Performers (Hits)'),
('ar', 'todays_top_performers', 'أفضل أداء اليوم (توقعات ناجحة)'),
('en', 'todays_biggest_deviations', 'Today''s Biggest Deviations (Misses)'),
('ar', 'todays_biggest_deviations', 'أكبر انحرافات اليوم (توقعات خاطئة)'),
('en', 'prediction_error_distribution', 'Prediction Error Distribution'),
('ar', 'prediction_error_distribution', 'توزيع خطأ التوقعات'),
('en', 'pct_error', '% Error'),
('ar', 'pct_error', 'نسبة الخطأ %'),
('en', 'no_hits_today', 'No successful predictions today.'),
('ar', 'no_hits_today', 'لا توجد توقعات ناجحة اليوم.'),
('en', 'no_misses_today', 'No incorrect predictions today.'),
('ar', 'no_misses_today', 'لا توجد توقعات خاطئة اليوم.'),
('en', 'actual_close', 'Actual Close'),
('ar', 'actual_close', 'الإغلاق الفعلي'),
('en', 'detailed_results', 'Detailed Results'),
('ar', 'detailed_results', 'النتائج التفصيلية')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Date Display Translations for Stock Analysis
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # prominent date display component on the Stock Analysis page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'data_for_date', 'Displaying analysis for:'),
('ar', 'data_for_date', 'عرض التحليل ليوم:')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add/Update "Remember Me" Translation
-- #
-- # Purpose: This script ensures the translation key for the "Remember Me"
-- # checkbox is present and correct in the database, fixing a UI issue where
-- # the key was displayed instead of the translated text.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times and
-- will update existing keys if necessary.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'remember_me', 'Remember me'),
('ar', 'remember_me', 'تذكرني')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The "remember_me" translation has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Header Login Form Translations
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # Facebook-style login form in the main header.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'email_or_phone', 'Email or phone'),
('ar', 'email_or_phone', 'البريد الإلكتروني أو الهاتف'),
('en', 'forgotten_account', 'Forgotten account?'),
('ar', 'forgotten_account', 'هل نسيت الحساب؟')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix "add_new_user" Translation
-- #
-- # Purpose: This script specifically fixes an issue where the "Add New User"
-- # button was not translated into Arabic. It ensures the correct translation
-- # key is present in the database.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translation for 'add_new_user' in Arabic.
-- The ON CONFLICT clause makes this script safe to re-run and ensures
-- the value is updated if it already exists.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'add_new_user', 'Add New User'),
('ar', 'add_new_user', 'إضافة مستخدم جديد')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The "add_new_user" translation has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Stock Management UI Translations
-- #
-- # Purpose: This script adds all the translation keys needed for the new
-- # Stock Management page and its associated components.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'stock_management', 'Stock Management'),
('ar', 'stock_management', 'إدارة الأسهم'),
('en', 'add_new_stock', 'Add New Stock'),
('ar', 'add_new_stock', 'إضافة سهم جديد'),
('en', 'edit_stock', 'Edit Stock'),
('ar', 'edit_stock', 'تعديل السهم'),
('en', 'stock_symbol', 'Symbol'),
('ar', 'stock_symbol', 'الرمز'),
('en', 'stock_name', 'Name'),
('ar', 'stock_name', 'الاسم'),
('en', 'tracking_status', 'Tracking Status'),
('ar', 'tracking_status', 'حالة التتبع'),
('en', 'tracked', 'Tracked'),
('ar', 'tracked', 'يتم تتبعه'),
('en', 'not_tracked', 'Not Tracked'),
('ar', 'not_tracked', 'لا يتم تتبعه'),
('en', 'stock_saved_successfully', 'Stock saved successfully!'),
('ar', 'stock_saved_successfully', 'تم حفظ السهم بنجاح!'),
('en', 'stock_save_failed', 'Failed to save stock. The symbol may already exist.'),
('ar', 'stock_save_failed', 'فشل حفظ السهم. قد يكون الرمز موجوداً بالفعل.'),
('en', 'search_stock_symbol_or_name', 'Search by symbol or name...'),
('ar', 'search_stock_symbol_or_name', 'ابحث بالرمز أو الاسم...')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Stock Filtering & Pagination UI Translations
-- #
-- # Purpose: This script adds all the translation keys needed for the new
-- # filtering, sorting, and pagination controls on the Stock Management page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'filter_by_status', 'Filter by Status'),
('ar', 'filter_by_status', 'تصفية حسب الحالة'),
('en', 'all', 'All'),
('ar', 'all', 'الكل'),
('en', 'page_x_of_y', 'Page {currentPage} of {totalPages}'),
('ar', 'page_x_of_y', 'صفحة {currentPage} من {totalPages}'),
('en', 'previous', 'Previous'),
('ar', 'previous', 'السابق'),
('en', 'next', 'Next'),
('ar', 'next', 'التالي'),
('en', 'no_results_found', 'No stocks match your criteria.'),
('ar', 'no_results_found', 'لم يتم العثور على أسهم تطابق معاييرك.')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add "Site Management" Translation
-- #
-- # Purpose: This script adds the UI translation key required for the new
-- # "Site Management" dropdown menu in the header.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'site_management', 'Site Management'),
('ar', 'site_management', 'إدارة الموقع')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translation Management System
-- #
-- # Purpose: This script introduces the backend infrastructure for the new
-- # Translation Management page.
-- #
-- # It performs four key actions:
-- # 1. Creates a new permission `manage:translations`.
-- # 2. Assigns this permission to the 'Admin' role.
-- # 3. Updates the RLS policy on the `translations` table to use this
-- #    more specific permission for write access.
-- # 4. Creates an efficient RPC function `get_all_translations_for_management`
-- #    to fetch data for the UI.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Add the new permission to the permissions table.
INSERT INTO public.permissions (action, description)
VALUES ('manage:translations', 'Can edit UI translation values for all languages.')
ON CONFLICT (action) DO UPDATE SET description = EXCLUDED.description;
RAISE NOTICE 'SUCCESS: Permission "manage:translations" added or updated.';

-- Step 2: Assign the new permission to the Admin role.
DO $$
DECLARE
    admin_role_id UUID;
    manage_translations_perm_id UUID;
BEGIN
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    SELECT id INTO manage_translations_perm_id FROM public.permissions WHERE action = 'manage:translations';

    IF admin_role_id IS NOT NULL AND manage_translations_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, manage_translations_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
        
        IF FOUND THEN
             RAISE NOTICE 'SUCCESS: Assigned "manage:translations" permission to Admin role.';
        ELSE
             RAISE NOTICE 'INFO: Admin role already has "manage:translations" permission.';
        END IF;
    END IF;
END $$;

-- Step 3: Update RLS policies for the `translations` table for better security.
-- The old policy allowed `manage:settings` to edit translations. This is more specific.
DROP POLICY IF EXISTS "Allow managers full access" ON "public"."translations";
DROP POLICY IF EXISTS "Allow settings managers full access on translations" ON "public"."translations";
CREATE POLICY "Allow translation managers full access" ON "public"."translations"
FOR ALL USING (public.has_permission('manage:translations'));
RAISE NOTICE 'SUCCESS: RLS policy for "translations" table updated to use new permission.';

-- Step 4: Create the RPC function to fetch pivoted translation data.
CREATE OR REPLACE FUNCTION public.get_all_translations_for_management()
RETURNS TABLE (
    key text,
    value_en text,
    value_ar text
)
LANGUAGE sql STABLE AS $$
SELECT
    t.key,
    MAX(CASE WHEN t.lang_id = 'en' THEN t.value ELSE NULL END) as value_en,
    MAX(CASE WHEN t.lang_id = 'ar' THEN t.value ELSE NULL END) as value_ar
FROM
    public.translations t
WHERE
    t.lang_id IN ('en', 'ar')
GROUP BY
    t.key
ORDER BY
    t.key;
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_all_translations_for_management" created or updated.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translation Management UI Translations
-- #
-- # Purpose: This script adds all the translation keys needed for the new
-- # Translation Management page and updates related permission descriptions.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'translation_management', 'Translation Management'),
('ar', 'translation_management', 'إدارة الترجمات'),
('en', 'perm_manage_translations', 'Manage Translations'),
('ar', 'perm_manage_translations', 'إدارة الترجمات'),
('en', 'perm_manage_translations_desc', 'Can edit UI translation values for all languages.'),
('ar', 'perm_manage_translations_desc', 'يمكنه تعديل قيم ترجمة واجهة المستخدم لجميع اللغات.'),
('en', 'translation_key', 'Key'),
('ar', 'translation_key', 'المفتاح'),
('en', 'english_translation', 'English Translation'),
('ar', 'english_translation', 'الترجمة الإنجليزية'),
('en', 'arabic_translation', 'Arabic Translation'),
('ar', 'arabic_translation', 'الترجمة العربية'),
('en', 'search_by_key_or_value', 'Search by key or value...'),
('ar', 'search_by_key_or_value', 'ابحث بالمفتاح أو القيمة...'),
('en', 'translation_saved_successfully', 'Translation saved successfully!'),
('ar', 'translation_saved_successfully', 'تم حفظ الترجمة بنجاح!'),
('en', 'translation_save_failed', 'Failed to save translation.'),
('ar', 'translation_save_failed', 'فشل حفظ الترجمة.'),
-- Update manage:settings description as it no longer handles translations
('en', 'perm_manage_settings_desc', 'Can update site-wide application settings like logo and landing page content.'),
('ar', 'perm_manage_settings_desc', 'يمكنه تحديث إعدادات التطبيق على مستوى الموقع مثل الشعار ومحتوى الصفحة الرئيسية.')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Auto-Confirm All Users & Add Signup Translations
-- #
-- # Purpose: This script implements the user's request to make registration
-- # faster and easier by removing the email confirmation step.
-- #
-- # It performs three key actions:
-- # 1. AUTO-CONFIRMATION: It updates the `handle_new_user` trigger to
-- #    automatically confirm the email of *every* new user upon signup.
-- # 2. UPDATE NOTIFICATION: It changes the 'signup_success' translation to
-- #    inform users they can log in immediately.
-- # 3. ADD UI TRANSLATIONS: It adds new keys for the "Confirm Password" field.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Part 1: Update the user creation trigger to auto-confirm all new users.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
  user_count integer;
  target_role_id uuid;
BEGIN
  -- Create the profile entry for the new user, including their full name.
  INSERT INTO public.profiles (id, full_name, email)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.email);

  -- Check the total number of users to determine if this is the first one.
  SELECT count(*) INTO user_count FROM auth.users;

  -- Logic for the first user vs. subsequent users for role assignment
  IF user_count = 1 THEN
    -- FIRST USER EVER: Make them an Admin.
    RAISE NOTICE 'First user signing up. Assigning Admin role.';
    SELECT id INTO target_role_id FROM public.roles WHERE name = 'Admin';
  ELSE
    -- SUBSEQUENT USERS: Assign the default 'User' role.
    RAISE NOTICE 'New user signing up. Assigning default User role.';
    SELECT id INTO target_role_id FROM public.roles WHERE name = 'User';
  END IF;

  -- Assign the determined role to the user's profile
  IF target_role_id IS NOT NULL THEN
    UPDATE public.profiles
    SET role_id = target_role_id
    WHERE id = new.id;
  ELSE
     RAISE WARNING 'Could not find a suitable role (Admin or User) to assign to new user %.', new.id;
  END IF;
  
  -- ALWAYS auto-confirm the user's email so they can log in immediately.
  -- This is a privileged operation, allowed because the function is SECURITY DEFINER.
  UPDATE auth.users
  SET email_confirmed_at = now()
  WHERE id = new.id;
  RAISE NOTICE 'Auto-confirmed email for new user %.', new.id;

  RETURN new;
END;
$$;
RAISE NOTICE 'SUCCESS: The `handle_new_user` trigger has been updated to auto-confirm ALL new users.';


-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Part 2: Update the signup success message.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'signup_success', 'Account created successfully! You can now log in.'),
('ar', 'signup_success', 'تم إنشاء الحساب بنجاح! يمكنك الآن تسجيل الدخول.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;
RAISE NOTICE 'SUCCESS: The "signup_success" translation has been updated for auto-confirmation.';

-- Part 3: Add new translations for the updated sign-up modal.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'passwords_do_not_match', 'Passwords do not match. Please try again.'),
('ar', 'passwords_do_not_match', 'كلمتا المرور غير متطابقتين. يرجى المحاولة مرة أخرى.'),
('en', 'confirm_password', 'Confirm Password'),
('ar', 'confirm_password', 'تأكيد كلمة المرور'),
('en', 'signup_failed', 'Sign up failed. Please check your information and try again.'),
('ar', 'signup_failed', 'فشل التسجيل. يرجى التحقق من معلوماتك والمحاولة مرة أخرى.')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;
RAISE NOTICE 'SUCCESS: Added translations for sign-up modal confirmation.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Header Login Translation
-- #
-- # Purpose: This script ensures the translation for the header login form's
-- # email field is correctly stored in the database, fixing an issue where
-- # the translation key was displayed instead of the translated text.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- This script ensures the Arabic translation for 'email_or_phone' exists.
-- It fixes an issue where the translation key was displayed instead of the text.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'email_or_phone', 'Email or phone'),
('ar', 'email_or_phone', 'البريد الإلكتروني')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The translation for "email_or_phone" has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Revert Header Login Translation to be more accurate
-- #
-- # Purpose: This script corrects the Arabic translation for the 'email_or_phone'
-- # key to its more accurate, longer form "البريد الإلكتروني أو الهاتف". This
-- # resolves a quality issue where the key and its value were inconsistent.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- This script updates the Arabic translation for 'email_or_phone' to be more
-- accurate and descriptive, resolving an inconsistency.
INSERT INTO public.translations (lang_id, key, value) VALUES
('ar', 'email_or_phone', 'البريد الإلكتروني أو الهاتف')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The translation for "email_or_phone" has been corrected.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Strengthen All Management RLS Policies
-- #
-- # Purpose: This script provides a definitive fix for issues where "Save"
-- # buttons were failing silently. The previous general-purpose security rules
-- # were not robust enough for INSERT/UPDATE/DELETE operations.
-- #
-- # This script replaces ambiguous policies with explicit, robust policies for
-- # all managed tables. This ensures that users with the correct permissions
-- # can reliably save, update, and delete data across the entire site.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- 1. Strengthen RLS for `global_announcements` (Fixes Announcements save button)
RAISE NOTICE 'Updating RLS for global_announcements...';
DROP POLICY IF EXISTS "Allow managers full access" ON public.global_announcements;

-- Public read access is handled by a separate policy. We need explicit write access for managers.
-- A SELECT policy for managers is also needed so they can see all records, not just active ones.
-- The following policies ensure clean state and correct permissions.
DROP POLICY IF EXISTS "Allow managers to SELECT all announcements" ON public.global_announcements;
CREATE POLICY "Allow managers to SELECT all announcements" ON public.global_announcements FOR SELECT USING (public.has_permission('manage:announcements'));

DROP POLICY IF EXISTS "Allow managers to INSERT announcements" ON public.global_announcements;
CREATE POLICY "Allow managers to INSERT announcements" ON public.global_announcements FOR INSERT WITH CHECK (public.has_permission('manage:announcements'));

DROP POLICY IF EXISTS "Allow managers to UPDATE announcements" ON public.global_announcements;
CREATE POLICY "Allow managers to UPDATE announcements" ON public.global_announcements FOR UPDATE USING (public.has_permission('manage:announcements'));

DROP POLICY IF EXISTS "Allow managers to DELETE announcements" ON public.global_announcements;
CREATE POLICY "Allow managers to DELETE announcements" ON public.global_announcements FOR DELETE USING (public.has_permission('manage:announcements'));


-- 2. Strengthen RLS for `profiles` (Fixes User Management save button)
RAISE NOTICE 'Updating RLS for profiles...';
-- The previous "FOR ALL" policy was ambiguous. Replace it with explicit UPDATE.
DROP POLICY IF EXISTS "Allow managers full access on profiles" ON public.profiles;
DROP POLICY IF EXISTS "Allow managers to UPDATE profiles" ON public.profiles;
CREATE POLICY "Allow managers to UPDATE profiles" ON public.profiles FOR UPDATE USING (public.has_permission('manage:users'));


-- 3. Strengthen RLS for `role_permissions` (Fixes Role Management save button)
RAISE NOTICE 'Updating RLS for role_permissions...';
DROP POLICY IF EXISTS "Allow managers full access" ON public.role_permissions;
DROP POLICY IF EXISTS "Allow role managers full access on role_permissions" ON public.role_permissions;
-- The `FOR ALL` policy is ambiguous. Replace with explicit INSERT/DELETE which is what the UI uses.
DROP POLICY IF EXISTS "Allow managers to INSERT role_permissions" ON public.role_permissions;
CREATE POLICY "Allow managers to INSERT role_permissions" ON public.role_permissions FOR INSERT WITH CHECK (public.has_permission('manage:roles'));

DROP POLICY IF EXISTS "Allow managers to DELETE role_permissions" ON public.role_permissions;
CREATE POLICY "Allow managers to DELETE role_permissions" ON public.role_permissions FOR DELETE USING (public.has_permission('manage:roles'));


-- 4. Strengthen RLS for `translations` (Fixes Translation Management save button)
RAISE NOTICE 'Updating RLS for translations...';
DROP POLICY IF EXISTS "Allow translation managers full access" ON public.translations;
-- Public read is handled. We need explicit write access for managers (UPSERT).
DROP POLICY IF EXISTS "Allow managers to INSERT translations" ON public.translations;
CREATE POLICY "Allow managers to INSERT translations" ON public.translations FOR INSERT WITH CHECK (public.has_permission('manage:translations'));

DROP POLICY IF EXISTS "Allow managers to UPDATE translations" ON public.translations;
CREATE POLICY "Allow managers to UPDATE translations" ON public.translations FOR UPDATE USING (public.has_permission('manage:translations'));


-- 5. Strengthen RLS for `app_settings` (Fixes Dashboard Settings save button)
RAISE NOTICE 'Updating RLS for app_settings...';
DROP POLICY IF EXISTS "Allow managers full access" ON public.app_settings;
DROP POLICY IF EXISTS "Allow settings managers full access on app_settings" ON public.app_settings;
-- Public read is handled. We need explicit write access for managers (UPSERT).
DROP POLICY IF EXISTS "Allow managers to INSERT app_settings" ON public.app_settings;
CREATE POLICY "Allow managers to INSERT app_settings" ON public.app_settings FOR INSERT WITH CHECK (public.has_permission('manage:settings'));

DROP POLICY IF EXISTS "Allow managers to UPDATE app_settings" ON public.app_settings;
CREATE POLICY "Allow managers to UPDATE app_settings" ON public.app_settings FOR UPDATE USING (public.has_permission('manage:settings'));


-- 6. Strengthen RLS for `stocks` (Fixes Stock Management save button)
RAISE NOTICE 'Updating RLS for stocks...';
DROP POLICY IF EXISTS "Allow managers full access on stocks" ON public.stocks;
-- Public read is handled. We need explicit write access for managers (UPSERT).
DROP POLICY IF EXISTS "Allow managers to INSERT stocks" ON public.stocks;
CREATE POLICY "Allow managers to INSERT stocks" ON public.stocks FOR INSERT WITH CHECK (public.has_permission('manage:stocks'));

DROP POLICY IF EXISTS "Allow managers to UPDATE stocks" ON public.stocks;
CREATE POLICY "Allow managers to UPDATE stocks" ON public.stocks FOR UPDATE USING (public.has_permission('manage:stocks'));


RAISE NOTICE 'SUCCESS: All management RLS policies have been strengthened.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Announcements RLS Policy for Managers
-- #
-- # Purpose: This script fixes a critical bug where users with management
-- # permissions could not see any announcements on the management page.
-- # A previous migration removed the general-purpose "full access" policy
-- # but failed to add back an explicit SELECT policy for managers.
-- #
-- # This script adds the missing SELECT policy, allowing managers to view all
-- # announcements (active, scheduled, expired, etc.) as intended.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Add a specific SELECT policy for users with the 'manage:announcements' permission.
-- This works in conjunction with the existing public read policy.
-- Managers will match this policy and see all announcements.
-- The public will not match this and will fall back to the public policy, seeing only active ones.
DROP POLICY IF EXISTS "Allow managers to SELECT all announcements" ON public.global_announcements;
CREATE POLICY "Allow managers to SELECT all announcements"
    ON public.global_announcements FOR SELECT
    USING (public.has_permission('manage:announcements'));

RAISE NOTICE 'SUCCESS: Added missing SELECT RLS policy for announcement managers.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Create Daily Checklist View and Function
-- #
-- # Purpose: This script implements the user's request by creating a new
-- # SQL view (`vw_Last_dayCheckList`) and an RPC function to fetch data from it.
-- # This provides the backend for the redesigned "Last Work Day" page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the SQL View as provided by the user.
CREATE OR REPLACE VIEW public.vw_Last_dayCheckList AS
SELECT
  fr.stock_symbol,
  fr.stock_name,
  s.last_updated,
  s.price,
  fr.actual_low,
  fr.actual_high,
  fr.predicted_lo,
  fr.predicted_hi,
  fr.is_hit
FROM public."Forcast_Result" AS fr
JOIN public.stocks AS s
  ON s.symbol = fr.stock_symbol
ORDER BY fr.stock_symbol;

--RAISE NOTICE 'SUCCESS: View "vw_Last_dayCheckList" created or updated.';


-- Step 2: Apply Row Level Security to the new view.
-- Since the underlying tables are public, a simple public read policy is sufficient.
ALTER VIEW public.vw_Last_dayCheckList OWNER TO postgres;
-- RLS policies are not directly applicable to views in the same way as tables,
-- access is controlled by the underlying tables' policies. We will create
-- an RPC function to ensure controlled access.


-- Step 3: Create an RPC function to fetch data from the view.
-- This is the recommended way to expose data to the client-side.
CREATE OR REPLACE FUNCTION public.get_daily_checklist()
RETURNS SETOF public.vw_Last_dayCheckList
LANGUAGE sql STABLE
AS $$
  SELECT * FROM public.vw_Last_dayCheckList;
$$;

--RAISE NOTICE 'SUCCESS: RPC function "get_daily_checklist" created or updated.';

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Daily Checklist Translations
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # table on the redesigned "Last Work Day" page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'last_updated_at', 'Last Updated'),
('ar', 'last_updated_at', 'آخر تحديث')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add V2 Daily Checklist Translations
-- #
-- # Purpose: This script adds all the UI translation keys required for the new
-- # table headers and filter controls on the redesigned "Last Work Day" page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Column Headers for Checklist Table
('en', 'last_price', 'Last Price'),
('ar', 'last_price', 'آخر سعر'),
('en', 'actual_range', 'Actual Range'),
('ar', 'actual_range', 'النطاق الفعلي'),
('en', 'predicted_range', 'Predicted Range'),
('ar', 'predicted_range', 'النطاق المتوقع'),
('en', 'forecast_result', 'Forecast Result'),
('ar', 'forecast_result', 'نتيجة التوقع'),

-- Filter Controls
('en', 'filter_by_result', 'Filter by result'),
('ar', 'filter_by_result', 'تصفية حسب النتيجة'),
('en', 'hits', 'Hits'),
('ar', 'hits', 'ناجحة'),
('en', 'misses', 'Misses'),
('ar', 'misses', 'خاطئة')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Checklist Sub-Header Translations
-- #
-- # Purpose: This script adds the UI translation keys required for the
-- # sub-header columns ("Low", "High") on the "Last Work Day" page,
-- # fixing an issue where English keys were displayed in the Arabic UI.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/update the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- English (more concise for sub-headers)
('en', 'actual_low', 'Low'),
('en', 'actual_high', 'High'),
('en', 'predicted_low', 'Low'),
('en', 'predicted_high', 'High'),

-- Arabic
('ar', 'actual_low', 'الأدنى'),
('ar', 'actual_high', 'الأعلى'),
('ar', 'predicted_low', 'الأدنى'),
('ar', 'predicted_high', 'الأعلى')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add/Update "Hit" Translation
-- #
-- # Purpose: This script ensures the translation key for the word "Hit"
-- # is present and correct in the database, as requested.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times and
-- will update existing keys if necessary.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'hit', 'Hit'),
('ar', 'hit', 'أصاب')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The "hit" translation has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add/Update "Miss" Translation
-- #
-- # Purpose: This script ensures the translation key for the word "Miss"
-- # (for an incorrect forecast) is present and correct in the database.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times and
-- will update existing keys if necessary.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'miss', 'Miss'),
('ar', 'miss', 'أخطأ')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The "miss" translation has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add "Last Close Price" Translation
-- #
-- # Purpose: This script adds the UI translation key required for the new
-- # merged "Last Close Price" column on the "Last Work Day" page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/update the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'price_of_last_close', 'Last Close Price'),
('ar', 'price_of_last_close', 'سعر اخر اغلاق')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Indicators Function and Update View
-- #
-- # Purpose: This script enhances the backend for the "Last Work Day" page.
-- # It adds the forecast date to the main view and creates a new RPC function
-- # to fetch detailed technical indicators for a selected stock.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Update the view to include the forecast date.
CREATE OR REPLACE VIEW public.vw_Last_dayCheckList AS
SELECT
  fr.stock_symbol,
  fr.stock_name,
  s.last_updated,
  s.price,
  fr.actual_low,
  fr.actual_high,
  fr.predicted_lo,
  fr.predicted_hi,
  fr.is_hit,
  fr.forecast_date -- Add the forecast date to the view
FROM public."Forcast_Result" AS fr
JOIN public.stocks AS s
  ON s.symbol = fr.stock_symbol
ORDER BY fr.stock_symbol;

RAISE NOTICE 'SUCCESS: View "vw_Last_dayCheckList" updated to include forecast_date.';


-- Step 2: Create an RPC function to fetch technical indicators for a stock on a specific date.
CREATE OR REPLACE FUNCTION public.get_indicators_for_stock_date(p_symbol text, p_date date)
RETURNS SETOF public.technical_indicators
LANGUAGE sql STABLE
AS $$
  SELECT *
  FROM public.technical_indicators
  WHERE stock_symbol = p_symbol AND date = p_date
  LIMIT 1;
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_indicators_for_stock_date" created or updated.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Indicator Analysis Translations
-- #
-- # Purpose: This script adds all the new translation keys needed for the
-- # interactive technical indicator analysis panel on the "Last Work Day" page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'indicator_analysis_for', 'Indicator Analysis for {stock}'),
('ar', 'indicator_analysis_for', 'تحليل المؤشرات لسهم {stock}'),
('en', 'rsi_indicator', 'RSI (14)'),
('ar', 'rsi_indicator', 'مؤشر القوة النسبية (14)'),
('en', 'macd_indicator', 'MACD Hist.'),
('ar', 'macd_indicator', 'مؤشر الماكد'),
('en', 'sma20', 'SMA 20'),
('ar', 'sma20', 'متوسط 20 يوم'),
('en', 'sma50', 'SMA 50'),
('ar', 'sma50', 'متوسط 50 يوم'),
('en', 'bollinger_upper', 'BB Upper'),
('ar', 'bollinger_upper', 'بولينجر العلوي'),
('en', 'bollinger_lower', 'BB Lower'),
('ar', 'bollinger_lower', 'بولينجر السفلي'),
('en', 'no_indicator_data', 'No technical indicator data available for this date.'),
('ar', 'no_indicator_data', 'لا توجد بيانات مؤشرات فنية متاحة لهذا التاريخ.')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add More Indicator Translations
-- #
-- # Purpose: This script adds all the new translation keys needed for the
-- # expanded, visually rich technical indicator analysis panel.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'technical_analysis_for', 'Technical Analysis for {stock}'),
('ar', 'technical_analysis_for', 'التحليل الفني لسهم {stock}'),
('en', 'overbought', 'Overbought'),
('ar', 'overbought', 'تشبع شرائي'),
('en', 'oversold', 'Oversold'),
('ar', 'oversold', 'تشبع بيعي'),
('en', 'neutral', 'Neutral'),
('ar', 'neutral', 'محايد'),
('en', 'macd_line', 'MACD Line'),
('ar', 'macd_line', 'خط الماكد'),
('en', 'signal_line', 'Signal Line'),
('ar', 'signal_line', 'خط الإشارة'),
('en', 'histogram', 'Histogram'),
('ar', 'histogram', 'الرسم البياني'),
('en', 'trend_momentum', 'Trend & Momentum'),
('ar', 'trend_momentum', 'الاتجاه والزخم'),
('en', 'price_vs_sma', 'Price vs. SMA {period}'),
('ar', 'price_vs_sma', 'السعر مقابل متوسط {period} يوم'),
('en', 'above', 'Above'),
('ar', 'above', 'أعلى'),
('en', 'below', 'Below'),
('ar', 'below', 'أسفل'),
('en', 'bollinger_bands', 'Bollinger Bands'),
('ar', 'bollinger_bands', 'نطاقات بولينجر'),
('en', 'price_position', 'Price Position'),
('ar', 'price_position', 'موضع السعر'),
('en', 'near_upper', 'Near Upper Band'),
('ar', 'near_upper', 'قرب النطاق العلوي'),
('en', 'near_lower', 'Near Lower Band'),
('ar', 'near_lower', 'قرب النطاق السفلي'),
('en', 'in_middle', 'In the Middle'),
('ar', 'in_middle', 'في المنتصف'),
('en', 'stochastics', 'Stochastics (%K / %D)'),
('ar', 'stochastics', 'مؤشر ستوكاستيك (%K / %D)'),
('en', 'williams_r', 'Williams %R'),
('ar', 'williams_r', 'مؤشر ويليامز %R'),
('en', 'volatility', 'Volatility'),
('ar', 'volatility', 'التقلب'),
('en', 'atr14', 'ATR (14)'),
('ar', 'atr14', 'متوسط النطاق الحقيقي (14)'),
('en', 'page_x_of_y', 'Page {currentPage} of {totalPages}'),
('ar', 'page_x_of_y', 'صفحة {currentPage} من {totalPages}'),
('en', 'previous', 'Previous'),
('ar', 'previous', 'السابق'),
('en', 'next', 'Next'),
('ar', 'next', 'التالي'),
('en', 'no_results_found', 'No stocks match your criteria.'),
('ar', 'no_results_found', 'لم يتم العثور على أسهم تطابق معاييرك.')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Final Indicator Translations for Visual Redesign
-- #
-- # Purpose: This script adds all the new and updated translation keys needed
-- # for the redesigned technical indicator analysis panel to precisely match
-- # the user's screenshot.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Main Panel Title
('en', 'technical_analysis_for', 'Technical Analysis for {stock}'),
('ar', 'technical_analysis_for', 'التحليل الفني لسهم {stock}'),

-- RSI Gauge Card
('en', 'rsi_indicator_14', 'RSI (14)'),
('ar', 'rsi_indicator_14', 'مؤشر القوة النسبية (14)'),
('en', 'overbought', 'Overbought'),
('ar', 'overbought', 'تشبع شرائي'),
('en', 'oversold', 'Oversold'),
('ar', 'oversold', 'تشبع بيعي'),
('en', 'neutral', 'Neutral'),
('ar', 'neutral', 'محايد'),

-- MACD Card
('en', 'macd_indicator', 'MACD Indicator'),
('ar', 'macd_indicator', 'مؤشر الماكد'),
('en', 'macd_line', 'MACD'),
('ar', 'macd_line', 'خط الماكد'),
('en', 'signal_line', 'Signal'),
('ar', 'signal_line', 'خط الإشارة'),
('en', 'histogram', 'Hist.'),
('ar', 'histogram', 'الرسم البياني'),

-- Trend & Momentum Card
('en', 'trend_momentum', 'Trend & Momentum'),
('ar', 'trend_momentum', 'الاتجاه والزخم'),
('en', 'price_vs_sma_20', 'Price vs 20-Day SMA'),
('ar', 'price_vs_sma_20', 'السعر مقابل متوسط 20 يوم'),
('en', 'price_vs_sma_50', 'Price vs 50-Day SMA'),
('ar', 'price_vs_sma_50', 'السعر مقابل متوسط 50 يوم'),
('en', 'price_vs_sma_200', 'Price vs 200-Day SMA'),
('ar', 'price_vs_sma_200', 'السعر مقابل متوسط 200 يوم'),
('en', 'above', 'Above'),
('ar', 'above', 'أعلى'),
('en', 'below', 'Below'),
('ar', 'below', 'أسفل'),

-- Volatility Card
('en', 'volatility', 'Volatility'),
('ar', 'volatility', 'التقلب'),
('en', 'atr_14', 'Average True Range (14)'),
('ar', 'atr_14', 'متوسط النطاق الحقيقي (14)'),

-- Oscillators Card
('en', 'stochastic_indicator_kd', 'Stochastic (%K)'),
('ar', 'stochastic_indicator_kd', 'مؤشر ستوكاستيك (%K)'),
('en', 'williams_r_indicator', 'Williams %R'),
('ar', 'williams_r_indicator', 'مؤشر ويليامز R%'),

-- General
('en', 'no_indicator_data', 'No technical indicator data available for this date.'),
('ar', 'no_indicator_data', 'لا توجد بيانات مؤشرات فنية متاحة لهذا التاريخ.'),
('en', 'n_a', 'N/A'),
('ar', 'n_a', 'غ/م')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translations for New Technical Analysis Panel
-- #
-- # Purpose: This script adds all the new UI translation keys required for the
-- # completely redesigned, modern technical analysis panel.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Main Panel Title
('en', 'technical_analysis_for', 'Technical Analysis for {stock}'),
('ar', 'technical_analysis_for', 'التحليل الفني لسهم {stock}'),

-- Summary Card
('en', 'technical_summary', 'Technical Summary'),
('ar', 'technical_summary', 'الملخص الفني'),
('en', 'summary_signal', 'Summary Signal'),
('ar', 'summary_signal', 'الإشارة النهائية'),
('en', 'strong_buy', 'Strong Buy'),
('ar', 'strong_buy', 'شراء قوي'),
('en', 'buy', 'Buy'),
('ar', 'buy', 'شراء'),
('en', 'neutral', 'Neutral'),
('ar', 'neutral', 'محايد'),
('en', 'sell', 'Sell'),
('ar', 'sell', 'بيع'),
('en', 'strong_sell', 'Strong Sell'),
('ar', 'strong_sell', 'بيع قوي'),

-- Oscillators Panel
('en', 'oscillators', 'Oscillators'),
('ar', 'oscillators', 'مؤشرات التذبذب'),
('en', 'oversold_zone', 'Oversold'),
('ar', 'oversold_zone', 'تشبع بيعي'),
('en', 'overbought_zone', 'Overbought'),
('ar', 'overbought_zone', 'تشبع شرائي'),

-- Trend & Momentum Panel
('en', 'trend_momentum_indicators', 'Trend & Momentum'),
('ar', 'trend_momentum_indicators', 'مؤشرات الاتجاه والزخم'),
('en', 'moving_averages', 'Moving Averages'),
('ar', 'moving_averages', 'المتوسطات المتحركة'),
('en', 'macd_indicator', 'MACD'),
('ar', 'macd_indicator', 'مؤشر الماكد'),
('en', 'histogram', 'Histogram'),
('ar', 'histogram', 'الرسم البياني'),
('en', 'macd_line', 'MACD'),
('ar', 'macd_line', 'الماكد'),
('en', 'signal_line', 'Signal'),
('ar', 'signal_line', 'الإشارة'),

-- General
('en', 'above', 'Above'),
('ar', 'above', 'أعلى'),
('en', 'below', 'Below'),
('ar', 'below', 'أسفل'),
('en', 'no_indicator_data', 'No technical indicator data available for this date.'),
('ar', 'no_indicator_data', 'لا توجد بيانات مؤشرات فنية متاحة لهذا التاريخ.')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Remove Technical Summary Translations
-- #
-- # Purpose: This script removes the translation keys associated with the
-- # "Technical Summary" feature, which has been removed from the UI.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Delete the keys related to the removed feature.
-- 'neutral' is kept as it's used by other components.
DELETE FROM public.translations
WHERE key IN (
  'technical_summary',
  'summary_signal',
  'strong_buy',
  'buy',
  'sell',
  'strong_sell'
);

RAISE NOTICE 'SUCCESS: Removed obsolete translations for the technical summary feature.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Checklist UI Translations
-- #
-- # Purpose: This script updates several translation keys to match the new UI
-- # design for the "Last Work Day" table, including the merged "Last Close"
-- # column header and the "Correct/Incorrect" status badges.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- 1. Add/update the new key for the merged column header.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'last_close_info', 'Last Close'),
('ar', 'last_close_info', 'آخر إغلاق')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- 2. Delete the old, now-redundant 'price_of_last_close' key.
DELETE FROM public.translations WHERE key = 'price_of_last_close';

-- 3. Update the translations for 'hit' and 'miss' for better clarity.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'hit', 'Correct'),
('ar', 'hit', 'صحيح'),
('en', 'miss', 'Incorrect'),
('ar', 'miss', 'خطأ')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Checklist UI translations have been updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Editable Description for Stock Analysis Page
-- #
-- # Purpose: This script adds the backend infrastructure to allow an admin
-- # to set a custom description for the "Last Work Day" page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.app_settings DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- 1. Add new keys to app_settings for the description content.
INSERT INTO public.app_settings (key, value) VALUES
('stock_analysis_page_description_en', 'This table shows the daily forecast results for tracked stocks. Click on any row to view a detailed technical analysis.'),
('stock_analysis_page_description_ar', 'يعرض هذا الجدول نتائج التوقعات اليومية للأسهم المتعقبة. انقر على أي صف لعرض تحليل فني مفصل.')
ON CONFLICT (key) 
DO UPDATE SET value = EXCLUDED.value;

-- 2. Add new translation keys for the UI labels in the dashboard settings.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'stock_analysis_page_settings', 'Stock Analysis Page Settings'),
('ar', 'stock_analysis_page_settings', 'إعدادات صفحة تحليل الأسهم'),
('en', 'stock_analysis_page_desc_en', 'Page Description (English)'),
('ar', 'stock_analysis_page_desc_en', 'وصف الصفحة (انجليزي)'),
('en', 'stock_analysis_page_desc_ar', 'Page Description (Arabic)'),
('ar', 'stock_analysis_page_desc_ar', 'وصف الصفحة (عربي)')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Added settings and translations for stock analysis page description.';

-- Re-enable RLS
ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add More Specific Sign-Up Error Translations
-- #
-- # Purpose: This script adds a new translation key to provide a more
-- # specific error message when a user tries to sign up with an email that
-- # is already registered. This improves the user experience during registration.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times and
-- will update existing keys if necessary.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'user_already_registered', 'A user with this email address already exists.'),
('ar', 'user_already_registered', 'يوجد مستخدم مسجل بهذا البريد الإلكتروني بالفعل.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The "user_already_registered" translation has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix User Management RLS Policy
-- #
-- # Purpose: This script fixes a critical bug where users with the 'manage:users'
-- # permission could not see the full list of users on the management page.
-- # A previous migration inadvertently removed the SELECT policy for managers.
-- # This script restores it, ensuring admins can view all profiles as intended.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- This script fixes a critical bug where users with 'manage:users' permission
-- could not see the full list of users. A previous migration (073)
-- inadvertently removed the SELECT policy for managers. This script restores it.

-- Drop any potentially conflicting old policies to ensure a clean slate.
DROP POLICY IF EXISTS "Allow managers read access on profiles" ON "public"."profiles";
DROP POLICY IF EXISTS "Allow managers full access on profiles" ON "public"."profiles";

-- Create a new, explicit SELECT policy for managers.
-- This allows them to view all user profiles, fixing the empty list issue.
CREATE POLICY "Allow managers to SELECT all profiles"
ON public.profiles FOR SELECT
USING (public.has_permission('manage:users'));

RAISE NOTICE 'SUCCESS: Restored SELECT permission for user managers on the profiles table.';

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Correct Default User Role Permissions
-- #
-- # Purpose: This script fixes the default permissions for the standard 'User'
-- # role to align with the principle that the dashboard is for admins only.
-- #
-- # It performs two key actions:
-- # 1. It REMOVES the 'view:dashboard' permission from the 'User' role.
-- # 2. It GRANTS the 'view:stock_analysis' permission to the 'User' role,
-- #    making it the default accessible feature for standard users.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

DO $$
DECLARE
    user_role_id UUID;
    view_dashboard_perm_id UUID;
    view_analysis_perm_id UUID;
BEGIN
    -- Get the IDs for the 'User' role and the relevant permissions.
    SELECT id INTO user_role_id FROM public.roles WHERE name = 'User';
    SELECT id INTO view_dashboard_perm_id FROM public.permissions WHERE action = 'view:dashboard';
    SELECT id INTO view_analysis_perm_id FROM public.permissions WHERE action = 'view:stock_analysis';

    -- Ensure all required entities were found before proceeding.
    IF user_role_id IS NULL OR view_dashboard_perm_id IS NULL OR view_analysis_perm_id IS NULL THEN
        RAISE WARNING 'Could not find "User" role or required permissions. Skipping permission update.';
        RETURN;
    END IF;

    -- 1. Remove the incorrect 'view:dashboard' permission from the 'User' role.
    DELETE FROM public.role_permissions
    WHERE role_id = user_role_id AND permission_id = view_dashboard_perm_id;
    
    IF FOUND THEN
    ELSE
    END IF;

    -- 2. Add the correct 'view:stock_analysis' permission to the 'User' role.
    INSERT INTO public.role_permissions (role_id, permission_id)
    VALUES (user_role_id, view_analysis_perm_id)
    ON CONFLICT (role_id, permission_id) DO NOTHING;

    IF FOUND THEN
        RAISE NOTICE 'SUCCESS: Assigned "view:stock_analysis" permission to the "User" role.';
    ELSE
        RAISE NOTICE 'INFO: "User" role already had "view:stock_analysis" permission. No action taken.';
    END IF;

END $$;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translations for Stock Analysis Stats
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # statistics cards on the "Last Work Day" page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'total_forecasts', 'Total Forecasts'),
('ar', 'total_forecasts', 'إجمالي التوقعات'),
('en', 'correct_forecasts', 'Correct Forecasts'),
('ar', 'correct_forecasts', 'توقعات صحيحة'),
('en', 'incorrect_forecasts', 'Incorrect Forecasts'),
('ar', 'incorrect_forecasts', 'توقعات خاطئة'),
('en', 'hit_rate', 'Hit Rate'),
('ar', 'hit_rate', 'نسبة النجاح')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Date Display Translations for Stock Analysis
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # prominent date display component on the Stock Analysis page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'data_for_date', 'Displaying analysis for:'),
('ar', 'data_for_date', 'عرض التحليل ليوم:')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add "Last Close Info" Translation
-- #
-- # Purpose: This script adds the UI translation key required for the
-- # "Last Close Info" column header on the "Last Work Day" page, fixing an
-- # issue where the key was displayed instead of the translated text.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/update the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'last_close_info', 'Last Close Info'),
('ar', 'last_close_info', 'معلومات آخر إغلاق')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Stock Details Page System
-- #
-- # Purpose: This script introduces the backend infrastructure for the new
-- # Stock Details page.
-- #
-- # It performs two key actions:
-- # 1. Creates a new RPC function `get_stock_details_page_data` to efficiently
-- #    fetch all required data for a given stock in a single call.
-- # 2. Adds all necessary UI translations for the new page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the RPC function to fetch all data for the details page.
CREATE OR REPLACE FUNCTION public.get_stock_details_page_data(p_symbol TEXT)
RETURNS json
LANGUAGE sql
STABLE
AS $$
SELECT json_build_object(
    'details', (
        SELECT row_to_json(s)
        FROM public.stocks s
        WHERE s.symbol = p_symbol
    ),
    'next_forecast', (
        SELECT row_to_json(f)
        FROM public.forecasts f
        WHERE f.stock_symbol = p_symbol
        ORDER BY f.forecast_date DESC
        LIMIT 1
    ),
    'historical_data', (
        SELECT COALESCE(json_agg(h ORDER BY h.date ASC), '[]'::json) -- Order ASC for charting
        FROM (
            SELECT * FROM public.historical_data
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 90
        ) h
    ),
    'latest_indicators', (
        SELECT row_to_json(ti)
        FROM public.technical_indicators ti
        WHERE ti.stock_symbol = p_symbol
        ORDER BY ti.date DESC
        LIMIT 1
    ),
    'forecast_history', (
        SELECT COALESCE(json_agg(fch ORDER BY fch.forecast_date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.forecast_check_history
            WHERE stock_symbol = p_symbol
            ORDER BY forecast_date DESC
            LIMIT 10
        ) fch
    ),
    'recent_patterns', (
         SELECT COALESCE(json_agg(cp ORDER BY cp.date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.candle_patterns
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 5
        ) cp
    )
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_stock_details_page_data" created or updated.';


-- Step 2: Add all necessary UI translations.
-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'stock_details', 'Stock Details'),
('ar', 'stock_details', 'تفاصيل السهم'),
('en', 'back_to_analysis', 'Back to Analysis List'),
('ar', 'back_to_analysis', 'الرجوع إلى قائمة التحليل'),
('en', 'next_day_forecast', 'Next Day Forecast'),
('ar', 'next_day_forecast', 'توقع اليوم التالي'),
('en', 'no_forecast_available', 'No forecast available.'),
('ar', 'no_forecast_available', 'لا يوجد توقع متاح.'),
('en', 'historical_performance_90d', 'Historical Performance (90-Day)'),
('ar', 'historical_performance_90d', 'الأداء التاريخي (آخر 90 يومًا)'),
('en', 'technical_indicators_tab', 'Technical Indicators'),
('ar', 'technical_indicators_tab', 'المؤشرات الفنية'),
('en', 'forecast_history_tab', 'Forecast History'),
('ar', 'forecast_history_tab', 'سجل التوقعات'),
('en', 'candle_patterns_tab', 'Recent Patterns'),
('ar', 'candle_patterns_tab', 'الأنماط الأخيرة'),
('en', 'outcome', 'Outcome'),
('ar', 'outcome', 'النتيجة'),
('en', 'pattern', 'Pattern'),
('ar', 'pattern', 'النمط'),
('en', 'sentiment', 'Sentiment'),
('ar', 'sentiment', 'المؤشر'),
('en', 'bullish', 'Bullish'),
('ar', 'bullish', 'صاعد'),
('en', 'bearish', 'Bearish'),
('ar', 'bearish', 'هابط')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for the Stock Details page have been added.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Ensure "Login Failed" Translation Exists
-- #
-- # Purpose: This script provides a definitive fix for an issue where the
-- # "login_failed" translation key was missing from the database, causing an
-- # untranslated error message to appear.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- This command ensures the 'login_failed' key exists for both English and Arabic.
-- If the key already exists, ON CONFLICT will simply update it to the correct value.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'login_failed', 'Invalid login credentials. Please try again.'),
('ar', 'login_failed', 'بيانات الدخول غير صحيحة. يرجى المحاولة مرة أخرى.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The "login_failed" translation has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Enhance Activity Logs Table
-- #
-- # Purpose: This script enhances the `activity_logs` table with an IP address
-- # column, sets up robust security, and adds the necessary permission for
-- # viewing logs.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Add the ip_address column to store the user's IP address.
DO $$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM information_schema.columns WHERE table_schema = 'public' AND table_name='activity_logs' AND column_name='ip_address') THEN
       ALTER TABLE public.activity_logs ADD COLUMN ip_address inet NULL;
       RAISE NOTICE 'SUCCESS: Column "ip_address" added to "activity_logs" table.';
    ELSE
       RAISE NOTICE 'INFO: Column "ip_address" already exists. No action taken.';
    END IF;
END $$;
COMMENT ON COLUMN public.activity_logs.ip_address IS 'The IP address of the user who performed the action.';

-- Step 2: Update the foreign key to SET NULL on user deletion.
-- This preserves log history even if a user account is removed.
ALTER TABLE public.activity_logs DROP CONSTRAINT IF EXISTS activity_logs_user_id_fkey;
ALTER TABLE public.activity_logs ADD CONSTRAINT activity_logs_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL;
RAISE NOTICE 'SUCCESS: Foreign key on "activity_logs" updated to ON DELETE SET NULL.';


-- Step 3: Add the new permission for viewing activity logs.
INSERT INTO public.permissions (action, description)
VALUES ('view:activity_log', 'Can view the system activity log.')
ON CONFLICT (action) DO UPDATE SET description = EXCLUDED.description;
RAISE NOTICE 'SUCCESS: Permission "view:activity_log" added or updated.';


-- Step 4: Assign the new permission to the Admin role.
DO $$
DECLARE
    admin_role_id UUID;
    view_log_perm_id UUID;
BEGIN
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    SELECT id INTO view_log_perm_id FROM public.permissions WHERE action = 'view:activity_log';

    IF admin_role_id IS NOT NULL AND view_log_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, view_log_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
        
        IF FOUND THEN
             RAISE NOTICE 'SUCCESS: Assigned "view:activity_log" permission to Admin role.';
        ELSE
             RAISE NOTICE 'INFO: Admin role already has "view:activity_log" permission.';
        END IF;
    END IF;
END $$;


-- Step 5: Set up Row Level Security (RLS) on the activity_logs table.
ALTER TABLE public.activity_logs ENABLE ROW LEVEL SECURITY;

-- Policy: Only allow users with the 'view:activity_log' permission to read the logs.
-- No public access is allowed. No one can write directly to this table; it's append-only via triggers.
DROP POLICY IF EXISTS "Allow log viewers to read activity logs" ON public.activity_logs;
CREATE POLICY "Allow log viewers to read activity logs"
ON public.activity_logs FOR SELECT
USING (public.has_permission('view:activity_log'));
RAISE NOTICE 'SUCCESS: RLS policies for "activity_logs" created or updated.';


COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Create Automated Logging Triggers and Functions
-- #
-- # Purpose: This script creates the core database functions and triggers for
-- # automatically logging important activities to the `activity_logs` table.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the main logging function.
-- V3 UPDATE: Updated the core logger to correctly read the user's IP address from
-- the 'x-forwarded-for' header provided by Supabase, instead of the server's internal IP.

-- This is the core logger, accepting a user_id directly.
CREATE OR REPLACE FUNCTION public.log_activity(p_user_id UUID, p_action_type TEXT, p_details_json JSONB)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER -- Required to access request headers.
SET search_path = public, auth
AS $$
DECLARE
    v_ip_address inet;
BEGIN
    -- Try to get the real IP from the X-Forwarded-For header, which Supabase/PostgREST sets.
    -- The header might contain a comma-separated list of IPs; we take the first one.
    -- A `true` second argument to current_setting makes it not throw an error if the setting is missing.
    BEGIN
        v_ip_address := split_part(current_setting('request.headers', true)::json->>'x-forwarded-for', ',', 1)::inet;
    EXCEPTION
        -- If the header is missing or malformed, it can throw an error.
        -- In that case, we fall back to inet_client_addr().
        WHEN others THEN
            v_ip_address := inet_client_addr();
    END;
    
    INSERT INTO public.activity_logs (user_id, action, details, ip_address)
    VALUES (
        p_user_id,
        p_action_type,
        p_details_json,
        v_ip_address
    );
END;
$$;

-- This is the original function signature, maintained for backward compatibility for other triggers.
-- It now acts as a wrapper, calling the core logger with the current user's ID from the active session.
CREATE OR REPLACE FUNCTION public.log_activity(action_type TEXT, details_json JSONB)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER -- To access auth.uid() and client IP
SET search_path = public, auth
AS $$
BEGIN
  -- Call the overloaded function, passing the current user's ID from the session.
  PERFORM public.log_activity(auth.uid(), action_type, details_json);
END;
$$;
-- RAISE NOTICE 'SUCCESS: Central logging function "log_activity" created or updated.';


-- Step 2: Trigger for Profile Changes (User Role Update)
CREATE OR REPLACE FUNCTION public.fn_log_profile_update()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  old_role_name TEXT;
  new_role_name TEXT;
BEGIN
  IF OLD.role_id IS DISTINCT FROM NEW.role_id THEN
    SELECT name INTO old_role_name FROM public.roles WHERE id = OLD.role_id;
    SELECT name INTO new_role_name FROM public.roles WHERE id = NEW.role_id;
    PERFORM public.log_activity(
      'USER_ROLE_CHANGED',
      jsonb_build_object(
        'target_user_email', NEW.email,
        'old_role_name', old_role_name,
        'new_role_name', new_role_name
      )
    );
  END IF;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS tr_log_profile_update ON public.profiles;
CREATE TRIGGER tr_log_profile_update
  AFTER UPDATE ON public.profiles
  FOR EACH ROW EXECUTE PROCEDURE public.fn_log_profile_update();
-- RAISE NOTICE 'SUCCESS: Trigger for profile updates created.';


-- Step 3: Trigger for Role Permission Changes
CREATE OR REPLACE FUNCTION public.fn_log_role_permission_change()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  action_type TEXT;
  details JSONB;
  role_name_text TEXT;
  permission_action_text TEXT;
BEGIN
  IF (TG_OP = 'INSERT') THEN
    action_type := 'ROLE_PERMISSION_ADDED';
    SELECT r.name, p.action INTO role_name_text, permission_action_text FROM public.roles r, public.permissions p WHERE r.id = NEW.role_id AND p.id = NEW.permission_id;
    details := jsonb_build_object('role_name', role_name_text, 'permission_action', permission_action_text);
    PERFORM public.log_activity(action_type, details);
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    action_type := 'ROLE_PERMISSION_REMOVED';
    SELECT r.name, p.action INTO role_name_text, permission_action_text FROM public.roles r, public.permissions p WHERE r.id = OLD.role_id AND p.id = OLD.permission_id;
    details := jsonb_build_object('role_name', role_name_text, 'permission_action', permission_action_text);
    PERFORM public.log_activity(action_type, details);
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$;

DROP TRIGGER IF EXISTS tr_log_role_permission_change ON public.role_permissions;
CREATE TRIGGER tr_log_role_permission_change
  AFTER INSERT OR DELETE ON public.role_permissions
  FOR EACH ROW EXECUTE PROCEDURE public.fn_log_role_permission_change();
-- RAISE NOTICE 'SUCCESS: Trigger for role permission changes created.';


-- Step 4: Trigger for App Settings Changes
CREATE OR REPLACE FUNCTION public.fn_log_app_settings_change()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    PERFORM public.log_activity(
      'APP_SETTING_CHANGED',
      jsonb_build_object(
        'setting_key', NEW.key,
        'old_value', OLD.value,
        'new_value', NEW.value
      )
    );
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS tr_log_app_settings_change ON public.app_settings;
CREATE TRIGGER tr_log_app_settings_change
  AFTER UPDATE ON public.app_settings
  FOR EACH ROW EXECUTE PROCEDURE public.fn_log_app_settings_change();
-- RAISE NOTICE 'SUCCESS: Trigger for app settings changes created.';


-- Step 5: Update handle_new_user to log user creation.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
  user_count integer;
  target_role_id uuid;
BEGIN
  INSERT INTO public.profiles (id, full_name, email)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.email);

  SELECT count(*) INTO user_count FROM auth.users;

  IF user_count = 1 THEN
    SELECT id INTO target_role_id FROM public.roles WHERE name = 'Admin';
  ELSE
    SELECT id INTO target_role_id FROM public.roles WHERE name = 'User';
  END IF;

  IF target_role_id IS NOT NULL THEN
    UPDATE public.profiles SET role_id = target_role_id WHERE id = new.id;
  END IF;
  
  UPDATE auth.users SET email_confirmed_at = now() WHERE id = new.id;

  -- Log this event, passing the user_id directly to the new logger function
  PERFORM public.log_activity(new.id, 'USER_CREATED', jsonb_build_object('user_id', new.id, 'email', new.email));

  RETURN new;
END;
$$;
-- RAISE NOTICE 'SUCCESS: Trigger "handle_new_user" updated to log user creation.';


-- Step 6: Trigger for Successful User Login
CREATE OR REPLACE FUNCTION public.fn_log_user_login()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
BEGIN
  -- last_sign_in_at is updated on every successful login
  IF OLD.last_sign_in_at IS DISTINCT FROM NEW.last_sign_in_at THEN
    -- Call the overloaded logger with the explicit user ID from the trigger's context
    PERFORM public.log_activity(NEW.id, 'USER_LOGIN_SUCCESS', jsonb_build_object('user_id', NEW.id, 'email', NEW.email));
  END IF;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS tr_log_user_login ON auth.users;
CREATE TRIGGER tr_log_user_login
  AFTER UPDATE OF last_sign_in_at ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.fn_log_user_login();
-- RAISE NOTICE 'SUCCESS: Trigger for successful user logins created.';


-- Step 7: Create RPC function for the UI to fetch logs with pagination and filtering.
CREATE OR REPLACE FUNCTION public.get_activity_logs(
    page_num INT, 
    page_size INT, 
    search_query TEXT DEFAULT '', 
    filter_action TEXT DEFAULT '',
    start_date_filter DATE DEFAULT NULL,
    end_date_filter DATE DEFAULT NULL
)
RETURNS TABLE (
    id bigint,
    created_at timestamptz,
    user_full_name text,
    user_email text,
    action text,
    ip_address inet,
    details jsonb,
    total_count bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
  query_offset INT;
BEGIN
  IF NOT public.has_permission('view:activity_log') THEN
    RETURN;
  END IF;

  query_offset := (page_num - 1) * page_size;

  RETURN QUERY
  WITH filtered_logs AS (
    SELECT
      al.id,
      al.created_at,
      p.full_name AS user_full_name,
      p.email AS user_email,
      al.action,
      al.ip_address,
      al.details
    FROM public.activity_logs al
    LEFT JOIN public.profiles p ON al.user_id = p.id
    WHERE
      (search_query = '' OR search_query IS NULL OR p.email ILIKE '%' || search_query || '%' OR p.full_name ILIKE '%' || search_query || '%') AND
      (filter_action = '' OR filter_action IS NULL OR al.action = filter_action) AND
      (start_date_filter IS NULL OR al.created_at::date >= start_date_filter) AND
      (end_date_filter IS NULL OR al.created_at::date <= end_date_filter)
  )
  SELECT
    fl.id,
    fl.created_at,
    fl.user_full_name,
    fl.user_email,
    fl.action,
    fl.ip_address,
    fl.details,
    count(*) OVER() AS total_count
  FROM filtered_logs fl
  ORDER BY fl.created_at DESC
  OFFSET query_offset
  LIMIT page_size;
END;
$$;
-- RAISE NOTICE 'SUCCESS: RPC function "get_activity_logs" for UI created.';


-- Step 8: Create RPC function to get distinct action types for filtering.
CREATE OR REPLACE FUNCTION public.get_distinct_log_actions()
RETURNS TABLE (action TEXT)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
BEGIN
  IF NOT public.has_permission('view:activity_log') THEN
    RETURN;
  END IF;

  RETURN QUERY
    SELECT DISTINCT al.action FROM public.activity_logs al ORDER BY al.action;
END;
$$;
-- RAISE NOTICE 'SUCCESS: RPC function "get_distinct_log_actions" for UI created.';


COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Activity Log UI Translations
-- #
-- # Purpose: This script adds all the translation keys needed for the new
-- # Activity Log page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Delete the old 'timestamp' key as it's being replaced.
DELETE FROM public.translations WHERE key = 'timestamp';

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Page Title & Permission
('en', 'activity_log', 'Activity Log'),
('ar', 'activity_log', 'سجل الأنشطة'),
('en', 'perm_view_activity_log', 'View Activity Log'),
('ar', 'perm_view_activity_log', 'عرض سجل الأنشطة'),
('en', 'perm_view_activity_log_desc', 'Can view the system activity log.'),
('ar', 'perm_view_activity_log_desc', 'يمكنه عرض سجل أنشطة النظام.'),

-- Table Headers & Controls
('en', 'date_time', 'Date Time'),
('ar', 'date_time', 'تاريخ ووقت'),
('en', 'user', 'User'),
('ar', 'user', 'المستخدم'),
('en', 'action_type', 'Action'),
('ar', 'action_type', 'الإجراء'),
('en', 'ip_address', 'IP Address'),
('ar', 'ip_address', 'عنوان IP'),
('en', 'details', 'Details'),
('ar', 'details', 'التفاصيل'),
('en', 'search_by_name_or_email', 'Search by name or email...'),
('ar', 'search_by_name_or_email', 'ابحث بالاسم أو البريد الإلكتروني...'),
('en', 'filter_by_action', 'Filter by action type'),
('ar', 'filter_by_action', 'تصفية حسب نوع الإجراء'),
('en', 'no_logs_found', 'No activity logs found.'),
('ar', 'no_logs_found', 'لم يتم العثور على سجلات أنشطة.'),
('en', 'all_actions', 'All Actions'),
('ar', 'all_actions', 'كل الإجراءات'),

-- Action Types
('en', 'log_action_USER_ROLE_CHANGED', 'User Role Changed'),
('ar', 'log_action_USER_ROLE_CHANGED', 'تغيير دور المستخدم'),
('en', 'log_action_ROLE_PERMISSION_ADDED', 'Permission Added'),
('ar', 'log_action_ROLE_PERMISSION_ADDED', 'إضافة صلاحية'),
('en', 'log_action_ROLE_PERMISSION_REMOVED', 'Permission Removed'),
('ar', 'log_action_ROLE_PERMISSION_REMOVED', 'إزالة صلاحية'),
('en', 'log_action_APP_SETTING_CHANGED', 'App Setting Changed'),
('ar', 'log_action_APP_SETTING_CHANGED', 'تغيير إعدادات التطبيق'),
('en', 'log_action_USER_CREATED', 'User Created'),
('ar', 'log_action_USER_CREATED', 'إنشاء مستخدم'),
('en', 'log_action_USER_LOGIN_SUCCESS', 'User Login'),
('ar', 'log_action_USER_LOGIN_SUCCESS', 'تسجيل دخول المستخدم'),

-- Keys for Details
('en', 'log_key_target_user', 'Target User'),
('ar', 'log_key_target_user', 'المستخدم المستهدف'),
('en', 'log_key_old_role', 'Old Role'),
('ar', 'log_key_old_role', 'الدور القديم'),
('en', 'log_key_new_role', 'New Role'),
('ar', 'log_key_new_role', 'الدور الجديد'),
('en', 'log_key_role', 'Role'),
('ar', 'log_key_role', 'الدور'),
('en', 'log_key_permission', 'Permission'),
('ar', 'log_key_permission', 'الصلاحية'),
('en', 'log_key_setting', 'Setting'),
('ar', 'log_key_setting', 'الإعداد'),
('en', 'log_key_old_value', 'Old Value'),
('ar', 'log_key_old_value', 'القيمة القديمة'),
('en', 'log_key_new_value', 'New Value'),
('ar', 'log_key_new_value', 'القيمة الجديدة')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Announcements Update RLS Policy
-- #
-- # Purpose: This script provides a definitive fix for the issue where the
-- # "Save" button on the "Edit Announcement" modal was failing silently. The
-- # previous RLS policy for UPDATE operations was missing a `WITH CHECK`
-- # clause, causing ambiguity and silent failures.
-- #
-- # This script replaces the faulty policy with a robust one that explicitly
-- # checks permissions for the updated row data.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- First, drop the old, incomplete UPDATE policy.
DROP POLICY IF EXISTS "Allow managers to UPDATE announcements" ON public.global_announcements;
RAISE NOTICE 'INFO: Dropped old UPDATE policy on global_announcements table.';

-- Now, create the new, robust UPDATE policy with both USING and WITH CHECK.
-- This ensures the permission check is applied correctly during update operations.
CREATE POLICY "Allow managers to UPDATE announcements"
    ON public.global_announcements FOR UPDATE
    USING (public.has_permission('manage:announcements'))
    WITH CHECK (public.has_permission('manage:announcements'));

RAISE NOTICE 'SUCCESS: Replaced the announcements UPDATE policy with a robust version, fixing the save button issue.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Definitive Announcements RLS Fix
-- #
-- # Purpose: This script provides a definitive fix for the issue where the
-- # "Save" button on the "Edit Announcement" modal was failing silently. It
-- # replaces all previous policies with a clean, explicit, and robust set.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Drop all existing policies on the table to avoid any conflicts.
DROP POLICY IF EXISTS "Allow public read access for active announcements" ON public.global_announcements;
DROP POLICY IF EXISTS "Public read access for active announcements" ON public.global_announcements;
DROP POLICY IF EXISTS "Allow managers full access" ON public.global_announcements;
DROP POLICY IF EXISTS "Allow managers to SELECT all announcements" ON public.global_announcements;
DROP POLICY IF EXISTS "Managers can read all announcements" ON public.global_announcements;
DROP POLICY IF EXISTS "Allow managers to INSERT announcements" ON public.global_announcements;
DROP POLICY IF EXISTS "Managers can insert announcements" ON public.global_announcements;
DROP POLICY IF EXISTS "Allow managers to UPDATE announcements" ON public.global_announcements;
DROP POLICY IF EXISTS "Managers can update announcements" ON public.global_announcements;
DROP POLICY IF EXISTS "Allow managers to DELETE announcements" ON public.global_announcements;
DROP POLICY IF EXISTS "Managers can delete announcements" ON public.global_announcements;

-- Create the correct, explicit policies from scratch.

-- 1. Public can read active announcements.
CREATE POLICY "Public read access for active announcements"
    ON public.global_announcements FOR SELECT
    USING ( is_enabled = true AND now() >= start_date AND now() <= end_date );

-- 2. Managers can read ALL announcements (active, expired, disabled, etc.).
CREATE POLICY "Managers can read all announcements"
    ON public.global_announcements FOR SELECT
    USING ( public.has_permission('manage:announcements') );

-- 3. Managers can insert new announcements.
CREATE POLICY "Managers can insert announcements"
    ON public.global_announcements FOR INSERT
    WITH CHECK ( public.has_permission('manage:announcements') );

-- 4. Managers can update announcements. This is the critical fix.
CREATE POLICY "Managers can update announcements"
    ON public.global_announcements FOR UPDATE
    USING ( public.has_permission('manage:announcements') )
    WITH CHECK ( public.has_permission('manage:announcements') );

-- 5. Managers can delete announcements.
CREATE POLICY "Managers can delete announcements"
    ON public.global_announcements FOR DELETE
    USING ( public.has_permission('manage:announcements') );
    
RAISE NOTICE 'SUCCESS: Replaced all RLS policies on global_announcements with a definitive, robust set.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add "Saving..." Translation Key
-- #
-- # Purpose: This script adds the missing translation key for the "Saving..."
-- # state on buttons, ensuring it's correctly translated into Arabic. It
-- # also includes the ellipsis in the translation value for consistency.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'saving', 'Saving...'),
('ar', 'saving', 'جاري الحفظ...')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The "saving" translation has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Definitive Fix for Hanging Save Button (Corrected)
-- #
-- # Purpose: This script provides a definitive, server-side fix for the issue
-- # where the "Save" button would hang indefinitely. The root cause is invisible null
-- # characters (`\u0000`) that cause PostgreSQL's JSONB/text processing to fail.
-- #
-- # This script creates a trigger that automatically sanitizes the `title` and
-- # `message` JSONB fields on the `global_announcements` table BEFORE any
-- # insert or update, ensuring no invalid characters ever reach the database.
-- #
-- # This version uses the standard `chr(0)` function for maximum compatibility.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the trigger function to sanitize the JSONB fields.
CREATE OR REPLACE FUNCTION public.sanitize_announcement_jsonb()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
    sanitized_title JSONB;
    sanitized_message JSONB;
    rec RECORD;
BEGIN
    -- Sanitize the 'title' JSONB field if it's not NULL.
    IF NEW.title IS NOT NULL THEN
        sanitized_title := '{}'::jsonb;
        FOR rec IN SELECT * FROM jsonb_each_text(NEW.title) LOOP
            -- Use chr(0) to represent the null character, which is more robust than escape strings.
            sanitized_title := sanitized_title || jsonb_build_object(rec.key, replace(rec.value, chr(0), ''));
        END LOOP;
        NEW.title := sanitized_title;
    END IF;

    -- Sanitize the 'message' JSONB field if it's not NULL.
    IF NEW.message IS NOT NULL THEN
        sanitized_message := '{}'::jsonb;
        FOR rec IN SELECT * FROM jsonb_each_text(NEW.message) LOOP
            sanitized_message := sanitized_message || jsonb_build_object(rec.key, replace(rec.value, chr(0), ''));
        END LOOP;
        NEW.message := sanitized_message;
    END IF;

    RETURN NEW;
END;
$$;
RAISE NOTICE 'SUCCESS: Sanitization function for announcements created or updated.';


-- Step 2: Create the trigger that executes the function before any write operation.
DROP TRIGGER IF EXISTS tr_sanitize_announcement_jsonb ON public.global_announcements;
CREATE TRIGGER tr_sanitize_announcement_jsonb
  BEFORE INSERT OR UPDATE ON public.global_announcements
  FOR EACH ROW EXECUTE PROCEDURE public.sanitize_announcement_jsonb();

RAISE NOTICE 'SUCCESS: Trigger to sanitize announcements has been applied. The save issue is now definitively fixed.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix App Settings Loading Error
-- #
-- # Purpose: This script provides a definitive fix for an issue where the
-- # application would fail to load with an "Error fetching app settings"
-- # message. This was likely caused by an RLS-related issue preventing the
-- # `get_all_app_settings` function from reading the settings table.
-- #
-- # This script modifies the function to run with `SECURITY DEFINER`, allowing
-- # it to bypass RLS and reliably fetch the public application settings.
-- # This is safe as the settings are intended for public read access.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.get_all_app_settings()
RETURNS SETOF public.app_settings
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT key, value FROM public.app_settings;
$$;

RAISE NOTICE 'SUCCESS: The "get_all_app_settings" function has been updated with SECURITY DEFINER to fix loading errors.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix 'get_all_app_settings' Function Return Type
-- #
-- # Purpose: This script provides a definitive fix for the "return type mismatch"
-- # error that occurred when calling the `get_all_app_settings` function.
-- #
-- # The previous version used `RETURNS SETOF public.app_settings`, which can be
-- # brittle. This version explicitly defines the return columns using
-- # `RETURNS TABLE(key text, value text)`. This creates a stable contract for
-- # the function that is not affected by potential underlying table changes,
-- # resolving the error permanently.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.get_all_app_settings()
RETURNS TABLE(key text, value text)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  -- Explicitly select the two columns that match the RETURNS TABLE definition.
  -- Using an alias 'a' for clarity.
  SELECT a.key, a.value FROM public.app_settings AS a;
$$;

RAISE NOTICE 'SUCCESS: The "get_all_app_settings" function has been corrected with an explicit return type to fix the mismatch error.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Strengthen Announcement Sanitization (Definitive Fix)
-- #
-- # Purpose: This script provides a definitive server-side fix for the
-- # "null character not permitted" error that occurs when saving announcements.
-- # The root cause is invisible null characters (\u0000) in text fields.
-- #
-- # This script replaces the previous, complex trigger function with a much
-- # simpler and more robust one. The new function casts the entire JSONB object
-- # to text, performs a global replace on the null character, and casts it back.
-- # This is more effective than iterating over JSON keys.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################
   
BEGIN;

-- Step 1: Replace the trigger function with a more robust version.
CREATE OR REPLACE FUNCTION public.sanitize_announcement_jsonb()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN           
    -- Sanitize the 'title' JSONB field by casting to text, replacing, and casting back.
    -- The '\u0000' is the JSON escape sequence for the null character that PostgreSQL rejects.
    IF NEW.title IS NOT NULL THEN
        NEW.title := replace(NEW.title::text, '\u0000', '')::jsonb;
    END IF;

    -- Do the same for the 'message' JSONB field.
    IF NEW.message IS NOT NULL THEN
        NEW.message := replace(NEW.message::text, '\u0000', '')::jsonb;
    END IF;

    RETURN NEW;
END;
$$;
RAISE NOTICE 'SUCCESS: Sanitization function for announcements has been upgraded to a more robust version.';


-- Step 2: Ensure the trigger is applied.
-- The CREATE OR REPLACE on the function is the key change, but we ensure the trigger is present.
DROP TRIGGER IF EXISTS tr_sanitize_announcement_jsonb ON public.global_announcements;
CREATE TRIGGER tr_sanitize_announcement_jsonb
  BEFORE INSERT OR UPDATE ON public.global_announcements
  FOR EACH ROW EXECUTE PROCEDURE public.sanitize_announcement_jsonb();

RAISE NOTICE 'SUCCESS: Trigger to sanitize announcements has been re-applied. The save issue is now definitively fixed.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Create Automated Forecast Evaluation Procedure
-- #
-- # Purpose: This script creates a single, efficient PostgreSQL function
-- # named `evaluate_and_save_forecasts()`. This function entirely replaces
-- # the external `forecast_check_run.py` script by performing all evaluation
-- # logic directly within the database.
-- #
-- # When called, it will:
-- # 1. Find all forecasts that haven't been evaluated yet.
-- # 2. Join them with available historical data for the same day.
-- # 3. Calculate the hit/miss status and error metrics.
-- # 4. Atomically save the results to `forecast_check_history`,
-- #    `forecast_check_latest`, and `Forcast_Result` using UPSERT logic.
-- #
-- # This server-side approach is significantly more efficient and robust.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.evaluate_and_save_forecasts(p_date_filter date DEFAULT NULL)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    processed_count integer;
BEGIN
    -- This single WITH clause performs all calculations and insertions atomically.
    WITH new_evaluations AS (
        -- Calculate the results for all forecasts that have matching historical data.
        -- This allows re-evaluation if historical data changes or logic is updated.
        SELECT
            f.stock_symbol,
            s.name AS stock_name,
            f.forecast_date,
            f.predicted_price,
            f.predicted_lo,
            f.predicted_hi,
            f.confidence,
            h.low AS actual_low,
            h.high AS actual_high,
            h.close AS actual_close,
            -- Core "hit" logic: TRUE if the predicted range overlaps with the actual range.
            (f.predicted_lo <= h.high AND h.low <= f.predicted_hi) AS hit_range,
            -- Calculate error metrics, avoiding division by zero with NULLIF.
            ABS(f.predicted_price - h.close) AS abs_error,
            ABS(f.predicted_price - h.close) / NULLIF(h.close, 0) AS pct_error
        FROM
            public.forecasts f
        JOIN
            public.stocks s ON f.stock_symbol = s.symbol
        JOIN
            public.historical_data h ON f.stock_symbol = h.stock_symbol AND f.forecast_date = h.date
        -- Filter by date if provided, otherwise process all.
        WHERE (p_date_filter IS NULL OR f.forecast_date = p_date_filter)
    ),
    insert_history AS (
        INSERT INTO public.forecast_check_history (
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        )
        SELECT
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        FROM new_evaluations
        ON CONFLICT (stock_symbol, forecast_date) DO UPDATE SET
            predicted_price = EXCLUDED.predicted_price,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            actual_close = EXCLUDED.actual_close,
            hit_range = EXCLUDED.hit_range,
            abs_error = EXCLUDED.abs_error,
            pct_error = EXCLUDED.pct_error,
            confidence = EXCLUDED.confidence,
            created_at = NOW()
        RETURNING 1
    ),
    upsert_latest AS (
        INSERT INTO public.forecast_check_latest (
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        )
        -- Select only the single most recent evaluation for each stock symbol
        -- from the set of new evaluations to prevent the "cannot affect row a second time" error.
        SELECT DISTINCT ON (stock_symbol)
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        FROM new_evaluations
        ORDER BY stock_symbol, forecast_date DESC -- Crucial for DISTINCT ON to pick the latest
        ON CONFLICT (stock_symbol) DO UPDATE SET
            forecast_date = EXCLUDED.forecast_date,
            predicted_price = EXCLUDED.predicted_price,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            actual_close = EXCLUDED.actual_close,
            hit_range = EXCLUDED.hit_range,
            abs_error = EXCLUDED.abs_error,
            pct_error = EXCLUDED.pct_error,
            confidence = EXCLUDED.confidence,
            created_at = NOW()
    ),
    insert_legacy AS (
        INSERT INTO public."Forcast_Result" (
            stock_symbol, stock_name, forecast_date, predicted_lo, predicted_hi,
            actual_low, actual_high, is_hit
        )
        SELECT
            stock_symbol, stock_name, forecast_date, predicted_lo, predicted_hi,
            actual_low, actual_high, hit_range
        FROM new_evaluations
        ON CONFLICT (stock_symbol, forecast_date) DO UPDATE SET
            stock_name = EXCLUDED.stock_name,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            is_hit = EXCLUDED.is_hit,
            created_at = NOW()
    )
    SELECT count(*) INTO processed_count FROM insert_history;
        
    RAISE NOTICE '% forecast(s) evaluated and saved.', processed_count;
    
    RETURN processed_count;
END;
$$;

RAISE NOTICE 'SUCCESS: Function "evaluate_and_save_forecasts" created or updated.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Filter Daily Checklist by Latest Date
-- #
-- # Purpose: This script updates the `get_daily_checklist` function to return
-- # data ONLY for the single most recent forecast date available in the
-- # `Forcast_Result` table. This ensures the "Last Work Day" page calculates
-- # statistics based solely on the latest data, as requested.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.get_daily_checklist()
RETURNS SETOF public.vw_Last_dayCheckList
LANGUAGE sql STABLE
AS $$
  -- This function now returns data ONLY for the single most recent forecast date
  -- available in the Forcast_Result table. The UI then calculates stats on this filtered data.
  WITH latest_date AS (
    SELECT max(forecast_date) AS value FROM public."Forcast_Result"
  )
  SELECT * 
  FROM public.vw_Last_dayCheckList
  WHERE forecast_date = (SELECT value FROM latest_date);
$$;

RAISE NOTICE 'SUCCESS: Function "get_daily_checklist" updated to filter for the latest forecast date.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Create Automated Forecast Evaluation Trigger
-- #
-- # Purpose: This script automates the execution of the forecast evaluation
-- # process. It creates a trigger that runs after a new forecast is inserted.
-- # This trigger checks if the batch of forecasts for a given day is complete
-- # (by comparing forecast counts to tracked stock counts). If complete, it
-- # automatically calls the `evaluate_and_save_forecasts()` function.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Ensure the main evaluation function is up-to-date.
-- This is the function that will be called by the trigger.
CREATE OR REPLACE FUNCTION public.evaluate_and_save_forecasts(p_date_filter date DEFAULT NULL)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    processed_count integer;
BEGIN
    -- This single WITH clause performs all calculations and insertions atomically.
    WITH new_evaluations AS (
        -- Calculate the results for all forecasts that have matching historical data.
        -- This allows re-evaluation if historical data changes or logic is updated.
        SELECT
            f.stock_symbol,
            s.name AS stock_name,
            f.forecast_date,
            f.predicted_price,
            f.predicted_lo,
            f.predicted_hi,
            f.confidence,
            h.low AS actual_low,
            h.high AS actual_high,
            h.close AS actual_close,
            -- Core "hit" logic: TRUE if the predicted range overlaps with the actual range.
            (f.predicted_lo <= h.high AND h.low <= f.predicted_hi) AS hit_range,
            -- Calculate error metrics, avoiding division by zero with NULLIF.
            ABS(f.predicted_price - h.close) AS abs_error,
            ABS(f.predicted_price - h.close) / NULLIF(h.close, 0) AS pct_error
        FROM
            public.forecasts f
        JOIN
            public.stocks s ON f.stock_symbol = s.symbol
        JOIN
            public.historical_data h ON f.stock_symbol = h.stock_symbol AND f.forecast_date = h.date
        -- Filter by date if provided, otherwise process all.
        WHERE (p_date_filter IS NULL OR f.forecast_date = p_date_filter)
    ),
    insert_history AS (
        INSERT INTO public.forecast_check_history (
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        )
        SELECT
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        FROM new_evaluations
        ON CONFLICT (stock_symbol, forecast_date) DO UPDATE SET
            predicted_price = EXCLUDED.predicted_price,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            actual_close = EXCLUDED.actual_close,
            hit_range = EXCLUDED.hit_range,
            abs_error = EXCLUDED.abs_error,
            pct_error = EXCLUDED.pct_error,
            confidence = EXCLUDED.confidence,
            created_at = NOW()
        RETURNING 1
    ),
    upsert_latest AS (
        INSERT INTO public.forecast_check_latest (
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        )
        -- Select only the single most recent evaluation for each stock symbol
        -- from the set of new evaluations to prevent the "cannot affect row a second time" error.
        SELECT DISTINCT ON (stock_symbol)
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        FROM new_evaluations
        ORDER BY stock_symbol, forecast_date DESC -- Crucial for DISTINCT ON to pick the latest
        ON CONFLICT (stock_symbol) DO UPDATE SET
            forecast_date = EXCLUDED.forecast_date,
            predicted_price = EXCLUDED.predicted_price,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            actual_close = EXCLUDED.actual_close,
            hit_range = EXCLUDED.hit_range,
            abs_error = EXCLUDED.abs_error,
            pct_error = EXCLUDED.pct_error,
            confidence = EXCLUDED.confidence,
            created_at = NOW()
    ),
    insert_legacy AS (
        INSERT INTO public."Forcast_Result" (
            stock_symbol, stock_name, forecast_date, predicted_lo, predicted_hi,
            actual_low, actual_high, is_hit
        )
        SELECT
            stock_symbol, stock_name, forecast_date, predicted_lo, predicted_hi,
            actual_low, actual_high, hit_range
        FROM new_evaluations
        ON CONFLICT (stock_symbol, forecast_date) DO UPDATE SET
            stock_name = EXCLUDED.stock_name,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            is_hit = EXCLUDED.is_hit,
            created_at = NOW()
    )
    SELECT count(*) INTO processed_count FROM insert_history;
        
    RETURN processed_count;
END;
$$;
RAISE NOTICE 'SUCCESS: Function "evaluate_and_save_forecasts" created or updated.';


-- Step 2: Create the trigger function that decides when to run the evaluation.
CREATE OR REPLACE FUNCTION public.trigger_forecast_evaluation()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
    tracked_stock_count integer;
    forecast_count_for_date integer;
BEGIN
    -- 1. Get the counts to check if the batch is complete.
    SELECT count(*)
    INTO tracked_stock_count
    FROM public.stocks
    WHERE is_tracked = true;

    SELECT count(*)
    INTO forecast_count_for_date
    FROM public.forecasts
    WHERE forecast_date = NEW.forecast_date;

    -- 2. If the number of forecasts for the day matches or exceeds the number of tracked stocks,
    --    assume the batch is complete and run the evaluation function for that specific day.
    IF forecast_count_for_date >= tracked_stock_count THEN
        RAISE NOTICE 'Forecast batch for % appears complete. Triggering evaluation.', NEW.forecast_date;
        -- The function is now able to handle updates, so we call it for the specific date.
        PERFORM public.evaluate_and_save_forecasts(NEW.forecast_date);
    END IF;

    RETURN NEW;
END;
$$;
RAISE NOTICE 'SUCCESS: Function "trigger_forecast_evaluation" for the trigger has been created or updated.';


-- Step 3: Create the trigger and attach it to the forecasts table.
DROP TRIGGER IF EXISTS tr_evaluate_forecasts_on_batch_complete ON public.forecasts;
CREATE TRIGGER tr_evaluate_forecasts_on_batch_complete
  AFTER INSERT ON public.forecasts
  FOR EACH ROW
  EXECUTE PROCEDURE public.trigger_forecast_evaluation();
  
RAISE NOTICE 'SUCCESS: Trigger "tr_evaluate_forecasts_on_batch_complete" has been created on the forecasts table.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Admin Password Update Function
-- #
-- # Purpose: This script adds a secure RPC function that allows an authorized
-- # admin to change another user's password directly. This is required for
-- # the "Edit User" modal functionality.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.admin_update_user_password(user_id_to_update uuid, new_password text)
RETURNS void
LANGUAGE plpgsql
-- SECURITY DEFINER is necessary to modify the auth.users table.
SECURITY DEFINER
-- Set search path to ensure `has_permission` and `pgcrypto` functions are found.
SET search_path = public, extensions, auth
AS $$
BEGIN
  -- Security Check: Only allow users with 'manage:users' permission to run this.
  IF NOT public.has_permission('manage:users') THEN
    RAISE EXCEPTION 'Insufficient permissions: You need the "manage:users" permission to perform this action.';
  END IF;

  -- Validation: Ensure password meets minimum length.
  IF char_length(new_password) < 6 THEN
    RAISE EXCEPTION 'Password is too short. Minimum 6 characters required.';
  END IF;

  -- Perform the privileged action: Update the user's password in the auth schema.
  -- This requires the pgcrypto extension to be enabled.
  UPDATE auth.users
  SET encrypted_password = crypt(new_password, gen_salt('bf'))
  WHERE id = user_id_to_update;

END;
$$;

RAISE NOTICE 'SUCCESS: RPC function "admin_update_user_password" created or updated.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Password Edit Translations
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # password editing fields in the "Edit User" modal.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'new_password', 'New Password (leave blank to keep unchanged)'),
('ar', 'new_password', 'كلمة المرور الجديدة (اتركها فارغة لعدم التغيير)'),
('en', 'confirm_new_password', 'Confirm New Password'),
('ar', 'confirm_new_password', 'تأكيد كلمة المرور الجديدة'),
('en', 'password_too_short', 'Password must be at least 6 characters long.'),
('ar', 'password_too_short', 'يجب أن تكون كلمة المرور 6 أحرف على الأقل.'),
('en', 'password_is_required', 'Password is required for new users.'),
('ar', 'password_is_required', 'كلمة المرور مطلوبة للمستخدمين الجدد.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for password editing have been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Role Name Translations
-- #
-- # Purpose: This script adds the UI translation keys required to display
-- # role names (like 'Admin', 'User') in different languages. This fixes
-- # an issue where role names appeared in English in the Arabic UI.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for role names.
-- We include 'Supervisor' as it may have been added manually by users.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'role_Admin', 'Admin'),
('ar', 'role_Admin', 'مدير'),
('en', 'role_User', 'User'),
('ar', 'role_User', 'مستخدم'),
('en', 'role_Supervisor', 'Supervisor'),
('ar', 'role_Supervisor', 'مشرف')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for role names have been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Daily Watchlist Feature
-- #
-- # Purpose: This script introduces the backend infrastructure for the new
-- # "Daily Watchlist" page, which shows forecasts for the next trading day.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Add the new permission for viewing the watchlist.
INSERT INTO public.permissions (action, description)
VALUES ('view:daily_watchlist', 'Can view the daily watchlist of stock forecasts.')
ON CONFLICT (action) DO UPDATE SET description = EXCLUDED.description;
RAISE NOTICE 'SUCCESS: Permission "view:daily_watchlist" added or updated.';

-- Step 2: Assign the new permission to both Admin and User roles.
DO $$
DECLARE
    admin_role_id UUID;
    user_role_id UUID;
    view_watchlist_perm_id UUID;
BEGIN
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    SELECT id INTO user_role_id FROM public.roles WHERE name = 'User';
    SELECT id INTO view_watchlist_perm_id FROM public.permissions WHERE action = 'view:daily_watchlist';

    IF admin_role_id IS NOT NULL AND view_watchlist_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, view_watchlist_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
    END IF;
    
    IF user_role_id IS NOT NULL AND view_watchlist_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (user_role_id, view_watchlist_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
    END IF;

    RAISE NOTICE 'SUCCESS: Assigned "view:daily_watchlist" permission to Admin and User roles.';
END $$;

-- Step 3: Add UI translations for the new feature.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'daily_watchlist', 'Daily Watchlist'),
('ar', 'daily_watchlist', 'قائمة المراقبة اليومية'),
('en', 'perm_view_daily_watchlist', 'View Daily Watchlist'),
('ar', 'perm_view_daily_watchlist', 'عرض قائمة المراقبة اليومية'),
('en', 'perm_view_daily_watchlist_desc', 'Can view the daily watchlist of stock forecasts.'),
('ar', 'perm_view_daily_watchlist_desc', 'يمكنه عرض قائمة المراقبة اليومية لتوقعات الأسهم.'),
('en', 'watchlist_description', 'This is a list of stocks to watch for the upcoming trading day, based on our latest forecast models. This is not investment advice.'),
('ar', 'watchlist_description', 'هذه قائمة بالأسهم التي يجب مراقبتها ليوم التداول القادم، بناءً على أحدث نماذج التوقعات لدينا. هذه ليست نصيحة استثمارية.'),
('en', 'key_technical_levels', 'Key Technical Levels'),
('ar', 'key_technical_levels', 'المستويات الفنية الرئيسية'),
('en', 'last_technical_signal', 'Last Technical Signal'),
('ar', 'last_technical_signal', 'آخر إشارة فنية')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;
RAISE NOTICE 'SUCCESS: Translations for Daily Watchlist feature added.';

-- Step 4: Create the RPC function to fetch the watchlist data.
CREATE OR REPLACE FUNCTION public.get_daily_watchlist_data()
RETURNS TABLE (
    symbol text,
    stock_name text,
    last_close real,
    predicted_lo real,
    predicted_hi real,
    sma20 real,
    sma50 real,
    pattern_name text,
    bullish boolean,
    forecast_date date
)
LANGUAGE plpgsql STABLE
AS $$
DECLARE
    latest_forecast_date date;
    latest_indicator_date date;
BEGIN
    -- Find the latest date for which we have a forecast. This is for "tomorrow".
    SELECT max(f.forecast_date) INTO latest_forecast_date FROM public.forecasts f;

    -- Find the latest date for which we have indicators, which is "today".
    SELECT max(ti.date) INTO latest_indicator_date FROM public.technical_indicators ti WHERE ti.date < latest_forecast_date;

    RETURN QUERY
    SELECT
        s.symbol,
        s.name AS stock_name,
        s.price AS last_close,
        f.predicted_lo,
        f.predicted_hi,
        ti.sma20,
        ti.sma50,
        cp.pattern_name,
        cp.bullish,
        f.forecast_date
    FROM
        public.forecasts f
    JOIN
        public.stocks s ON f.stock_symbol = s.symbol
    LEFT JOIN
        public.technical_indicators ti ON f.stock_symbol = ti.stock_symbol AND ti.date = latest_indicator_date
    LEFT JOIN
        (
            -- Get only the first/most relevant pattern for the indicator date to avoid duplicate rows
            SELECT DISTINCT ON (cp_inner.stock_symbol) *
            FROM public.candle_patterns cp_inner
            WHERE cp_inner.date = latest_indicator_date
        ) cp ON f.stock_symbol = cp.stock_symbol
    WHERE
        f.forecast_date = latest_forecast_date
        AND s.is_tracked = true
    ORDER BY
        s.symbol;
END;
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_daily_watchlist_data" created or updated.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Daily Checklist Data Source (Definitive Fix)
-- #
-- # Purpose: This script provides a definitive fix for a data inconsistency on
-- # the "Last Work Day" page. It updates the underlying view and RPC function
-- # to use the correct data source: the `forecast_check_latest` table.
-- #
-- # This version uses DROP ... CASCADE to correctly handle dependencies where
-- # the get_daily_checklist function depends on the view, allowing the view
-- # to be replaced even if its column types have changed.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Drop the existing view and any objects that depend on it (like functions).
-- Using CASCADE is necessary because get_daily_checklist() depends on the view's type.
-- The dependent function will be recreated in Step 3, making this a safe operation.
DROP VIEW IF EXISTS public.vw_Last_dayCheckList CASCADE;
RAISE NOTICE 'INFO: Dropped "vw_Last_dayCheckList" view and its dependent objects.';

-- Step 2: Create the view to select from `forecast_check_latest` instead of the legacy table.
-- This new definition uses `double precision` columns from the source table.
CREATE VIEW public.vw_Last_dayCheckList AS
SELECT
  fcl.stock_symbol,
  s.name AS stock_name,
  s.last_updated,
  s.price,
  fcl.actual_low,
  fcl.actual_high,
  fcl.predicted_lo,
  fcl.predicted_hi,
  fcl.hit_range AS is_hit,
  fcl.forecast_date
FROM public.forecast_check_latest AS fcl
JOIN public.stocks AS s
  ON s.symbol = fcl.stock_symbol
ORDER BY fcl.stock_symbol;

RAISE NOTICE 'SUCCESS: View "vw_Last_dayCheckList" re-created to use the correct data source.';


-- Step 3: Re-create the RPC function that was dropped by CASCADE.
-- This function now correctly queries the new view and filters for the latest date.
CREATE OR REPLACE FUNCTION public.get_daily_checklist()
RETURNS SETOF public.vw_Last_dayCheckList
LANGUAGE sql STABLE
AS $$
  WITH latest_date AS (
    SELECT max(forecast_date) AS value FROM public.forecast_check_latest
  )
  SELECT * 
  FROM public.vw_Last_dayCheckList
  WHERE forecast_date = (SELECT value FROM latest_date);
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_daily_checklist" was re-created successfully.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix 'evaluate_and_save_forecasts' Function Overload Conflict
-- #
-- # Purpose: This script resolves the "function is not unique" error that
-- # occurs when calling `evaluate_and_save_forecasts()`. The error is caused
-- # by having two versions of the function in the database: one with no arguments,
-- # and one with a single argument that has a default value.
-- #
-- # This script provides a definitive fix by:
-- # 1. Explicitly dropping the conflicting, no-argument version of the function.
-- # 2. Re-creating the correct version of the function, which takes an optional
-- #    date parameter, ensuring only one valid function definition exists.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Drop the conflicting function with no arguments.
-- The empty parentheses are crucial to target the correct function signature.
-- Using `IF EXISTS` prevents an error if the function doesn't exist.
DROP FUNCTION IF EXISTS public.evaluate_and_save_forecasts();
RAISE NOTICE 'SUCCESS: Dropped conflicting no-argument version of "evaluate_and_save_forecasts".';

-- Step 2: Re-create the correct function with the date parameter.
-- This ensures the single, correct version of the function exists and is up-to-date.
CREATE OR REPLACE FUNCTION public.evaluate_and_save_forecasts(p_date_filter date DEFAULT NULL)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    processed_count integer;
BEGIN
    -- This single WITH clause performs all calculations and insertions atomically.
    WITH new_evaluations AS (
        -- Calculate the results for all forecasts that have matching historical data.
        SELECT
            f.stock_symbol,
            s.name AS stock_name,
            f.forecast_date,
            f.predicted_price,
            f.predicted_lo,
            f.predicted_hi,
            f.confidence,
            h.low AS actual_low,
            h.high AS actual_high,
            h.close AS actual_close,
            (f.predicted_lo <= h.high AND h.low <= f.predicted_hi) AS hit_range,
            ABS(f.predicted_price - h.close) AS abs_error,
            ABS(f.predicted_price - h.close) / NULLIF(h.close, 0) AS pct_error
        FROM
            public.forecasts f
        JOIN
            public.stocks s ON f.stock_symbol = s.symbol
        JOIN
            public.historical_data h ON f.stock_symbol = h.stock_symbol AND f.forecast_date = h.date
        WHERE (p_date_filter IS NULL OR f.forecast_date = p_date_filter)
    ),
    insert_history AS (
        INSERT INTO public.forecast_check_history (
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        )
        SELECT
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        FROM new_evaluations
        ON CONFLICT (stock_symbol, forecast_date) DO UPDATE SET
            predicted_price = EXCLUDED.predicted_price,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            actual_close = EXCLUDED.actual_close,
            hit_range = EXCLUDED.hit_range,
            abs_error = EXCLUDED.abs_error,
            pct_error = EXCLUDED.pct_error,
            confidence = EXCLUDED.confidence,
            created_at = NOW()
        RETURNING 1
    ),
    upsert_latest AS (
        INSERT INTO public.forecast_check_latest (
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        )
        SELECT DISTINCT ON (stock_symbol)
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        FROM new_evaluations
        ORDER BY stock_symbol, forecast_date DESC
        ON CONFLICT (stock_symbol) DO UPDATE SET
            forecast_date = EXCLUDED.forecast_date,
            predicted_price = EXCLUDED.predicted_price,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            actual_close = EXCLUDED.actual_close,
            hit_range = EXCLUDED.hit_range,
            abs_error = EXCLUDED.abs_error,
            pct_error = EXCLUDED.pct_error,
            confidence = EXCLUDED.confidence,
            created_at = NOW()
    ),
    insert_legacy AS (
        INSERT INTO public."Forcast_Result" (
            stock_symbol, stock_name, forecast_date, predicted_lo, predicted_hi,
            actual_low, actual_high, is_hit
        )
        SELECT
            stock_symbol, stock_name, forecast_date, predicted_lo, predicted_hi,
            actual_low, actual_high, hit_range
        FROM new_evaluations
        ON CONFLICT (stock_symbol, forecast_date) DO UPDATE SET
            stock_name = EXCLUDED.stock_name,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            is_hit = EXCLUDED.is_hit,
            created_at = NOW()
    )
    SELECT count(*) INTO processed_count FROM insert_history;
        
    RAISE NOTICE '% forecast(s) evaluated and saved.', processed_count;
    
    RETURN processed_count;
END;
$$;

RAISE NOTICE 'SUCCESS: Function "evaluate_and_save_forecasts(date)" re-created to resolve conflict.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Daily Watchlist UI Translations
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # filter controls and search functionality on the "Daily Watchlist" page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'search_by_symbol_or_name', 'Search by symbol or name...'),
('ar', 'search_by_symbol_or_name', 'ابحث بالرمز أو الاسم...'),
('en', 'all_patterns', 'All Patterns'),
('ar', 'all_patterns', 'كل الأنماط'),
('en', 'clear', 'Clear'),
('ar', 'clear', 'مسح')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Simplified Pattern Signal Translations
-- #
-- # Purpose: This script adds user-friendly translations to describe bullish
-- # and bearish candle patterns, replacing technical jargon like "Shooting Star".
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'pattern_signal_bullish', 'Potential Uptrend'),
('ar', 'pattern_signal_bullish', 'إشارة صعود محتملة'),
('en', 'pattern_signal_bearish', 'Potential Downtrend'),
('ar', 'pattern_signal_bearish', 'إشارة هبوط محتملة')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Technical Pattern Name Translations for Filters
-- #
-- # Purpose: This script adds the UI translation keys required to display
-- # candlestick pattern names in the filter dropdown on the Daily Watchlist page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'pattern_name_Shooting_Star', 'Shooting Star'),
('ar', 'pattern_name_Shooting_Star', 'شهاب ساقط'),
('en', 'pattern_name_Hammer', 'Hammer'),
('ar', 'pattern_name_Hammer', 'مطرقة'),
('en', 'pattern_name_Doji', 'Doji'),
('ar', 'pattern_name_Doji', 'دوجي'),
('en', 'pattern_name_Bullish_Engulfing', 'Bullish Engulfing'),
('ar', 'pattern_name_Bullish_Engulfing', 'ابتلاعية شرائية'),
('en', 'pattern_name_Bearish_Engulfing', 'Bearish Engulfing'),
('ar', 'pattern_name_Bearish_Engulfing', 'ابتلاعية بيعية')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translations for Visual Indicator Dashboard
-- #
-- # Purpose: This script adds all the new translation keys needed for the
-- # redesigned, visual technical indicator panel on the Stock Details page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Card Titles
('en', 'rsi_indicator_14', 'RSI (14)'),
('ar', 'rsi_indicator_14', 'مؤشر القوة النسبية (14)'),
('en', 'stochastic_oscillator', 'Stochastic (%K / %D)'),
('ar', 'stochastic_oscillator', 'مؤشر ستوكاستيك (%K / %D)'),
('en', 'williams_percent_r', 'Williams %R'),
('ar', 'williams_percent_r', 'مؤشر ويليامز %R'),
('en', 'bollinger_bands_20_2', 'Bollinger Bands (20, 2)'),
('ar', 'bollinger_bands_20_2', 'نطاقات بولينجر (20, 2)'),
('en', 'macd_indicator_full', 'MACD (12, 26, 9)'),
('ar', 'macd_indicator_full', 'مؤشر الماكد (12, 26, 9)'),
('en', 'moving_averages', 'Moving Averages'),
('ar', 'moving_averages', 'المتوسطات المتحركة'),
('en', 'volatility_indicators', 'Volatility'),
('ar', 'volatility_indicators', 'التقلب'),

-- Labels & Values
('en', 'value', 'Value'),
('ar', 'value', 'القيمة'),
('en', 'upper_band', 'Upper'),
('ar', 'upper_band', 'العلوي'),
('en', 'middle_band', 'Middle'),
('ar', 'middle_band', 'الأوسط'),
('en', 'lower_band', 'Lower'),
('ar', 'lower_band', 'السفلي'),
('en', 'macd_line', 'MACD'),
('ar', 'macd_line', 'الماكد'),
('en', 'signal_line', 'Signal'),
('ar', 'signal_line', 'الإشارة'),
('en', 'histogram', 'Histogram'),
('ar', 'histogram', 'الرسم البياني'),
('en', 'price_position', 'Price Position'),
('ar', 'price_position', 'موضع السعر'),
('en', 'cross_status', 'Cross Status'),
('ar', 'cross_status', 'حالة التقاطع'),
('en', 'percent_k', '%K'),
('ar', 'percent_k', '%K'),
('en', 'percent_d', '%D'),
('ar', 'percent_d', '%D'),

-- States & Zones
('en', 'overbought', 'Overbought'),
('ar', 'overbought', 'تشبع شرائي'),
('en', 'oversold', 'Oversold'),
('ar', 'oversold', 'تشبع بيعي'),
('en', 'neutral_zone', 'Neutral'),
('ar', 'neutral_zone', 'محايد'),
('en', 'bullish_cross', 'Bullish Cross'),
('ar', 'bullish_cross', 'تقاطع صاعد'),
('en', 'bearish_cross', 'Bearish Cross'),
('ar', 'bearish_cross', 'تقاطع هابط'),
('en', 'no_cross', 'No Cross'),
('ar', 'no_cross', 'لا يوجد تقاطع'),
('en', 'above', 'Above'),
('ar', 'above', 'أعلى'),
('en', 'below', 'Below'),
('ar', 'below', 'أسفل'),
('en', 'price_above_band', 'Price is Above'),
('ar', 'price_above_band', 'السعر أعلى'),
('en', 'price_below_band', 'Price is Below'),
('ar', 'price_below_band', 'السعر أسفل'),
('en', 'price_inside_bands', 'Price is Inside'),
('ar', 'price_inside_bands', 'السعر بالداخل'),

-- Moving Averages
('en', 'price_vs_sma', 'Price vs. SMA'),
('ar', 'price_vs_sma', 'السعر مقابل المتوسط المتحرك البسيط'),
('en', 'price_vs_ema', 'Price vs. EMA'),
('ar', 'price_vs_ema', 'السعر مقابل المتوسط المتحرك الأسي')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for the visual indicator dashboard have been added.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translations for AI Trader's Summary
-- #
-- # Purpose: This script adds all the new translation keys needed for the new
-- # AI-powered "Trader's Summary" component on the Stock Details page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'traders_summary', 'Trader''s Summary'),
('ar', 'traders_summary', 'الخلاصة من وجهة نظر متداول'),
('en', 'generating_summary', 'Generating summary'),
('ar', 'generating_summary', 'جاري إنشاء الخلاصة'),
('en', 'summary_generation_error', 'Could not generate summary at this time.'),
('ar', 'summary_generation_error', 'تعذر إنشاء الخلاصة في الوقت الحالي.'),
('en', 'not_enough_data_for_summary', 'Not enough indicator data to generate a summary.'),
('ar', 'not_enough_data_for_summary', 'لا توجد بيانات مؤشرات كافية لإنشاء خلاصة.')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for the Trader''s Summary have been added.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Completely Remove AI Summary Feature
-- #
-- # Purpose: This script removes all database objects related to the
-- # AI-powered summary feature, including the table, functions, cron job,
-- # and translations, as per the request to remove all Gemini API usage.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Unschedule and drop the daily cron job for summary generation.
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'unschedule' AND pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'cron')) THEN
        PERFORM cron.unschedule(job_name) FROM cron.job WHERE job_name = 'daily-ai-summary-generation';
        RAISE NOTICE 'SUCCESS: Unscheduled the "daily-ai-summary-generation" cron job if it existed.';
    ELSE
        RAISE NOTICE 'INFO: pg_cron extension not available or job does not exist. Skipping unschedule.';
    END IF;
END;
$$;


-- Step 2: Drop all RPC functions related to the AI summary feature.
DROP FUNCTION IF EXISTS public.generate_all_daily_summaries();
RAISE NOTICE 'SUCCESS: Dropped function "generate_all_daily_summaries".';


-- Step 3: Drop the table used to cache the summaries.
-- Using CASCADE to also remove any dependent objects.
DROP TABLE IF EXISTS public.stock_analysis_summaries CASCADE;
RAISE NOTICE 'SUCCESS: Dropped the "stock_analysis_summaries" table.';


-- Step 4: Update the stock details function to remove the summary field.
CREATE OR REPLACE FUNCTION public.get_stock_details_page_data(p_symbol TEXT)
RETURNS json
LANGUAGE sql
STABLE
AS $$
WITH latest_indicator_date AS (
    SELECT max(date) AS value
    FROM public.technical_indicators ti
    WHERE ti.stock_symbol = p_symbol
)
SELECT json_build_object(
    'details', (
        SELECT row_to_json(s)
        FROM public.stocks s
        WHERE s.symbol = p_symbol
    ),
    'next_forecast', (
        SELECT row_to_json(f)
        FROM public.forecasts f
        WHERE f.stock_symbol = p_symbol
        ORDER BY f.forecast_date DESC
        LIMIT 1
    ),
    'historical_data', (
        SELECT COALESCE(json_agg(h ORDER BY h.date ASC), '[]'::json) -- Order ASC for charting
        FROM (
            SELECT * FROM public.historical_data
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 90
        ) h
    ),
    'latest_indicators', (
        SELECT row_to_json(ti)
        FROM public.technical_indicators ti
        WHERE ti.stock_symbol = p_symbol AND ti.date = (SELECT value FROM latest_indicator_date)
        LIMIT 1
    ),
    'forecast_history', (
        SELECT COALESCE(json_agg(fch ORDER BY fch.forecast_date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.forecast_check_history
            WHERE stock_symbol = p_symbol
            ORDER BY forecast_date DESC
            LIMIT 10
        ) fch
    ),
    'recent_patterns', (
         SELECT COALESCE(json_agg(cp ORDER BY cp.date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.candle_patterns
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 5
        ) cp
    )
    -- The 'stock_summary' field has been removed from this object.
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_stock_details_page_data" updated to remove AI summary field.';


-- Step 5: Delete all translation keys related to the feature.
DELETE FROM public.translations
WHERE key IN (
  'quick_look_analysis'
);
RAISE NOTICE 'SUCCESS: Deleted all translation keys related to the AI summary feature.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Trader Summaries System
-- #
-- # Purpose: This script creates the database infrastructure for storing and
-- # retrieving the AI-generated "Trader's Summary" for each stock, improving
-- # performance by caching the generated content.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the table to store the summaries.
CREATE TABLE IF NOT EXISTS public.trader_summaries (
  stock_symbol text NOT NULL,
  "date" date NOT NULL,
  summary_en text NOT NULL,
  summary_ar text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT trader_summaries_pkey PRIMARY KEY (stock_symbol, date),
  CONSTRAINT trader_summaries_stock_symbol_fkey FOREIGN KEY (stock_symbol) REFERENCES stocks(symbol) ON DELETE CASCADE
);
COMMENT ON TABLE public.trader_summaries IS 'Stores AI-generated trader summaries for a stock on a specific date.';
RAISE NOTICE 'SUCCESS: Table "trader_summaries" created or already exists.';


-- Step 2: Set up Row Level Security (RLS) for the new table.
ALTER TABLE public.trader_summaries ENABLE ROW LEVEL SECURITY;

-- Policy 1: Allow anyone to read the summaries.
DROP POLICY IF EXISTS "Allow public read access on trader_summaries" ON public.trader_summaries;
CREATE POLICY "Allow public read access on trader_summaries"
    ON public.trader_summaries FOR SELECT
    USING (true);

-- Policy 2: Allow any authenticated user to save/update summaries.
-- Since generation is client-side, this allows the app to persist the results.
DROP POLICY IF EXISTS "Allow authenticated users to save summaries" ON public.trader_summaries;
CREATE POLICY "Allow authenticated users to save summaries"
    ON public.trader_summaries FOR ALL
    USING (auth.role() = 'authenticated');
RAISE NOTICE 'SUCCESS: RLS policies for "trader_summaries" created or updated.';


-- Step 3: Create an RPC function to GET a summary.
CREATE OR REPLACE FUNCTION public.get_trader_summary(p_symbol text, p_date date)
RETURNS public.trader_summaries
LANGUAGE sql STABLE
AS $$
  SELECT *
  FROM public.trader_summaries
  WHERE stock_symbol = p_symbol AND "date" = p_date
  LIMIT 1;
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_trader_summary" created or updated.';


-- Step 4: Create an RPC function to SAVE (UPSERT) a summary.
CREATE OR REPLACE FUNCTION public.save_trader_summary(
    p_symbol text,
    p_date date,
    p_summary_en text,
    p_summary_ar text
)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO public.trader_summaries (stock_symbol, "date", summary_en, summary_ar)
  VALUES (p_symbol, p_date, p_summary_en, p_summary_ar)
  ON CONFLICT (stock_symbol, "date") DO UPDATE SET
    summary_en = p_summary_en,
    summary_ar = p_summary_ar,
    created_at = now();
END;
$$;
RAISE NOTICE 'SUCCESS: RPC function "save_trader_summary" created or updated.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Automated AI Summary Generation System
-- #
-- # Purpose: This script moves the AI summary generation from the client-side
-- # to the backend. It creates a powerful PostgreSQL function that iterates
-- # through all tracked stocks, calls the Gemini API via pg_net, and saves
-- # the results. It also schedules this function to run daily via pg_cron.
-- #
-- # This completely eliminates the long waiting time for the first user who
-- # views a stock each day.
-- #
-- # !!! IMPORTANT SETUP STEP !!!
-- # Before this will work, you MUST add your Gemini API key as a secret in Supabase:
-- # 1. Go to your Supabase Dashboard -> Project Settings -> Database.
-- # 2. Under "Connection settings", enable the "pg_net" extension.
-- # 3. Go to the SQL Editor and run:
-- #    CREATE EXTENSION IF NOT EXISTS pg_net;
-- # 4. Go to your Supabase Dashboard -> Project Settings -> Vault.
-- # 5. Click "New Secret" and create a secret with the name `GEMINI_API_KEY`
-- #    and paste your API key as the value.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the main function to generate and cache all summaries.
CREATE OR REPLACE FUNCTION public.generate_and_cache_all_trader_summaries(p_date date DEFAULT (CURRENT_DATE - INTERVAL '1 day'))
RETURNS text
LANGUAGE plpgsql
-- SECURITY DEFINER is required to access pg_net and secrets.
SECURITY DEFINER
AS $$
DECLARE
    stock_record RECORD;
    indicators_record RECORD;
    prompt TEXT;
    gemini_api_key TEXT;
    api_url TEXT;
    response JSONB;
    summary_json JSONB;
    summary_en_text TEXT;
    summary_ar_text TEXT;
    processed_count INT := 0;
    error_count INT := 0;
    error_messages TEXT := '';
BEGIN
    -- Get the Gemini API key from Supabase Vault
    SELECT decrypted_secret INTO gemini_api_key FROM vault.decrypted_secrets WHERE name = 'GEMINI_API_KEY';

    IF gemini_api_key IS NULL OR gemini_api_key = '' THEN
        RAISE EXCEPTION 'GEMINI_API_KEY secret not found in Vault. Please add it in your Supabase project settings.';
    END IF;

    api_url := 'https://aistudio.googleapis.com/v1/models/gemini-2.5-flash:generateContent?key=' || gemini_api_key;

    -- Loop through each tracked stock
    FOR stock_record IN
        SELECT s.symbol, s.price FROM public.stocks s WHERE s.is_tracked = true
    LOOP
        BEGIN
            -- Get the latest indicators for the specified date
            SELECT * INTO indicators_record
            FROM public.technical_indicators ti
            WHERE ti.stock_symbol = stock_record.symbol AND ti.date = p_date
            LIMIT 1;

            -- Proceed only if we have the necessary data
            IF FOUND AND indicators_record.rsi IS NOT NULL AND indicators_record.macd_cross IS NOT NULL AND stock_record.price IS NOT NULL THEN
                -- Construct the exact same prompt as the client-side version
                prompt := format(
                    'You are an expert stock market analyst providing a concise summary for a trader. '
                    'Your analysis is based *only* on the data provided. '
                    'Generate a 3-point summary in both English and Arabic, formatted as a JSON object with "en" and "ar" keys. '
                    'Each language summary must follow this structure, including its specific introductory phrase: '
                    '- English Intro: "Based on this data, I understand the following:" '
                    '- Arabic Intro: "بناءً على هذه البيانات، أفهم ما يلي:" '
                    '- **Overall Situation:** Describe the trend by comparing the Current Price to the moving averages (SMA20, SMA50, SMA200). '
                    '- **Momentum:** Describe the momentum based on the MACD Cross Signal (1=bullish, -1=bearish, 0=neutral). '
                    '- **Point of Caution/Opportunity:** Describe the situation based on the RSI (>70=overbought, <30=oversold). '
                    '**Data:** '
                    '- Current Price: %s, - SMA20: %s, - SMA50: %s, - SMA200: %s, - MACD Cross Signal: %s, - RSI (14): %s. '
                    'Your output must be ONLY the JSON object.',
                    stock_record.price,
                    indicators_record.sma20,
                    indicators_record.sma50,
                    indicators_record.sma200,
                    indicators_record.macd_cross,
                    indicators_record.rsi
                );
                
                -- Make the HTTP request to Gemini API
                SELECT content::jsonb INTO response
                FROM pg_net.http_post(
                    url := api_url,
                    headers := '{"Content-Type": "application/json"}',
                    body := jsonb_build_object(
                        'contents', jsonb_build_array(jsonb_build_object('parts', jsonb_build_array(jsonb_build_object('text', prompt)))),
                        'generationConfig', jsonb_build_object('response_mime_type', 'application/json')
                    )
                ) AS content;
                
                -- Extract the summaries from the response
                summary_json := (response -> 'candidates' -> 0 -> 'content' -> 'parts' -> 0 ->> 'text')::jsonb;
                summary_en_text := summary_json ->> 'en';
                summary_ar_text := summary_json ->> 'ar';
                
                -- Save the summary to the database
                IF summary_en_text IS NOT NULL AND summary_ar_text IS NOT NULL THEN
                    PERFORM public.save_trader_summary(stock_record.symbol, p_date, summary_en_text, summary_ar_text);
                    processed_count := processed_count + 1;
                ELSE
                    RAISE WARNING 'Gemini response for % was empty or malformed.', stock_record.symbol;
                    error_count := error_count + 1;
                    error_messages := error_messages || stock_record.symbol || ': Malformed response; ';
                END IF;

            ELSE
                RAISE WARNING 'Skipping % for date % due to missing indicator or price data.', stock_record.symbol, p_date;
                error_count := error_count + 1;
                error_messages := error_messages || stock_record.symbol || ': Missing data; ';
            END IF;
        EXCEPTION
            WHEN others THEN
                RAISE WARNING 'Failed to process summary for %: %', stock_record.symbol, SQLERRM;
                error_count := error_count + 1;
                error_messages := error_messages || stock_record.symbol || ': ' || SQLERRM || '; ';
        END;
    END LOOP;

    RETURN 'Summary generation complete. Processed: ' || processed_count || ', Errors: ' || error_count || '. Errors: ' || error_messages;
END;
$$;

RAISE NOTICE 'SUCCESS: Function "generate_and_cache_all_trader_summaries" created.';

-- Step 2: Schedule the function to run daily.
-- This job runs every day at 8:00 AM UTC.
-- It processes the data for the PREVIOUS day to ensure all market data is available.
SELECT cron.schedule(
    'daily-trader-summary-generation',
    '0 8 * * *', -- 8:00 AM UTC daily
    $$ SELECT public.generate_and_cache_all_trader_summaries(CURRENT_DATE - INTERVAL '1 day'); $$
);

RAISE NOTICE 'SUCCESS: Scheduled "generate_and_cache_all_trader_summaries" to run daily.';

COMMIT;
-- This migration is obsolete as the AI summary feature has been removed.
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translations for Summary Loading States
-- #
-- # Purpose: This script adds new UI translation keys to provide clearer
-- # feedback to the user while fetching the pre-generated AI summary.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'loading_summary', 'Loading summary'),
('ar', 'loading_summary', 'جاري تحميل الخلاصة'),
('en', 'summary_not_available_yet', 'Summary for this date is not available yet. Please check back later.'),
('ar', 'summary_not_available_yet', 'الخلاصة لهذا التاريخ غير متوفرة بعد. يرجى المراجعة لاحقًا.'),
('en', 'summary_fetch_error', 'An error occurred while fetching the summary.'),
('ar', 'summary_fetch_error', 'حدث خطأ أثناء جلب الخلاصة.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for summary loading states have been added.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Stock Details Function to Include Summary
-- #
-- # Purpose: This script enhances the `get_stock_details_page_data` RPC
-- # function to include the pre-generated `stock_summary`. This makes the
-- # data fetching for the Stock Details page more efficient by gathering all
-- # necessary data in a single network request.
-- #
-- # V2 Update: Added a safeguard to create the dependent table if it's missing,
-- # preventing errors if migrations are run out of order.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Defensive Step: Ensure the 'stock_analysis_summaries' table exists.
-- This is a safeguard in case migrations were run out of order or a previous one failed.
CREATE TABLE IF NOT EXISTS public.stock_analysis_summaries (
  stock_symbol text NOT NULL,
  "date" date NOT NULL,
  summary jsonb NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT stock_analysis_summaries_pkey PRIMARY KEY (stock_symbol, "date"),
  CONSTRAINT stock_analysis_summaries_stock_symbol_fkey FOREIGN KEY (stock_symbol) REFERENCES stocks(symbol) ON DELETE CASCADE
);
RAISE NOTICE 'INFO: Safeguard check complete. Table "stock_analysis_summaries" exists.';


-- Update the RPC function to fetch all data for the details page, now including the summary.
CREATE OR REPLACE FUNCTION public.get_stock_details_page_data(p_symbol TEXT)
RETURNS json
LANGUAGE sql
STABLE
AS $$
WITH latest_indicator_date AS (
    SELECT max(date) AS value
    FROM public.technical_indicators ti
    WHERE ti.stock_symbol = p_symbol
)
SELECT json_build_object(
    'details', (
        SELECT row_to_json(s)
        FROM public.stocks s
        WHERE s.symbol = p_symbol
    ),
    'next_forecast', (
        SELECT row_to_json(f)
        FROM public.forecasts f
        WHERE f.stock_symbol = p_symbol
        ORDER BY f.forecast_date DESC
        LIMIT 1
    ),
    'historical_data', (
        SELECT COALESCE(json_agg(h ORDER BY h.date ASC), '[]'::json) -- Order ASC for charting
        FROM (
            SELECT * FROM public.historical_data
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 90
        ) h
    ),
    'latest_indicators', (
        SELECT row_to_json(ti)
        FROM public.technical_indicators ti
        WHERE ti.stock_symbol = p_symbol AND ti.date = (SELECT value FROM latest_indicator_date)
        LIMIT 1
    ),
    'forecast_history', (
        SELECT COALESCE(json_agg(fch ORDER BY fch.forecast_date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.forecast_check_history
            WHERE stock_symbol = p_symbol
            ORDER BY forecast_date DESC
            LIMIT 10
        ) fch
    ),
    'recent_patterns', (
         SELECT COALESCE(json_agg(cp ORDER BY cp.date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.candle_patterns
            WHERE stock_symbol = p_symbol
            ORDER BY date DESC
            LIMIT 5
        ) cp
    ),
    'stock_summary', (
        SELECT sas.summary
        FROM public.stock_analysis_summaries sas
        WHERE sas.stock_symbol = p_symbol AND sas.date = (SELECT value FROM latest_indicator_date)
        LIMIT 1
    )
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_stock_details_page_data" has been enhanced to include the automated summary.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Manual Trigger UI Translations
-- #
-- # Purpose: This script adds all the translation keys needed for the new
-- # "Manual System Triggers" feature on the Dashboard page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'manual_system_triggers', 'Manual System Triggers'),
('ar', 'manual_system_triggers', 'مشغلات النظام اليدوية'),
('en', 'generate_daily_summaries', 'Generate Daily Analysis Summaries'),
('ar', 'generate_daily_summaries', 'إنشاء ملخصات التحليل اليومية'),
('en', 'generate_daily_summaries_desc', 'Manually runs the process that generates the rule-based "Quick Look" summary for all tracked stocks. This is normally automated to run once daily.'),
('ar', 'generate_daily_summaries_desc', 'يشغل يدويًا العملية التي تنشئ ملخص "نظرة سريعة" المستند إلى القواعد لجميع الأسهم المتعقبة. تعمل هذه العملية عادةً تلقائيًا مرة واحدة يوميًا.'),
('en', 'run_forecast_evaluation', 'Run Forecast Evaluation'),
('ar', 'run_forecast_evaluation', 'تشغيل تقييم التوقعات'),
('en', 'run_forecast_evaluation_desc', 'Manually runs the process that checks the latest forecasts against actual market data and saves the results. This is normally automated.'),
('ar', 'run_forecast_evaluation_desc', 'يشغل يدويًا العملية التي تتحقق من أحدث التوقعات مقابل بيانات السوق الفعلية وتحفظ النتائج. تعمل هذه العملية عادةً تلقائيًا.'),
('en', 'run_now', 'Run Now'),
('ar', 'run_now', 'تشغيل الآن'),
('en', 'running_process', 'Running process'),
('ar', 'running_process', 'جاري تشغيل العملية'),
('en', 'process_complete', 'Process Complete'),
('ar', 'process_complete', 'اكتملت العملية'),
('en', 'process_summary', 'Process Summary'),
('ar', 'process_summary', 'ملخص العملية'),
('en', 'processed_count', 'Processed'),
('ar', 'processed_count', 'تمت المعالجة'),
('en', 'errors_skipped', 'Errors / Skipped'),
('ar', 'errors_skipped', 'أخطاء / تم تخطيها'),
('en', 'evaluation_complete_message', 'Successfully evaluated {count} forecasts.'),
('ar', 'evaluation_complete_message', 'تم تقييم {count} توقع بنجاح.'),
('en', 'generation_complete_message', 'Summary generation complete.'),
('ar', 'generation_complete_message', 'اكتمل إنشاء الملخصات.'),
('en', 'close', 'Close'),
('ar', 'close', 'إغلاق'),
('en', 'process_failed', 'Process Failed'),
('ar', 'process_failed', 'فشلت العملية')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Remove All Gemini API Integration
-- #
-- # Purpose: This script completely removes all database objects and data
-- # related to the Gemini API integration, including the "Trader's Summary"
-- # feature. This follows a request to remove all usage of the Gemini API.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Unschedule and drop the daily cron job for summary generation.
-- The IF EXISTS is important so it doesn't fail if already removed.
SELECT cron.unschedule(job_name) FROM cron.job WHERE job_name = 'daily-trader-summary-generation';
RAISE NOTICE 'SUCCESS: Unscheduled the "daily-trader-summary-generation" cron job if it existed.';

-- Step 2: Drop all RPC functions related to the Gemini summary feature.
DROP FUNCTION IF EXISTS public.generate_and_cache_all_trader_summaries(date);
DROP FUNCTION IF EXISTS public.get_trader_summary(text, date);
DROP FUNCTION IF EXISTS public.save_trader_summary(text, date, text, text);
RAISE NOTICE 'SUCCESS: Dropped all RPC functions related to trader summaries.';

-- Step 3: Drop the table used to cache the summaries.
-- Using CASCADE to also remove any dependent objects.
DROP TABLE IF EXISTS public.trader_summaries CASCADE;
RAISE NOTICE 'SUCCESS: Dropped the "trader_summaries" table.';

-- Step 4: Delete all translation keys related to the feature.
DELETE FROM public.translations
WHERE key IN (
  'traders_summary',
  'generating_summary',
  'summary_generation_error',
  'not_enough_data_for_summary',
  'loading_summary',
  'summary_not_available_yet',
  'summary_fetch_error'
);
RAISE NOTICE 'SUCCESS: Deleted all translation keys related to the Trader''s Summary feature.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translations for Background Process Start
-- #
-- # Purpose: This script adds the UI translation keys needed to inform the
-- # user that a long-running manual process has started successfully in the
-- # background, improving the user experience for these tasks.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'process_started_title', 'Process Started'),
('ar', 'process_started_title', 'بدأت العملية'),
('en', 'process_started_message', 'The process has started in the background and may take a few minutes to complete. You can safely close this window.'),
('ar', 'process_started_message', 'بدأت العملية في الخلفية وقد تستغرق بضع دقائق حتى تكتمل. يمكنك إغلاق هذه النافذة بأمان.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for the background process start notification have been added.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Translations for Indicator Visuals
-- #
-- # Purpose: This script adds all the new translation keys needed for the
-- # redesigned, more visual technical indicator components on the Stock Details page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Moving Averages Card
('en', 'price_vs_sma_20', 'Price vs. 20-Day SMA'),
('ar', 'price_vs_sma_20', 'السعر مقابل متوسط 20 يوم'),
('en', 'price_vs_sma_50', 'Price vs. 50-Day SMA'),
('ar', 'price_vs_sma_50', 'السعر مقابل متوسط 50 يوم'),
('en', 'price_vs_sma_200', 'Price vs. 200-Day SMA'),
('ar', 'price_vs_sma_200', 'السعر مقابل متوسط 200 يوم'),

-- Volatility Card
('en', 'historical_volatility_20d', 'Historical Volatility (20D)'),
('ar', 'historical_volatility_20d', 'التقلب التاريخي (20 يومًا)'),
('en', 'atr_14', 'Average True Range (14)'),
('ar', 'atr_14', 'متوسط النطاق الحقيقي (14)'),

-- Stochastic Gauge
('en', 'percent_k', '%K'),
('ar', 'percent_k', '%K'),
('en', 'percent_d', '%D'),
('ar', 'percent_d', '%D'),
('en', 'stochastic_oscillator', 'Stochastic Oscillator'),
('ar', 'stochastic_oscillator', 'مذبذب ستوكاستيك'),


-- Bollinger Bands Viz
('en', 'price_above_band', 'Price is trading above the upper band.'),
('ar', 'price_above_band', 'السعر يتداول فوق النطاق العلوي.'),
('en', 'price_below_band', 'Price is trading below the lower band.'),
('ar', 'price_below_band', 'السعر يتداول أسفل النطاق السفلي.'),
('en', 'price_inside_bands', 'Price is trading within the bands.'),
('ar', 'price_inside_bands', 'السعر يتداول داخل النطاقات.'),
('en', 'bollinger_bands_20_2', 'Bollinger Bands (20, 2)'),
('ar', 'bollinger_bands_20_2', 'نطاقات بولينجر (20, 2)'),

-- MACD Viz
('en', 'macd_indicator_full', 'MACD (12, 26, 9)'),
('ar', 'macd_indicator_full', 'مؤشر الماكد (12, 26, 9)'),
('en', 'cross_status', 'Cross Status'),
('ar', 'cross_status', 'حالة التقاطع'),
('en', 'bullish_cross', 'Bullish Cross'),
('ar', 'bullish_cross', 'تقاطع صاعد'),
('en', 'bearish_cross', 'Bearish Cross'),
('ar', 'bearish_cross', 'تقاطع هابط'),
('en', 'no_cross', 'No Cross'),
('ar', 'no_cross', 'لا يوجد تقاطع')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for the visual indicator dashboard have been updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Enhance Stock Details Chart and Add Translations
-- #
-- # Purpose: This script updates the backend for the Stock Details page to
-- # support a new, more advanced historical chart. It increases the amount
-- # of forecast history data fetched and adds new translation keys.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Update the RPC function to fetch 15 days of forecast history, ordered ascending for charting.
CREATE OR REPLACE FUNCTION public.get_stock_details_page_data(p_symbol TEXT)
RETURNS json
LANGUAGE sql STABLE AS $$
SELECT json_build_object(
    'details', (SELECT row_to_json(s) FROM public.stocks s WHERE s.symbol = p_symbol),
    'next_forecast', (SELECT row_to_json(f) FROM public.forecasts f WHERE f.stock_symbol = p_symbol ORDER BY f.forecast_date DESC LIMIT 1),
    'historical_data', (SELECT COALESCE(json_agg(h ORDER BY h.date ASC), '[]'::json) FROM (SELECT * FROM public.historical_data WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 90) h),
    'latest_indicators', (SELECT row_to_json(ti) FROM public.technical_indicators ti WHERE ti.stock_symbol = p_symbol ORDER BY ti.date DESC LIMIT 1),
    'forecast_history', (
        SELECT COALESCE(json_agg(fch ORDER BY fch.forecast_date ASC), '[]'::json) -- Order ASC for charting
        FROM (
            SELECT * FROM public.forecast_check_history
            WHERE stock_symbol = p_symbol
            ORDER BY forecast_date DESC
            LIMIT 15 -- Increased from 10 to 15
        ) fch
    ),
    'recent_patterns', (SELECT COALESCE(json_agg(cp ORDER BY cp.date DESC), '[]'::json) FROM (SELECT * FROM public.candle_patterns WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 5) cp)
);
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_stock_details_page_data" updated to fetch 15 days of history.';

-- Step 2: Add translations for the chart and new indicator visuals.
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'not_enough_data_for_chart', 'Not enough data to display chart.'),
('ar', 'not_enough_data_for_chart', 'لا توجد بيانات كافية لعرض الرسم البياني.'),
('en', 'historical_performance_15d', 'Historical Performance (15-Day Range)'),
('ar', 'historical_performance_15d', 'الأداء التاريخي (نطاق 15 يومًا)'),
('en', 'actual_range', 'Actual Range'),
('ar', 'actual_range', 'النطاق الفعلي'),
('en', 'predicted_range', 'Predicted Range'),
('ar', 'predicted_range', 'النطاق المتوقع'),
('en', 'neutral_zone', 'Neutral'),
('ar', 'neutral_zone', 'محايد'),
('en', 'stochastic_oscillator', 'Stochastic Oscillator'),
('ar', 'stochastic_oscillator', 'مذبذب ستوكاستيك'),
('en', 'percent_k', '%K'),
('ar', 'percent_k', '%K'),
('en', 'percent_d', '%D'),
('ar', 'percent_d', '%D'),
('en', 'williams_percent_r', 'Williams %R'),
('ar', 'williams_percent_r', 'مؤشر ويليامز %R'),
('en', 'overbought_zone', 'Overbought Zone'),
('ar', 'overbought_zone', 'منطقة تشبع شرائي'),
('en', 'oversold_zone', 'Oversold Zone'),
('ar', 'oversold_zone', 'منطقة تشبع بيعي'),
('en', 'bollinger_bands_20_2', 'Bollinger Bands (20, 2)'),
('ar', 'bollinger_bands_20_2', 'نطاقات بولينجر (20, 2)'),
('en', 'lower_band', 'Lower'),
('ar', 'lower_band', 'السفلي'),
('en', 'middle_band', 'Middle'),
('ar', 'middle_band', 'الأوسط'),
('en', 'upper_band', 'Upper'),
('ar', 'upper_band', 'العلوي'),
('en', 'price_above_band', 'Price is Above Band'),
('ar', 'price_above_band', 'السعر فوق النطاق'),
('en', 'price_below_band', 'Price is Below Band'),
('ar', 'price_below_band', 'السعر تحت النطاق'),
('en', 'price_inside_bands', 'Price is Inside Bands'),
('ar', 'price_inside_bands', 'السعر داخل النطاق'),
('en', 'macd_indicator_full', 'MACD (12, 26, 9)'),
('ar', 'macd_indicator_full', 'مؤشر الماكد (12, 26, 9)'),
('en', 'cross_status', 'Cross Status'),
('ar', 'cross_status', 'حالة التقاطع'),
('en', 'bullish_cross', 'Bullish Cross'),
('ar', 'bullish_cross', 'تقاطع صاعد'),
('en', 'bearish_cross', 'Bearish Cross'),
('ar', 'bearish_cross', 'تقاطع هابط'),
('en', 'no_cross', 'No Cross'),
('ar', 'no_cross', 'لا يوجد تقاطع'),
('en', 'volatility_indicators', 'Volatility'),
('ar', 'volatility_indicators', 'التقلب'),
('en', 'historical_volatility_20d', 'Historical Volatility (20D)'),
('ar', 'historical_volatility_20d', 'التقلب التاريخي (20 يومًا)')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Added new translations for chart and indicator visuals.';

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Remove Gemini Analytics Feature
-- #
-- # Purpose: This script completely removes all database objects and data
-- # related to the Gemini Analytics feature, following a request to remove
-- # all usage of the Gemini API.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Delete the 'view:gemini_analytics' permission.
-- Deleting from the parent 'permissions' table will automatically cascade
-- and remove any corresponding entries in 'role_permissions'.
DELETE FROM public.permissions WHERE action = 'view:gemini_analytics';
RAISE NOTICE 'SUCCESS: Deleted "view:gemini_analytics" permission.';

-- Step 2: Delete all translation keys related to the Gemini Analytics feature.
DELETE FROM public.translations
WHERE key IN (
  'gemini_analytics',
  'perm_view_gemini_analytics',
  'perm_view_gemini_analytics_desc',
  'gemini_welcome_message',
  'ask_gemini_placeholder',
  'send',
  'gemini_api_error'
);
RAISE NOTICE 'SUCCESS: Deleted all translation keys related to the Gemini Analytics feature.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Watchlist Last Close Date
-- #
-- # Purpose: This script provides a definitive fix for the issue where the
-- # "Daily Watchlist" page displayed an incorrect date for the "Last Close".
-- # It updates the RPC function to select the actual `last_updated` timestamp
-- # from the stocks table, which is the reliable source of truth, instead of
-- # trying to calculate it.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Drop the existing function to allow for changing its return signature.
-- The empty parentheses are important to target the function without arguments.
DROP FUNCTION IF EXISTS public.get_daily_watchlist_data();

-- Recreate the function with the new `last_updated` column in its return table.
CREATE FUNCTION public.get_daily_watchlist_data()
RETURNS TABLE (
    symbol text,
    stock_name text,
    last_close real,
    last_updated timestamptz, -- ADD THIS COLUMN
    predicted_lo real,
    predicted_hi real,
    sma20 real,
    sma50 real,
    pattern_name text,
    bullish boolean,
    forecast_date date
)
LANGUAGE plpgsql STABLE
AS $$
DECLARE
    latest_forecast_date date;
    latest_indicator_date date;
BEGIN
    -- Find the latest date for which we have a forecast. This is for "tomorrow".
    SELECT max(f.forecast_date) INTO latest_forecast_date FROM public.forecasts f;

    -- Find the latest date for which we have indicators, which is "today" (the last closing day).
    SELECT max(ti.date) INTO latest_indicator_date FROM public.technical_indicators ti WHERE ti.date < latest_forecast_date;

    RETURN QUERY
    SELECT
        s.symbol,
        s.name AS stock_name,
        s.price AS last_close,
        s.last_updated, -- SELECT THE CORRECT DATE
        f.predicted_lo,
        f.predicted_hi,
        ti.sma20,
        ti.sma50,
        cp.pattern_name,
        cp.bullish,
        f.forecast_date
    FROM
        public.forecasts f
    JOIN
        public.stocks s ON f.stock_symbol = s.symbol
    LEFT JOIN
        public.technical_indicators ti ON f.stock_symbol = ti.stock_symbol AND ti.date = latest_indicator_date
    LEFT JOIN
        (
            -- Get only the first/most relevant pattern for the indicator date to avoid duplicate rows
            SELECT DISTINCT ON (cp_inner.stock_symbol) *
            FROM public.candle_patterns cp_inner
            WHERE cp_inner.date = latest_indicator_date
        ) cp ON f.stock_symbol = cp.stock_symbol
    WHERE
        f.forecast_date = latest_forecast_date
        AND s.is_tracked = true
    ORDER BY
        s.symbol;
END;
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_daily_watchlist_data" updated to include the correct last_updated date.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Next Day Forecast Logic
-- #
-- # Purpose: This script provides a definitive fix for potential inconsistencies
-- # in the "Next Day Forecast" display on the Stock Details page.
-- #
-- # It updates the `get_stock_details_page_data` function to be more robust.
-- # The new logic first finds the latest date with an evaluated result, and then
-- # selects the forecast for the day immediately following it. This ensures
-- # the "next" forecast is always relative to the last known data point.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.get_stock_details_page_data(p_symbol TEXT)
RETURNS json
LANGUAGE plpgsql STABLE AS $$
DECLARE
    latest_evaluated_date date;
    next_forecast_json json;
BEGIN
    -- Find the latest date we have evaluated results for this stock.
    SELECT max(fch.forecast_date) INTO latest_evaluated_date
    FROM public.forecast_check_history fch
    WHERE fch.stock_symbol = p_symbol;

    IF latest_evaluated_date IS NOT NULL THEN
        -- If we have history, find the very next forecast after that date.
        SELECT row_to_json(f) INTO next_forecast_json
        FROM public.forecasts f
        WHERE f.stock_symbol = p_symbol AND f.forecast_date > latest_evaluated_date
        ORDER BY f.forecast_date ASC
        LIMIT 1;
    ELSE
        -- If there's no history (new stock), just get the latest forecast available.
        SELECT row_to_json(f) INTO next_forecast_json
        FROM public.forecasts f
        WHERE f.stock_symbol = p_symbol
        ORDER BY f.forecast_date DESC
        LIMIT 1;
    END IF;

    RETURN json_build_object(
        'details', (SELECT row_to_json(s) FROM public.stocks s WHERE s.symbol = p_symbol),
        'next_forecast', next_forecast_json,
        'historical_data', (SELECT COALESCE(json_agg(h ORDER BY h.date ASC), '[]'::json) FROM (SELECT * FROM public.historical_data WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 90) h),
        'latest_indicators', (SELECT row_to_json(ti) FROM public.technical_indicators ti WHERE ti.stock_symbol = p_symbol ORDER BY ti.date DESC LIMIT 1),
        'forecast_history', (
            SELECT COALESCE(json_agg(fch ORDER BY fch.forecast_date ASC), '[]'::json)
            FROM (
                SELECT * FROM public.forecast_check_history
                WHERE stock_symbol = p_symbol
                ORDER BY forecast_date DESC
                LIMIT 15
            ) fch
        ),
        'recent_patterns', (SELECT COALESCE(json_agg(cp ORDER BY cp.date DESC), '[]'::json) FROM (SELECT * FROM public.candle_patterns WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 5) cp)
    );
END;
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_stock_details_page_data" updated with more robust "next forecast" logic.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Simplify Next Day Forecast Logic
-- #
-- # Purpose: This script simplifies and corrects the logic for determining the
-- # "Next Day Forecast" on the Stock Details page, as per user feedback.
-- #
-- # The function now uses the `historical_data` table as the direct source
-- # of truth for the last closing day, which is simpler and more robust than
-- # the previous implementation that used `forecast_check_history`.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.get_stock_details_page_data(p_symbol TEXT)
RETURNS json
LANGUAGE plpgsql STABLE AS $$
DECLARE
    latest_historical_date date;
    next_forecast_json json;
BEGIN
    -- Step 1: Find the latest date we have actual closing data for this stock from the definitive source.
    SELECT max(hd.date) INTO latest_historical_date
    FROM public.historical_data hd
    WHERE hd.stock_symbol = p_symbol;

    IF latest_historical_date IS NOT NULL THEN
        -- Step 2: If we have historical data, find the very next forecast *after* that date.
        SELECT row_to_json(f) INTO next_forecast_json
        FROM public.forecasts f
        WHERE f.stock_symbol = p_symbol AND f.forecast_date > latest_historical_date
        ORDER BY f.forecast_date ASC -- Get the first one after the last known date
        LIMIT 1;
    ELSE
        -- Step 3: If there's no history (e.g., a new stock), get the earliest forecast available.
        SELECT row_to_json(f) INTO next_forecast_json
        FROM public.forecasts f
        WHERE f.stock_symbol = p_symbol
        ORDER BY f.forecast_date ASC -- Get the very first forecast for this new stock
        LIMIT 1;
    END IF;

    -- The rest of the function remains the same, returning all necessary data for the page.
    RETURN json_build_object(
        'details', (SELECT row_to_json(s) FROM public.stocks s WHERE s.symbol = p_symbol),
        'next_forecast', next_forecast_json,
        'historical_data', (SELECT COALESCE(json_agg(h ORDER BY h.date ASC), '[]'::json) FROM (SELECT * FROM public.historical_data WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 90) h),
        'latest_indicators', (SELECT row_to_json(ti) FROM public.technical_indicators ti WHERE ti.stock_symbol = p_symbol ORDER BY ti.date DESC LIMIT 1),
        'forecast_history', (
            SELECT COALESCE(json_agg(fch ORDER BY fch.forecast_date ASC), '[]'::json)
            FROM (
                SELECT * FROM public.forecast_check_history
                WHERE stock_symbol = p_symbol
                ORDER BY forecast_date DESC
                LIMIT 15
            ) fch
        ),
        'recent_patterns', (SELECT COALESCE(json_agg(cp ORDER BY cp.date DESC), '[]'::json) FROM (SELECT * FROM public.candle_patterns WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 5) cp)
    );
END;
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_stock_details_page_data" updated with simpler, more direct "next forecast" logic.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Final Simplification of Next Day Forecast Logic
-- #
-- # Purpose: This script implements the user's final, direct instruction for
-- # determining the "Next Day Forecast" on the Stock Details page.
-- #
-- # The function now uses the absolute simplest logic: it fetches the single
-- # most recent forecast from the `forecasts` table for the given stock.
-- # This removes all previous complex logic involving date comparisons with
-- # other tables.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.get_stock_details_page_data(p_symbol TEXT)
RETURNS json
LANGUAGE sql STABLE AS $$
-- This pure SQL function is simpler and more efficient.
SELECT json_build_object(
    'details', (
        -- Fetches details from the stocks table (satisfies "last closing date from stocks table")
        SELECT row_to_json(s) FROM public.stocks s WHERE s.symbol = p_symbol
    ),
    'next_forecast', (
        -- Fetches the absolute latest forecast for the stock from the forecasts table.
        SELECT row_to_json(f)
        FROM public.forecasts f
        WHERE f.stock_symbol = p_symbol
        ORDER BY f.forecast_date DESC
        LIMIT 1
    ),
    'historical_data', (
        -- No change here, fetches historical data for the chart.
        SELECT COALESCE(json_agg(h ORDER BY h.date ASC), '[]'::json) FROM (SELECT * FROM public.historical_data WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 90) h
    ),
    'latest_indicators', (
        -- No change here, fetches the most recent indicators.
        SELECT row_to_json(ti) FROM public.technical_indicators ti WHERE ti.stock_symbol = p_symbol ORDER BY ti.date DESC LIMIT 1
    ),
    'forecast_history', (
        -- Fetches results from the forecast check history table, as requested.
        SELECT COALESCE(json_agg(fch ORDER BY fch.forecast_date ASC), '[]'::json)
        FROM (
            SELECT * FROM public.forecast_check_history
            WHERE stock_symbol = p_symbol
            ORDER BY forecast_date DESC
            LIMIT 15
        ) fch
    ),
    'recent_patterns', (
        -- No change here, fetches recent candle patterns.
        SELECT COALESCE(json_agg(cp ORDER BY cp.date DESC), '[]'::json) FROM (SELECT * FROM public.candle_patterns WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 5) cp
    )
);
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_stock_details_page_data" updated with the final, simplest "next forecast" logic.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Stock Details Forecast History Sort Order
-- #
-- # Purpose: This script updates the `get_stock_details_page_data` function
-- # to sort the forecast history results from newest to oldest, as requested
-- # by the user. This ensures the latest records appear at the top of the table.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.get_stock_details_page_data(p_symbol TEXT)
RETURNS json
LANGUAGE sql STABLE AS $$
-- This pure SQL function is simpler and more efficient.
SELECT json_build_object(
    'details', (
        -- Fetches details from the stocks table (satisfies "last closing date from stocks table")
        SELECT row_to_json(s) FROM public.stocks s WHERE s.symbol = p_symbol
    ),
    'next_forecast', (
        -- Fetches the absolute latest forecast for the stock from the forecasts table.
        SELECT row_to_json(f)
        FROM public.forecasts f
        WHERE f.stock_symbol = p_symbol
        ORDER BY f.forecast_date DESC
        LIMIT 1
    ),
    'historical_data', (
        -- No change here, fetches historical data for the chart.
        SELECT COALESCE(json_agg(h ORDER BY h.date ASC), '[]'::json) FROM (SELECT * FROM public.historical_data WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 90) h
    ),
    'latest_indicators', (
        -- No change here, fetches the most recent indicators.
        SELECT row_to_json(ti) FROM public.technical_indicators ti WHERE ti.stock_symbol = p_symbol ORDER BY ti.date DESC LIMIT 1
    ),
    'forecast_history', (
        -- Fetches results from the forecast check history table, sorted DESCENDING.
        SELECT COALESCE(json_agg(fch ORDER BY fch.forecast_date DESC), '[]'::json)
        FROM (
            SELECT * FROM public.forecast_check_history
            WHERE stock_symbol = p_symbol
            ORDER BY forecast_date DESC
            LIMIT 15
        ) fch
    ),
    'recent_patterns', (
        -- No change here, fetches recent candle patterns.
        SELECT COALESCE(json_agg(cp ORDER BY cp.date DESC), '[]'::json) FROM (SELECT * FROM public.candle_patterns WHERE stock_symbol = p_symbol ORDER BY date DESC LIMIT 5) cp
    )
);
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_stock_details_page_data" updated to sort forecast history from newest to oldest.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add User Favorites System for Stocks
-- #
-- # Purpose: This script introduces the full backend system for allowing
-- # users to "favorite" stocks.
-- #
-- # It performs three key actions:
-- # 1. Creates a new `user_favorite_stocks` table to store the relationship
-- #    between users and their favorited stock symbols.
-- # 2. Sets up Row Level Security (RLS) to ensure users can only access and
-- #    modify their own favorites.
-- # 3. Creates two RPC functions (`get_user_favorite_stocks` and `toggle_favorite_stock`)
-- #    for the client application to securely interact with the favorites data.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the user_favorite_stocks table.
CREATE TABLE IF NOT EXISTS public.user_favorite_stocks (
  user_id uuid NOT NULL,
  stock_symbol text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT user_favorite_stocks_pkey PRIMARY KEY (user_id, stock_symbol),
  CONSTRAINT user_favorite_stocks_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE,
  CONSTRAINT user_favorite_stocks_stock_symbol_fkey FOREIGN KEY (stock_symbol) REFERENCES stocks(symbol) ON DELETE CASCADE
);
COMMENT ON TABLE public.user_favorite_stocks IS 'Stores the stocks that a user has marked as their favorite.';
RAISE NOTICE 'SUCCESS: Table "user_favorite_stocks" created or already exists.';


-- Step 2: Set up Row Level Security (RLS) on the new table.
ALTER TABLE public.user_favorite_stocks ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users full control (SELECT, INSERT, DELETE) over their own favorite entries.
-- A user should never be able to see or modify another user's favorites.
DROP POLICY IF EXISTS "Allow users full access to their own favorites" ON public.user_favorite_stocks;
CREATE POLICY "Allow users full access to their own favorites"
    ON public.user_favorite_stocks FOR ALL
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

RAISE NOTICE 'SUCCESS: RLS policies for "user_favorite_stocks" created or updated.';


-- Step 3: Create an RPC function to GET the current user's favorite stock symbols.
CREATE OR REPLACE FUNCTION public.get_user_favorite_stocks()
RETURNS TABLE (stock_symbol text)
LANGUAGE sql STABLE
SECURITY DEFINER
SET search_path = public, auth
AS $$
  SELECT ufs.stock_symbol
  FROM public.user_favorite_stocks ufs
  WHERE ufs.user_id = auth.uid();
$$;
RAISE NOTICE 'SUCCESS: RPC function "get_user_favorite_stocks" created or updated.';


-- Step 4: Create an RPC function to toggle a stock's favorite status for the current user.
CREATE OR REPLACE FUNCTION public.toggle_favorite_stock(p_symbol text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
BEGIN
  -- Check if the entry already exists for the current user and the given symbol.
  IF EXISTS (SELECT 1 FROM public.user_favorite_stocks WHERE user_id = auth.uid() AND stock_symbol = p_symbol) THEN
    -- If it exists, DELETE it.
    DELETE FROM public.user_favorite_stocks WHERE user_id = auth.uid() AND stock_symbol = p_symbol;
  ELSE
    -- If it does not exist, INSERT it.
    INSERT INTO public.user_favorite_stocks (user_id, stock_symbol)
    VALUES (auth.uid(), p_symbol);
  END IF;
END;
$$;
RAISE NOTICE 'SUCCESS: RPC function "toggle_favorite_stock" created or updated.';

-- Step 5: Add required translations for the new feature
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'favorites_filter', 'Favorites'),
('ar', 'favorites_filter', 'المفضلة'),
('en', 'add_to_favorites', 'Add to favorites'),
('ar', 'add_to_favorites', 'إضافة إلى المفضلة'),
('en', 'remove_from_favorites', 'Remove from favorites'),
('ar', 'remove_from_favorites', 'إزالة من المفضلة')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Definitive Fix for Hanging "Save" Button in Settings
-- #
-- # Purpose: This script provides a definitive server-side fix for the issue
-- # where the "Save" button on the Dashboard's settings page would hang
-- # indefinitely. The root cause is invisible null characters (`\u0000`)
-- # pasted into text fields, which cause PostgreSQL to fail silently.
-- #
-- # This script creates a trigger that automatically sanitizes the `value`
-- # field on the `app_settings` table BEFORE any insert or update,
-- # ensuring no invalid characters can cause the operation to hang.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the trigger function to sanitize the `value` text field.
CREATE OR REPLACE FUNCTION public.sanitize_app_settings_value()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    -- If the 'value' column is being updated and is not NULL,
    -- replace any null characters (chr(0)) with an empty string.
    IF NEW.value IS NOT NULL THEN
        NEW.value := replace(NEW.value, chr(0), '');
    END IF;

    RETURN NEW;
END;
$$;
RAISE NOTICE 'SUCCESS: Sanitization function for app_settings created or updated.';


-- Step 2: Create the trigger that executes the function before any write operation.
DROP TRIGGER IF EXISTS tr_sanitize_app_settings ON public.app_settings;
CREATE TRIGGER tr_sanitize_app_settings
  BEFORE INSERT OR UPDATE ON public.app_settings
  FOR EACH ROW EXECUTE PROCEDURE public.sanitize_app_settings_value();

RAISE NOTICE 'SUCCESS: Trigger to sanitize app_settings has been applied. The save issue is now definitively fixed.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add "Signing Out..." Translation
-- #
-- # Purpose: This script adds the UI translation key required to show a
-- # loading state on the "Sign Out" button, improving user feedback.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'signing_out', 'Signing Out'),
('ar', 'signing_out', 'جاري تسجيل الخروج')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Definitive Fix for Announcements Save Button Hang
-- #
-- # Purpose: This script provides a final, robust server-side fix for the issue
-- # where the "Save" button on the Announcements modal would hang indefinitely.
-- # The root cause is invisible null characters (`\u0000`) being pasted into
-- # text fields, which cause PostgreSQL's JSONB processing to fail silently.
-- #
-- # This script replaces any previous sanitization attempts with a trigger
-- # that unpacks the JSONB objects, sanitizes each text value individually
-- # using `chr(0)`, and then rebuilds the JSONB object before saving. This is
-- # the most reliable method to handle this issue.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the robust trigger function to sanitize the JSONB fields.
CREATE OR REPLACE FUNCTION public.sanitize_announcement_jsonb()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
    sanitized_title JSONB;
    sanitized_message JSONB;
    rec RECORD;
BEGIN
    -- Sanitize the 'title' JSONB field if it's not NULL.
    IF NEW.title IS NOT NULL THEN
        sanitized_title := '{}'::jsonb;
        FOR rec IN SELECT * FROM jsonb_each_text(NEW.title) LOOP
            -- Use chr(0) to represent the null character, which is the most reliable way in PostgreSQL.
            sanitized_title := sanitized_title || jsonb_build_object(rec.key, replace(rec.value, chr(0), ''));
        END LOOP;
        NEW.title := sanitized_title;
    END IF;

    -- Sanitize the 'message' JSONB field if it's not NULL.
    IF NEW.message IS NOT NULL THEN
        sanitized_message := '{}'::jsonb;
        FOR rec IN SELECT * FROM jsonb_each_text(NEW.message) LOOP
            sanitized_message := sanitized_message || jsonb_build_object(rec.key, replace(rec.value, chr(0), ''));
        END LOOP;
        NEW.message := sanitized_message;
    END IF;

    RETURN NEW;
END;
$$;
RAISE NOTICE 'SUCCESS: Robust sanitization function for announcements created or updated.';


-- Step 2: Ensure the trigger is attached and active.
DROP TRIGGER IF EXISTS tr_sanitize_announcement_jsonb ON public.global_announcements;
CREATE TRIGGER tr_sanitize_announcement_jsonb
  BEFORE INSERT OR UPDATE ON public.global_announcements
  FOR EACH ROW EXECUTE PROCEDURE public.sanitize_announcement_jsonb();

RAISE NOTICE 'SUCCESS: Trigger to sanitize announcements has been applied. The save issue is now definitively fixed.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Definitive Fix for Announcements Save Button Hang (Final)
-- #
-- # Purpose: This script provides a final, robust server-side fix for the
-- # "null character not permitted" error that occurs when saving announcements.
-- # The root cause is invisible null characters (\u0000) being pasted into
-- # text fields, which cause PostgreSQL's JSONB processing to fail silently.
-- #
-- # This script replaces any previous sanitization attempts with a trigger
-- # that casts the entire JSONB object to text, performs a global replace of
-- # the null character's string representation, and then casts it back. This
-- # is more reliable than iterating over individual keys.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create the robust trigger function to sanitize the JSONB fields.
CREATE OR REPLACE FUNCTION public.sanitize_announcement_jsonb()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    -- Sanitize the 'title' JSONB field by casting to text, replacing the
    -- JSON escape sequence for a null character ('\u0000'), and casting back.
    IF NEW.title IS NOT NULL THEN
        NEW.title := replace(NEW.title::text, '\u0000', '')::jsonb;
    END IF;

    -- Do the same for the 'message' JSONB field.
    IF NEW.message IS NOT NULL THEN
        NEW.message := replace(NEW.message::text, '\u0000', '')::jsonb;
    END IF;

    RETURN NEW;
END;
$$;
RAISE NOTICE 'SUCCESS: Robust sanitization function for announcements created or updated.';


-- Step 2: Ensure the trigger is attached and active.
DROP TRIGGER IF EXISTS tr_sanitize_announcement_jsonb ON public.global_announcements;
CREATE TRIGGER tr_sanitize_announcement_jsonb
  BEFORE INSERT OR UPDATE ON public.global_announcements
  FOR EACH ROW EXECUTE PROCEDURE public.sanitize_announcement_jsonb();

RAISE NOTICE 'SUCCESS: Trigger to sanitize announcements has been applied. The save issue is now definitively fixed.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translation Edit UI Labels
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # "before and after" editing view on the Translation Management page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'original_value', 'Original'),
('ar', 'original_value', 'الأصلي'),
('en', 'new_value', 'New Value'),
('ar', 'new_value', 'القيمة الجديدة')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Activity Log "Before/After" Translations
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # "Summary", "Before", and "After" columns on the Activity Log page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'summary', 'Summary'),
('ar', 'summary', 'ملخص'),
('en', 'data_before', 'Before'),
('ar', 'data_before', 'قبل'),
('en', 'data_after', 'After'),
('ar', 'data_after', 'بعد')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Activity Log Summary Translations
-- #
-- # Purpose: This script adds the UI translation keys required to translate
-- # the dynamic summary descriptions in the Activity Log.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- User Role Changed
('en', 'log_summary_USER_ROLE_CHANGED', 'Changed role for user {email}.'),
('ar', 'log_summary_USER_ROLE_CHANGED', 'تم تغيير دور المستخدم {email}.'),

-- Permission Added to Role
('en', 'log_summary_ROLE_PERMISSION_ADDED', 'Granted permission "{permission_action}" to role "{role_name}".'),
('ar', 'log_summary_ROLE_PERMISSION_ADDED', 'تم منح صلاحية "{permission_action}" للدور "{role_name}".'),

-- Permission Removed from Role
('en', 'log_summary_ROLE_PERMISSION_REMOVED', 'Revoked permission "{permission_action}" from role "{role_name}".'),
('ar', 'log_summary_ROLE_PERMISSION_REMOVED', 'تم سحب صلاحية "{permission_action}" من الدور "{role_name}".'),

-- App Setting Changed
('en', 'log_summary_APP_SETTING_CHANGED', 'Updated setting "{setting_key}".'),
('ar', 'log_summary_APP_SETTING_CHANGED', 'تم تحديث الإعداد "{setting_key}".'),

-- User Created
('en', 'log_summary_USER_CREATED', 'New user account created for {email}.'),
('ar', 'log_summary_USER_CREATED', 'تم إنشاء حساب مستخدم جديد لـ {email}.'),

-- User Login Success
('en', 'log_summary_USER_LOGIN_SUCCESS', 'User {email} successfully logged in.'),
('ar', 'log_summary_USER_LOGIN_SUCCESS', 'تم تسجيل دخول المستخدم {email} بنجاح.')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add "Clear Activity Log" Feature
-- #
-- # Purpose: This script adds the backend infrastructure for an admin to
-- # clear all entries from the activity log table.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Add the new permission.
INSERT INTO public.permissions (action, description)
VALUES ('truncate:activity_log', 'Can permanently delete all entries from the activity log.')
ON CONFLICT (action) DO UPDATE SET description = EXCLUDED.description;
RAISE NOTICE 'SUCCESS: Permission "truncate:activity_log" added or updated.';

-- Step 2: Assign the permission to the Admin role.
DO $$
DECLARE
    admin_role_id UUID;
    truncate_perm_id UUID;
BEGIN
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'Admin';
    SELECT id INTO truncate_perm_id FROM public.permissions WHERE action = 'truncate:activity_log';

    IF admin_role_id IS NOT NULL AND truncate_perm_id IS NOT NULL THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, truncate_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
    END IF;
END $$;
RAISE NOTICE 'SUCCESS: Assigned "truncate:activity_log" permission to Admin role.';

-- Step 3: Create the RPC function to perform the truncation.
CREATE OR REPLACE FUNCTION public.truncate_activity_logs()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
BEGIN
  -- Security Check: Only allow authorized users to run this.
  IF NOT public.has_permission('truncate:activity_log') THEN
    RAISE EXCEPTION 'Insufficient permissions: You need the "truncate:activity_log" permission.';
  END IF;

  -- Perform the privileged action.
  TRUNCATE TABLE public.activity_logs RESTART IDENTITY;
END;
$$;
RAISE NOTICE 'SUCCESS: RPC function "truncate_activity_logs" created.';

-- Step 4: Add UI translations.
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'clear_log', 'Clear Log'),
('ar', 'clear_log', 'مسح السجل'),
('en', 'confirm_clear_log', 'Are you sure you want to permanently delete all activity logs? This action cannot be undone.'),
('ar', 'confirm_clear_log', 'هل أنت متأكد من رغبتك في حذف جميع سجلات الأنشطة نهائيًا؟ لا يمكن التراجع عن هذا الإجراء.'),
('en', 'log_cleared_successfully', 'Activity log has been cleared successfully.'),
('ar', 'log_cleared_successfully', 'تم مسح سجل الأنشطة بنجاح.'),
('en', 'log_clear_failed', 'Failed to clear the activity log.'),
('ar', 'log_clear_failed', 'فشل مسح سجل الأنشطة.'),
('en', 'perm_truncate_activity_log', 'Clear Activity Log'),
('ar', 'perm_truncate_activity_log', 'مسح سجل الأنشطة'),
('en', 'perm_truncate_activity_log_desc', 'Can permanently delete all entries from the activity log.'),
('ar', 'perm_truncate_activity_log_desc', 'يمكنه حذف جميع الإدخالات من سجل الأنشطة بشكل دائم.')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;
RAISE NOTICE 'SUCCESS: Added translations for the clear log feature.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add "Archive & Clear Activity Log" Feature
-- #
-- # Purpose: This script replaces the simple "truncate" functionality with a
-- # more robust, multi-step archive and delete process.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Drop the old "truncate_activity_logs" function as it's being replaced.
DROP FUNCTION IF EXISTS public.truncate_activity_logs();
RAISE NOTICE 'SUCCESS: Dropped old "truncate_activity_logs" function.';


-- Step 2: Create a function to EXPORT logs older than a specified period.
CREATE OR REPLACE FUNCTION public.export_activity_logs(p_older_than_months integer)
RETURNS TABLE(file_content text, record_count integer)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
    cutoff_date timestamptz;
    log_record record;
    formatted_log text;
    header_text text;
BEGIN
    IF NOT public.has_permission('truncate:activity_log') THEN
        RAISE EXCEPTION 'Insufficient permissions';
    END IF;

    cutoff_date := now() - (p_older_than_months * interval '1 month');
    
    header_text := format(
        'Activity Log Archive%s'
        '========================================%s'
        'Generated On: %s%s'
        'Period: Older than %s month(s)%s'
        'Cutoff Date: %s%s%s',
        E'\n', E'\n', now()::text, E'\n', p_older_than_months, E'\n', cutoff_date::text, E'\n', E'\n'
    );
    
    file_content := header_text;
    record_count := 0;

    FOR log_record IN
        SELECT
            al.id,
            al.created_at,
            COALESCE(p.full_name, 'System') as user_full_name,
            COALESCE(p.email, 'N/A') as user_email,
            al.action,
            al.ip_address,
            al.details
        FROM public.activity_logs al
        LEFT JOIN public.profiles p ON al.user_id = p.id
        WHERE al.created_at < cutoff_date
        ORDER BY al.created_at ASC
    LOOP
        formatted_log := format(
            E'----------------------------------------\n' ||
            'Log ID:     %s\n' ||
            'Date:       %s\n' ||
            'User:       %s (%s)\n' ||
            'IP Address: %s\n' ||
            'Action:     %s\n' ||
            'Details:\n%s\n\n',
            log_record.id,
            log_record.created_at,
            log_record.user_full_name,
            log_record.user_email,
            COALESCE(log_record.ip_address::text, 'N/A'),
            log_record.action,
            jsonb_pretty(log_record.details)
        );
        file_content := file_content || formatted_log;
        record_count := record_count + 1;
    END LOOP;

    RETURN NEXT;
END;
$$;
RAISE NOTICE 'SUCCESS: RPC function "export_activity_logs" created.';


-- Step 3: Create a function to DELETE logs older than a specified period.
CREATE OR REPLACE FUNCTION public.delete_activity_logs(p_older_than_months integer)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
    deleted_count integer;
    cutoff_date timestamptz;
BEGIN
    IF NOT public.has_permission('truncate:activity_log') THEN
        RAISE EXCEPTION 'Insufficient permissions';
    END IF;
    
    cutoff_date := now() - (p_older_than_months * interval '1 month');

    WITH deleted AS (
        DELETE FROM public.activity_logs
        WHERE created_at < cutoff_date
        RETURNING id
    )
    SELECT count(*) INTO deleted_count FROM deleted;
    
    RETURN deleted_count;
END;
$$;
RAISE NOTICE 'SUCCESS: RPC function "delete_activity_logs" created.';

-- Step 4: Add UI translations for the new feature.
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'archive_and_clear', 'Archive & Clear'),
('ar', 'archive_and_clear', 'أرشفة ومسح'),
('en', 'archive_and_clear_log', 'Archive & Clear Activity Log'),
('ar', 'archive_and_clear_log', 'أرشفة ومسح سجل الأنشطة'),
('en', 'archive_period_select_desc', 'This tool will generate a text file archive of old records and then permanently delete them. Select a time period to begin.'),
('ar', 'archive_period_select_desc', 'ستقوم هذه الأداة بإنشاء أرشيف نصي للسجلات القديمة ثم حذفها بشكل دائم. حدد فترة زمنية للبدء.'),
('en', 'older_than_1_month', 'Older than 1 month'),
('ar', 'older_than_1_month', 'أقدم من شهر واحد'),
('en', 'older_than_x_months', 'Older than {count} months'),
('ar', 'older_than_x_months', 'أقدم من {count} أشهر'),
('en', 'generate_archive', 'Generate Archive'),
('ar', 'generate_archive', 'إنشاء الأرشيف'),
('en', 'archive_downloaded', 'Archive Downloaded'),
('ar', 'archive_downloaded', 'تم تنزيل الأرشيف'),
('en', 'archive_download_confirm_desc', 'An archive of {count} records has been downloaded to your computer. Are you sure you want to permanently delete these records from the database? This action cannot be undone.'),
('ar', 'archive_download_confirm_desc', 'تم تنزيل أرشيف يحتوي على {count} سجل إلى جهاز الكمبيوتر الخاص بك. هل أنت متأكد من رغبتك في حذف هذه السجلات بشكل دائم من قاعدة البيانات؟ لا يمكن التراجع عن هذا الإجراء.'),
('en', 'delete_records_confirm', 'Yes, Delete {count} Records'),
('ar', 'delete_records_confirm', 'نعم، حذف {count} سجلات'),
('en', 'archive_generation_failed', 'Failed to generate archive'),
('ar', 'archive_generation_failed', 'فشل إنشاء الأرشيف'),
('en', 'deletion_failed', 'Deletion failed'),
('ar', 'deletion_failed', 'فشل الحذف'),
('en', 'log_archived_and_deleted', 'Logs have been successfully archived and deleted.'),
('ar', 'log_archived_and_deleted', 'تم أرشفة وحذف السجلات بنجاح.'),
('en', 'no_logs_to_archive_for_period', 'There are no logs in the selected period to archive.'),
('ar', 'no_logs_to_archive_for_period', 'لا توجد سجلات في الفترة المحددة للأرشفة.')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Remove old, now-unused translations.
DELETE FROM public.translations WHERE key IN ('clear_log', 'confirm_clear_log', 'log_cleared_successfully', 'log_clear_failed');

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;
RAISE NOTICE 'SUCCESS: Added translations for the archive and clear feature.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add PWA "Add to Home Screen" Translations
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # "Add to Home Screen" prompt for PWA installation on mobile devices.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'a2hs_ios_prompt_1', 'To install, tap'),
('ar', 'a2hs_ios_prompt_1', 'للتثبيت، اضغط'),
('en', 'a2hs_ios_prompt_2', 'then'),
('ar', 'a2hs_ios_prompt_2', 'ثم'),
('en', 'add_to_home_screen', 'Add to Home Screen'),
('ar', 'add_to_home_screen', 'إضافة إلى الشاشة الرئيسية'),
('en', 'a2hs_android_prompt', 'Add this app to your home screen for a better experience.'),
('ar', 'a2hs_android_prompt', 'أضف هذا التطبيق إلى شاشتك الرئيسية لتجربة أفضل.')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Site Title Fetching Error
-- #
-- # Purpose: This script provides a definitive fix for the "Error fetching site
-- # titles" issue seen on the dashboard. The error was likely caused by the
-- # `get_translations_for_key` function not having sufficient privileges to
-- # bypass RLS when called from the client.
-- #
-- # This script modifies the function to run with `SECURITY DEFINER`, allowing
-- # it to reliably fetch the required translation keys regardless of the
-- # calling user's RLS context. This is a safe and standard pattern for
-- # controlled data access functions.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.get_translations_for_key(p_key TEXT)
RETURNS SETOF public.translations
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT id, lang_id, key, value
  FROM public.translations
  WHERE key = p_key AND (lang_id = 'en' OR lang_id = 'ar');
$$;

RAISE NOTICE 'SUCCESS: The "get_translations_for_key" function has been updated with SECURITY DEFINER to fix fetching errors.';

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Google Sign-In UI Translations
-- #
-- # Purpose: This script adds the UI translation keys required for the new
-- # "Sign in with Google" feature.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'sign_in_with_google', 'Sign in with Google'),
('ar', 'sign_in_with_google', 'تسجيل الدخول باستخدام جوجل'),
('en', 'sign_up_with_google', 'Sign up with Google'),
('ar', 'sign_up_with_google', 'التسجيل باستخدام جوجل'),
('en', 'or_separator', 'OR'),
('ar', 'or_separator', 'أو'),
('en', 'login_with_email', 'Login with Email'),
('ar', 'login_with_email', 'الدخول بالبريد الإلكتروني'),
('en', 'sign_in', 'Sign In'),
('ar', 'sign_in', 'دخول'),
('en', 'google_sign_in_failed', 'Google sign-in failed. Please try again.'),
('ar', 'google_sign_in_failed', 'فشل تسجيل الدخول باستخدام جوجل. يرجى المحاولة مرة أخرى.')
ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for Google Sign-In have been added.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Google OAuth Role Assignment (Definitive Fix)
-- #
-- # Purpose: This script provides a definitive fix for the issue where users
-- # signing up with Google were not assigned a default 'User' role.
-- #
-- # The previous `handle_new_user` trigger had a subtle logic flaw. This
-- # updated version is more robust:
-- # 1. It uses `INSERT ... ON CONFLICT` to prevent errors if a profile record
-- #    already exists for the new user's ID.
-- # 2. It explicitly checks if the new user's profile is missing a role_id
-- #    and assigns the default 'User' role, ensuring all new users (including
-- #    those from OAuth providers) are correctly configured.
-- # 3. It gracefully handles different name fields from OAuth providers.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = auth, public
AS $$
DECLARE
  user_count integer;
  target_role_id uuid;
  v_full_name TEXT;
BEGIN
  -- 1. Safely create the profile if it doesn't exist.
  -- Use COALESCE to gracefully handle different name fields from OAuth providers.
  v_full_name := COALESCE(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name');
  
  INSERT INTO public.profiles (id, full_name, email)
  VALUES (new.id, v_full_name, new.email)
  ON CONFLICT (id) DO NOTHING;

  -- 2. Determine which role to assign.
  SELECT count(*) INTO user_count FROM auth.users;

  IF user_count = 1 THEN
    -- First user ever gets Admin role.
    RAISE NOTICE 'First user signing up. Assigning Admin role.';
    SELECT id INTO target_role_id FROM public.roles WHERE name = 'Admin';
  ELSE
    -- Subsequent users get the default 'User' role.
    RAISE NOTICE 'New user signing up. Assigning default User role.';
    SELECT id INTO target_role_id FROM public.roles WHERE name = 'User';
  END IF;

  -- 3. Assign the determined role, but ONLY if the user doesn't already have one.
  -- This is the crucial part that ensures a role is assigned to new OAuth users.
  IF target_role_id IS NOT NULL THEN
    UPDATE public.profiles
    SET role_id = target_role_id
    WHERE id = new.id AND role_id IS NULL; -- Only update if role_id is currently NULL
  ELSE
     RAISE WARNING 'Could not find a suitable role (Admin or User) to assign to the new user %.', new.id;
  END IF;
  
  -- 4. Auto-confirm the user's email so they can log in immediately.
  -- This part remains unchanged and is important.
  UPDATE auth.users
  SET email_confirmed_at = now()
  WHERE id = new.id;

  -- Also log the user creation event
  PERFORM public.log_activity(new.id, 'USER_CREATED', jsonb_build_object('user_id', new.id, 'email', new.email));

  RETURN new;
END;
$$;

RAISE NOTICE 'SUCCESS: The "handle_new_user" trigger has been updated to robustly assign roles to OAuth users.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Overhaul Daily Watchlist to "The Coming Trend"
-- #
-- # Purpose: This script replaces the backend for the "Daily Watchlist" page
-- # to support a complete redesign into "The Coming Trend", fetching detailed
-- # forecast and indicator data as requested.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Drop the old, now-obsolete function.
DROP FUNCTION IF EXISTS public.get_daily_watchlist_data();

-- Step 2: Create the new, powerful RPC function to gather all data in one call.
CREATE OR REPLACE FUNCTION public.get_the_coming_trend_data()
RETURNS TABLE (
    -- Stock info
    symbol TEXT,
    stock_name TEXT,
    last_price REAL,
    daily_change REAL,
    daily_change_percent REAL,
    
    -- Last evaluated forecast
    last_forecast_date DATE,
    last_predicted_lo REAL,
    last_predicted_hi REAL,
    last_actual_low REAL,
    last_actual_high REAL,
    last_is_hit BOOLEAN,
    
    -- Next upcoming forecast
    next_forecast_date DATE,
    next_predicted_lo REAL,
    next_predicted_hi REAL,
    
    -- Latest technical indicators
    indicator_date DATE,
    rsi REAL,
    macd REAL,
    macd_signal REAL,
    sma20 REAL,
    sma50 REAL
)
LANGUAGE plpgsql STABLE AS $$
DECLARE
    latest_historical_date DATE;
BEGIN
    -- Find the date of the latest available historical data. This represents "today" or the last trading day.
    SELECT MAX(date) INTO latest_historical_date FROM public.historical_data;

    RETURN QUERY
    SELECT
        s.symbol,
        s.name AS stock_name,
        s.price AS last_price,
        s.change AS daily_change,
        s.change_percent AS daily_change_percent,
        
        -- Last evaluated forecast (data for the latest historical day)
        fcl.forecast_date AS last_forecast_date,
        fcl.predicted_lo::real AS last_predicted_lo,
        fcl.predicted_hi::real AS last_predicted_hi,
        fcl.actual_low::real AS last_actual_low,
        fcl.actual_high::real AS last_actual_high,
        fcl.hit_range AS last_is_hit,
        
        -- Next upcoming forecast (the one with the date after the latest historical date)
        nf.forecast_date AS next_forecast_date,
        nf.predicted_lo AS next_predicted_lo,
        nf.predicted_hi AS next_predicted_hi,
        
        -- Latest technical indicators (for the latest historical day)
        ti.date AS indicator_date,
        ti.rsi::real,
        ti.macd::real,
        ti.macd_signal::real,
        ti.sma20::real,
        ti.sma50::real
        
    FROM public.stocks s
    
    -- Join for Last Forecast
    LEFT JOIN public.forecast_check_latest fcl ON s.symbol = fcl.stock_symbol AND fcl.forecast_date = latest_historical_date
    
    -- Join for Next Forecast
    LEFT JOIN LATERAL (
        SELECT *
        FROM public.forecasts
        WHERE stock_symbol = s.symbol AND forecast_date > latest_historical_date
        ORDER BY forecast_date ASC
        LIMIT 1
    ) nf ON true
    
    -- Join for Latest Indicators
    LEFT JOIN public.technical_indicators ti ON s.symbol = ti.stock_symbol AND ti.date = latest_historical_date
    
    WHERE s.is_tracked = true
    ORDER BY s.symbol;
END;
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_the_coming_trend_data" created.';


-- Step 3: Add all new and updated UI translations.
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
-- Page title update
('en', 'daily_watchlist', 'The Coming Trend'),
('ar', 'daily_watchlist', 'الاتجاه القادم'),

-- New section titles and labels
('en', 'last_forecast', 'Last Forecast'),
('ar', 'last_forecast', 'آخر توقع'),
('en', 'next_forecast', 'Next Forecast'),
('ar', 'next_forecast', 'التوقع القادم'),
('en', 'technical_indicators', 'Technical Indicators'),
('ar', 'technical_indicators', 'مؤشرات فنية'),
('en', 'outcome', 'Outcome'),
('ar', 'outcome', 'النتيجة'),
('en', 'no_data_available', 'No data available.'),
('ar', 'no_data_available', 'لا توجد بيانات متاحة.')

ON CONFLICT (lang_id, key)
DO UPDATE SET value = EXCLUDED.value;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;
RAISE NOTICE 'SUCCESS: Added translations for "The Coming Trend" page.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Remove Gemini AI Analysis Translations
-- #
-- # Purpose: This script removes the UI translation keys related to the
-- # AI-powered analysis feature on "The Coming Trend" page, as the feature
-- # has been requested to be removed.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Delete the translation keys related to the removed feature.
DELETE FROM public.translations
WHERE key IN (
  'analyze_with_ai',
  'generating_analysis',
  'analysis_results',
  'no_data_to_analyze',
  'gemini_api_error'
);

RAISE NOTICE 'SUCCESS: Removed obsolete translations for the AI analysis feature.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Disclaimer Translation
-- #
-- # Purpose: This script adds the missing translation for the disclaimer text
-- # on "The Coming Trend" page, fixing a UI issue where the key was
-- # displayed instead of the translated text.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'disclaimer_educational_purposes', 'Disclaimer: For educational purposes only.'),
('ar', 'disclaimer_educational_purposes', 'إخلاء مسؤولية: هذه المعلومات للأغراض التعليمية فقط.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The "disclaimer_educational_purposes" translation has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add "Forecast Date" Title Translation
-- #
-- # Purpose: This script adds the UI translation key required for the new
-- # dynamic title on "The Coming Trend" page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'forecast_for_date', 'Forecast for'),
('ar', 'forecast_for_date', 'توقعات ليوم')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The "forecast_for_date" translation has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update "The Coming Trend" Data Function
-- #
-- # Purpose: This script updates the RPC function for "The Coming Trend" page
-- # to include data for the latest detected candlestick pattern. This supports
-- # the new, more visual UI design.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Update the RPC function to join with candle_patterns and return the latest pattern.
CREATE OR REPLACE FUNCTION public.get_the_coming_trend_data()
RETURNS TABLE (
    -- Stock info
    symbol TEXT,
    stock_name TEXT,
    last_price REAL,
    daily_change REAL,
    daily_change_percent REAL,
    
    -- Next upcoming forecast
    next_forecast_date DATE,
    next_predicted_lo REAL,
    next_predicted_hi REAL,
    
    -- Latest technical indicators
    indicator_date DATE,
    rsi REAL,
    macd REAL,
    macd_signal REAL,
    sma20 REAL,
    sma50 REAL,

    -- Latest candle pattern
    pattern_name TEXT,
    bullish BOOLEAN
)
LANGUAGE plpgsql STABLE AS $$
DECLARE
    latest_historical_date DATE;
BEGIN
    -- Find the date of the latest available historical data. This represents "today" or the last trading day.
    SELECT MAX(date) INTO latest_historical_date FROM public.historical_data;

    RETURN QUERY
    SELECT
        s.symbol,
        s.name AS stock_name,
        s.price AS last_price,
        s.change AS daily_change,
        s.change_percent AS daily_change_percent,
        
        -- Next upcoming forecast (the one with the date after the latest historical date)
        nf.forecast_date AS next_forecast_date,
        nf.predicted_lo AS next_predicted_lo,
        nf.predicted_hi AS next_predicted_hi,
        
        -- Latest technical indicators (for the latest historical day)
        ti.date AS indicator_date,
        ti.rsi::real,
        ti.macd::real,
        ti.macd_signal::real,
        ti.sma20::real,
        ti.sma50::real,

        -- Latest candle pattern
        cp.pattern_name,
        cp.bullish
        
    FROM public.stocks s
    
    LEFT JOIN LATERAL (
        SELECT *
        FROM public.forecasts
        WHERE stock_symbol = s.symbol AND forecast_date > latest_historical_date
        ORDER BY forecast_date ASC
        LIMIT 1
    ) nf ON true
    
    LEFT JOIN public.technical_indicators ti ON s.symbol = ti.stock_symbol AND ti.date = latest_historical_date

    LEFT JOIN LATERAL (
        -- Get only the first/most relevant pattern for the indicator date to avoid duplicate rows
        SELECT cp_inner.pattern_name, cp_inner.bullish
        FROM public.candle_patterns cp_inner
        WHERE cp_inner.stock_symbol = s.symbol AND cp_inner.date = latest_historical_date
        ORDER BY cp_inner.confidence DESC NULLS LAST
        LIMIT 1
    ) cp ON true
    
    WHERE s.is_tracked = true
    ORDER BY s.symbol;
END;
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_the_coming_trend_data" updated to include candlestick pattern data.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translations for New Watchlist Visuals
-- #
-- # Purpose: This script adds all the translation keys needed for the new
-- # professional table layout and visual indicators on "The Coming Trend" page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Table Headers
('en', 'last_price_change', 'Last Price / Change'),
('ar', 'last_price_change', 'آخر سعر / التغيير'),
('en', 'next_forecast_range', 'Next Forecast Range'),
('ar', 'next_forecast_range', 'نطاق التوقع القادم'),
('en', 'key_indicators', 'Key Indicators'),
('ar', 'key_indicators', 'المؤشرات الرئيسية'),
('en', 'last_pattern', 'Last Pattern'),
('ar', 'last_pattern', 'آخر نمط فني'),

-- Tooltips and labels for indicators
('en', 'rsi_label', 'RSI'),
('ar', 'rsi_label', 'قوة نسبية'),
('en', 'macd_hist_label', 'MACD Histogram'),
('ar', 'macd_hist_label', 'الرسم البياني للماكد'),
('en', 'sma_label', 'Simple Moving Average'),
('ar', 'sma_label', 'متوسط متحرك بسيط'),
('en', 'price_above_sma', 'Price is above SMA{period}'),
('ar', 'price_above_sma', 'السعر أعلى من متوسط {period} يوم'),
('en', 'price_below_sma', 'Price is below SMA{period}'),
('ar', 'price_below_sma', 'السعر أدنى من متوسط {period} يوم'),
('en', 'overbought', 'Overbought'),
('ar', 'overbought', 'تشبع شرائي'),
('en', 'oversold', 'Oversold'),
('ar', 'oversold', 'تشبع بيعي'),
('en', 'neutral', 'Neutral'),
('ar', 'neutral', 'محايد'),

-- Pattern translations
('en', 'no_pattern_detected', 'None detected'),
('ar', 'no_pattern_detected', 'لم يتم رصد نمط')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for the new watchlist visuals have been added.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix Disclaimer Translation
-- #
-- # Purpose: This script adds the missing translation for the disclaimer text
-- # on "The Coming Trend" page, fixing a UI issue where the key was
-- # displayed instead of the translated text.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
-- The ON CONFLICT clause ensures this is safe to run multiple times.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'disclaimer_educational_purposes', 'Disclaimer: For educational purposes only.'),
('ar', 'disclaimer_educational_purposes', 'إخلاء مسؤولية: هذه المعلومات للأغراض التعليمية فقط.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The "disclaimer_educational_purposes" translation has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Update Translations for Redesigned Analysis Page
-- #
-- # Purpose: This script adds all the new and updated translation keys needed for
-- # the redesigned "Last Work Day" page to match the user's screenshot.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Update page title for nav button and page header
('en', 'stock_analysis', 'Last Day'),
('ar', 'stock_analysis', 'آخر يوم'),
('en', 'stock_analysis_title_last_day', 'Last Day'),
('ar', 'stock_analysis_title_last_day', 'آخر يوم'),

-- New disclaimer banner
('en', 'disclaimer_title', 'Disclaimer'),
('ar', 'disclaimer_title', 'تنبيه'),
('en', 'disclaimer_educational', 'Information is for educational purposes and is not investment advice.'),
('ar', 'disclaimer_educational', 'المعلومات لأغراض تعليمية وليست نصيحة استثمارية.'),

-- New date display
('en', 'check_forecasts_for_date', 'Checking forecasts for:'),
('ar', 'check_forecasts_for_date', 'فحص التوقعات ليوم:'),

-- New stat cards
('en', 'total_forecasts', 'Total Forecasts'),
('ar', 'total_forecasts', 'إجمالي التوقعات'),
('en', 'correct_forecasts', 'Correct Forecasts'),
('ar', 'correct_forecasts', 'توقعات صحيحة'),
('en', 'incorrect_forecasts', 'Incorrect Forecasts'),
('ar', 'incorrect_forecasts', 'توقعات خاطئة'),
('en', 'success_rate', 'Success Rate'),
('ar', 'success_rate', 'نسبة النجاح')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translations for the redesigned Stock Analysis page have been added/updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Toggle for Educational Disclaimer
-- #
-- # Purpose: This script adds the backend infrastructure to allow an admin
-- # to control the visibility of the educational disclaimer banner on the
-- # "Last Day" analysis page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Add the new setting to app_settings with a default value of 'true'.
-- The ON CONFLICT clause prevents errors if the script is run more than once.
INSERT INTO public.app_settings (key, value) VALUES
('show_educational_disclaimer', 'true')
ON CONFLICT (key) DO NOTHING;

-- Step 2: Add new translation keys for the UI labels in the dashboard settings.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'show_educational_disclaimer_label', 'Show Educational Disclaimer'),
('ar', 'show_educational_disclaimer_label', 'إظهار تنبيه الأغراض التعليمية'),
('en', 'show_educational_disclaimer_desc', 'Controls the visibility of the green disclaimer banner at the top of the "Last Day" analysis page.'),
('ar', 'show_educational_disclaimer_desc', 'يتحكم في ظهور شريط التنبيه الأخضر في أعلى صفحة تحليل "آخر يوم".')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Added setting and translations for the educational disclaimer toggle.';

COMMIT;
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add "forecasts_for" Translation Key
-- #
-- # Purpose: This script adds the missing translation key "forecasts_for"
-- # that is used in the DailyWatchlist page.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the missing translation for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'forecasts_for', 'Forecasts for'),
('ar', 'forecasts_for', 'توقعات ليوم')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: The "forecasts_for" translation has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################










-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Table Column Header Translations
-- #
-- # Purpose: This script adds translation keys for table column headers
-- # to ensure all UI text uses the translation system instead of hardcoded English.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add the new translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
-- Table Column Headers
('en', 'column_symbol', 'Symbol'),
('ar', 'column_symbol', 'الرمز'),
('en', 'column_name', 'Name'),
('ar', 'column_name', 'الاسم'),
('en', 'column_price_change', 'Price & Change'),
('ar', 'column_price_change', 'السعر والتغيير'),
('en', 'column_price_date', 'Price & Date'),
('ar', 'column_price_date', 'السعر والتاريخ'),
('en', 'column_actual_range', 'Actual Price Range'),
('ar', 'column_actual_range', 'النطاق الفعلي'),
('en', 'column_expected_range', 'Expected Price Range'),
('ar', 'column_expected_range', 'النطاق المتوقع'),
('en', 'column_rsi', 'RSI'),
('ar', 'column_rsi', 'مؤشر القوة النسبية'),
('en', 'column_forecast', 'Forecast'),
('ar', 'column_forecast', 'التوقع'),
('en', 'column_pattern', 'Pattern'),
('ar', 'column_pattern', 'النمط'),
('en', 'column_favorite', 'Favorite'),
('ar', 'column_favorite', 'مفضل')

ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Actual Price Range to Daily Watchlist
-- #
-- # Purpose: This script updates the get_the_coming_trend_data function
-- # to include actual low/high price range using multiple sources in priority:
-- # 1. forecast_check_history (for specific dates like 2025-10-31)
-- # 2. forecast_check_latest (latest evaluation results)
-- # 3. historical_data (raw historical data as fallback)
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Update the existing RPC function to include actual price range
-- Using CREATE OR REPLACE to update the function that already exists from migration_153
CREATE OR REPLACE FUNCTION public.get_the_coming_trend_data()
RETURNS TABLE (
    -- Stock info
    symbol TEXT,
    stock_name TEXT,
    last_price REAL,
    daily_change REAL,
    daily_change_percent REAL,
    
    -- Next upcoming forecast
    next_forecast_date DATE,
    next_predicted_lo REAL,
    next_predicted_hi REAL,
    
    -- Latest technical indicators
    indicator_date DATE,
    rsi REAL,
    macd REAL,
    macd_signal REAL,
    sma20 REAL,
    sma50 REAL,

    -- Latest candle pattern
    pattern_name TEXT,
    bullish BOOLEAN,
    
    -- Actual price range from historical_data for indicator_date
    actual_low REAL,
    actual_high REAL
)
LANGUAGE plpgsql STABLE AS $$
DECLARE
    latest_historical_date DATE;
BEGIN
    -- Find the date of the latest available historical data. This represents "today" or the last trading day.
    SELECT MAX(date) INTO latest_historical_date FROM public.historical_data;

    RETURN QUERY
    SELECT
        s.symbol,
        s.name AS stock_name,
        s.price AS last_price,
        s.change AS daily_change,
        s.change_percent AS daily_change_percent,
        
        -- Next upcoming forecast (the one with the date after the latest historical date)
        nf.forecast_date AS next_forecast_date,
        nf.predicted_lo AS next_predicted_lo,
        nf.predicted_hi AS next_predicted_hi,
        
        -- Latest technical indicators (for the latest historical day)
        ti.date AS indicator_date,
        ti.rsi::real,
        ti.macd::real,
        ti.macd_signal::real,
        ti.sma20::real,
        ti.sma50::real,

        -- Latest candle pattern
        cp.pattern_name,
        cp.bullish,
        
        -- Actual price range: prefer forecast_check_history (for specific dates like 2025-10-31)
        -- Then forecast_check_latest, then historical_data as fallback
        COALESCE(
            fch.actual_low::real, 
            fcl.actual_low::real, 
            hd.low::real
        ) AS actual_low,
        COALESCE(
            fch.actual_high::real, 
            fcl.actual_high::real, 
            hd.high::real
        ) AS actual_high
        
    FROM public.stocks s
    
    LEFT JOIN LATERAL (
        SELECT *
        FROM public.forecasts
        WHERE stock_symbol = s.symbol AND forecast_date > latest_historical_date
        ORDER BY forecast_date ASC
        LIMIT 1
    ) nf ON true
    
    LEFT JOIN public.technical_indicators ti ON s.symbol = ti.stock_symbol AND ti.date = latest_historical_date

    -- Use forecast_check_history first: try exact match with indicator_date,
    -- then fallback to latest available record
    LEFT JOIN LATERAL (
        SELECT fch_inner.actual_low, fch_inner.actual_high, fch_inner.forecast_date
        FROM public.forecast_check_history fch_inner
        WHERE fch_inner.stock_symbol = s.symbol
        ORDER BY 
            -- Priority 1: exact match with indicator_date
            CASE WHEN fch_inner.forecast_date = latest_historical_date THEN 0 ELSE 1 END,
            -- Priority 2: latest available date
            fch_inner.forecast_date DESC
        LIMIT 1
    ) fch ON true
    
    -- Fallback to forecast_check_latest if no history record exists
    LEFT JOIN public.forecast_check_latest fcl ON s.symbol = fcl.stock_symbol 
        AND fch.forecast_date IS NULL
    
    -- Final fallback to historical_data for indicator_date
    LEFT JOIN public.historical_data hd ON s.symbol = hd.stock_symbol 
        AND hd.date = latest_historical_date
        AND fch.forecast_date IS NULL
        AND fcl.stock_symbol IS NULL

    LEFT JOIN LATERAL (
        -- Get only the first/most relevant pattern for the indicator date to avoid duplicate rows
        SELECT cp_inner.pattern_name, cp_inner.bullish
        FROM public.candle_patterns cp_inner
        WHERE cp_inner.stock_symbol = s.symbol AND cp_inner.date = latest_historical_date
        ORDER BY cp_inner.confidence DESC NULLS LAST
        LIMIT 1
    ) cp ON true
    
    WHERE s.is_tracked = true
    ORDER BY s.symbol;
END;
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_the_coming_trend_data" updated to include actual price range.';

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Restore Correct Watchlist Logic
-- #
-- # Purpose: This script restores the correct logic from get_daily_watchlist_data()
-- # which starts from forecasts table and ensures we only show stocks with
-- # forecasts for the next trading day, while adding the new required fields:
-- # - actual_low and actual_high
-- # - Additional technical indicators (rsi, macd, macd_signal)
-- # - daily_change and daily_change_percent
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Update the function to use the correct logic from get_daily_watchlist_data
CREATE OR REPLACE FUNCTION public.get_the_coming_trend_data()
RETURNS TABLE (
    -- Stock info
    symbol TEXT,
    stock_name TEXT,
    last_price REAL,
    daily_change REAL,
    daily_change_percent REAL,
    
    -- Next upcoming forecast (for tomorrow)
    next_forecast_date DATE,
    next_predicted_lo REAL,
    next_predicted_hi REAL,
    
    -- Latest technical indicators (for today, before forecast date)
    indicator_date DATE,
    rsi REAL,
    macd REAL,
    macd_signal REAL,
    sma20 REAL,
    sma50 REAL,

    -- Latest candle pattern
    pattern_name TEXT,
    bullish BOOLEAN,
    
    -- Actual price range
    actual_low REAL,
    actual_high REAL
)
LANGUAGE plpgsql STABLE AS $$
DECLARE
    latest_forecast_date DATE;           -- آخر تاريخ توقع من جدول التوقعات (أحدث سجل)
    latest_indicator_date DATE;          -- آخر تاريخ مؤشرات (اليوم - قبل تاريخ التوقع)
    latest_historical_date DATE;         -- آخر تاريخ في البيانات التاريخية (للنطاق الفعلي)
BEGIN
    -- 1. آخر تاريخ توقع = أحدث سجل في جدول التوقعات (يوم العمل القادم)
    SELECT MAX(f.forecast_date) INTO latest_forecast_date FROM public.forecasts f;

    -- 2. آخر تاريخ مؤشرات (اليوم - قبل تاريخ التوقع) - نفس منطق get_daily_watchlist_data
    SELECT MAX(ti.date) INTO latest_indicator_date 
    FROM public.technical_indicators ti 
    WHERE ti.date < latest_forecast_date;

    -- 3. آخر تاريخ في البيانات التاريخية (لجلب النطاق الفعلي)
    SELECT MAX(hd.date) INTO latest_historical_date FROM public.historical_data hd;

    RETURN QUERY
    SELECT
        s.symbol,                              -- رمز السهم من جدول الأسهم (نفس منطق get_daily_watchlist_data)
        s.name AS stock_name,
        s.price AS last_price,                  -- سعر آخر إغلاق من جدول الأسهم
        s.change AS daily_change,
        s.change_percent AS daily_change_percent,
        
        -- التوقع القادم (من نفس سجل التوقعات - أحدث سجل)
        f.forecast_date AS next_forecast_date,  -- تاريخ التوقع = يوم العمل القادم
        f.predicted_lo AS next_predicted_lo,    -- نطاق التوقع القادم من نفس السجل
        f.predicted_hi AS next_predicted_hi,
        
        -- المؤشرات الفنية من آخر تاريخ مؤشرات (قبل تاريخ التوقع) - نفس منطق get_daily_watchlist_data
        ti.date AS indicator_date,
        ti.rsi::real,
        ti.macd::real,
        ti.macd_signal::real,
        ti.sma20::real,
        ti.sma50::real,

        -- نمط الشمعة من آخر تاريخ مؤشرات - نفس منطق get_daily_watchlist_data
        cp.pattern_name,
        cp.bullish,
        
        -- النطاق الفعلي من جدول البيانات التاريخية (لآخر تاريخ تاريخي)
        hd.low::real AS actual_low,
        hd.high::real AS actual_high
        
    FROM
        public.forecasts f                    -- ✅ ابدأ من جدول التوقعات (نفس منطق get_daily_watchlist_data)
    JOIN
        public.stocks s ON f.stock_symbol = s.symbol  -- ✅ سعر آخر إغلاق من جدول الأسهم
    LEFT JOIN
        public.technical_indicators ti 
        ON f.stock_symbol = ti.stock_symbol 
        AND ti.date = latest_indicator_date    -- ✅ المؤشرات الفنية من آخر تاريخ مؤشرات (قبل التوقع)
    LEFT JOIN
        -- نمط الشمعة من آخر تاريخ مؤشرات - نفس منطق get_daily_watchlist_data
        (
            SELECT DISTINCT ON (cp_inner.stock_symbol) *
            FROM public.candle_patterns cp_inner
            WHERE cp_inner.date = latest_indicator_date
        ) cp ON f.stock_symbol = cp.stock_symbol
    
    -- النطاق الفعلي من جدول البيانات التاريخية (لآخر تاريخ تاريخي)
    LEFT JOIN public.historical_data hd 
        ON f.stock_symbol = hd.stock_symbol 
        AND hd.date = latest_historical_date
        
    WHERE
        f.forecast_date = latest_forecast_date  -- ✅ Only forecasts for tomorrow
        AND s.is_tracked = true
    ORDER BY
        s.symbol;
END;
$$;

RAISE NOTICE 'SUCCESS: RPC function "get_the_coming_trend_data" restored with correct logic from get_daily_watchlist_data.';

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Leave Blank Translation
-- #
-- # Purpose: This script adds the translation key for "leave blank to not change"
-- # placeholder text in password fields
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update system data
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

-- Add/Update the translations for English and Arabic.
INSERT INTO public.translations (lang_id, key, value) VALUES
('en', 'leave_blank_to_not_change', 'Leave blank to not change'),
('ar', 'leave_blank_to_not_change', 'اتركها فارغة لعدم التغيير')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

RAISE NOTICE 'SUCCESS: Translation for leave_blank_to_not_change has been added or updated.';

-- Re-enable RLS
ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- # END OF SCRIPT
-- #############################################################################

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Create Forecast Accuracy Analysis Page
-- #
-- # Purpose: Create RPC function and permissions for forecast accuracy page
-- # This page displays historical forecast accuracy statistics and metrics
-- #
-- #############################################################################

BEGIN;

-- Step 1: Create RPC function to get forecast accuracy statistics
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_stats(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_result json;
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    -- Set default date range (last 90 days if not specified)
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    SELECT json_build_object(
        -- Overall Statistics
        'overall', (
            SELECT json_build_object(
                'total_forecasts', COUNT(*)::integer,
                'hit_range_count', COUNT(*) FILTER (WHERE hit_range = true)::integer,
                'miss_range_count', COUNT(*) FILTER (WHERE hit_range = false)::integer,
                'hit_rate', CASE 
                    WHEN COUNT(*) > 0 THEN 
                        ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                    ELSE 0 
                END,
                'avg_abs_error', COALESCE(AVG(abs_error), 0),
                'avg_pct_error', COALESCE(AVG(pct_error), 0),
                'avg_confidence', COALESCE(AVG(confidence), 0)
            )
            FROM public.forecast_check_history
            WHERE forecast_date BETWEEN v_start_date AND v_end_date
        ),
        
        -- By Stock Performance
        'by_stock', (
            SELECT COALESCE(json_agg(
                json_build_object(
                    'stock_symbol', stock_symbol,
                    'total_forecasts', total_forecasts::integer,
                    'hit_count', hit_count::integer,
                    'miss_count', miss_count::integer,
                    'hit_rate', hit_rate,
                    'avg_abs_error', avg_abs_error,
                    'avg_pct_error', avg_pct_error,
                    'avg_confidence', avg_confidence
                )
                ORDER BY hit_rate DESC, total_forecasts DESC
            ), '[]'::json)
            FROM (
                SELECT 
                    stock_symbol,
                    COUNT(*) as total_forecasts,
                    COUNT(*) FILTER (WHERE hit_range = true) as hit_count,
                    COUNT(*) FILTER (WHERE hit_range = false) as miss_count,
                    CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END as hit_rate,
                    COALESCE(AVG(abs_error), 0) as avg_abs_error,
                    COALESCE(AVG(pct_error), 0) as avg_pct_error,
                    COALESCE(AVG(confidence), 0) as avg_confidence
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                GROUP BY stock_symbol
                HAVING COUNT(*) >= 3  -- Only stocks with at least 3 forecasts
            ) stock_stats
        ),
        
        -- By Date Performance (Last 30 days)
        'by_date', (
            SELECT COALESCE(json_agg(
                json_build_object(
                    'forecast_date', forecast_date::text,
                    'total_forecasts', total_forecasts::integer,
                    'hit_count', hit_count::integer,
                    'hit_rate', hit_rate
                )
                ORDER BY forecast_date DESC
            ), '[]'::json)
            FROM (
                SELECT 
                    forecast_date,
                    COUNT(*) as total_forecasts,
                    COUNT(*) FILTER (WHERE hit_range = true) as hit_count,
                    CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END as hit_rate
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                GROUP BY forecast_date
            ) date_stats
            LIMIT 30
        ),
        
        -- Confidence Level Analysis
        'by_confidence', (
            SELECT json_build_object(
                'high_confidence', (
                    SELECT json_build_object(
                        'count', COUNT(*)::integer,
                        'hit_rate', CASE 
                            WHEN COUNT(*) > 0 THEN 
                                ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                            ELSE 0 
                        END
                    )
                    FROM public.forecast_check_history
                    WHERE forecast_date BETWEEN v_start_date AND v_end_date
                    AND confidence >= 70
                ),
                'medium_confidence', (
                    SELECT json_build_object(
                        'count', COUNT(*)::integer,
                        'hit_rate', CASE 
                            WHEN COUNT(*) > 0 THEN 
                                ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                            ELSE 0 
                        END
                    )
                    FROM public.forecast_check_history
                    WHERE forecast_date BETWEEN v_start_date AND v_end_date
                    AND confidence >= 50 AND confidence < 70
                ),
                'low_confidence', (
                    SELECT json_build_object(
                        'count', COUNT(*)::integer,
                        'hit_rate', CASE 
                            WHEN COUNT(*) > 0 THEN 
                                ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                            ELSE 0 
                        END
                    )
                    FROM public.forecast_check_history
                    WHERE forecast_date BETWEEN v_start_date AND v_end_date
                    AND confidence < 50
                )
            )
        ),
        
        -- Recent Forecasts (Last 20)
        'recent_forecasts', (
            SELECT COALESCE(json_agg(
                json_build_object(
                    'stock_symbol', rf.stock_symbol,
                    'forecast_date', rf.forecast_date::text,
                    'predicted_lo', rf.predicted_lo,
                    'predicted_hi', rf.predicted_hi,
                    'actual_low', rf.actual_low,
                    'actual_high', rf.actual_high,
                    'actual_close', rf.actual_close,
                    'hit_range', rf.hit_range,
                    'abs_error', rf.abs_error,
                    'pct_error', rf.pct_error,
                    'confidence', rf.confidence,
                    'stock_name', rf.stock_name
                )
                ORDER BY rf.forecast_date DESC, rf.created_at DESC
            ), '[]'::json)
            FROM (
                SELECT 
                    fch.stock_symbol,
                    fch.forecast_date,
                    fch.predicted_lo,
                    fch.predicted_hi,
                    fch.actual_low,
                    fch.actual_high,
                    fch.actual_close,
                    fch.hit_range,
                    fch.abs_error,
                    fch.pct_error,
                    fch.confidence,
                    fch.created_at,
                    s.name AS stock_name
                FROM public.forecast_check_history fch
                LEFT JOIN public.stocks s ON s.symbol = fch.stock_symbol
                WHERE fch.forecast_date BETWEEN v_start_date AND v_end_date
                ORDER BY fch.forecast_date DESC, fch.created_at DESC
                LIMIT 20
            ) rf
        ),
        
        -- Date Range
        'date_range', json_build_object(
            'start_date', v_start_date::text,
            'end_date', v_end_date::text
        )
    ) INTO v_result;

    RETURN v_result;
END;
$$;

COMMENT ON FUNCTION public.get_forecast_accuracy_stats IS 'Returns comprehensive forecast accuracy statistics for analysis page';

-- Step 2: Add permission for forecast accuracy page
-- Temporarily disable RLS to update system data
ALTER TABLE public.permissions DISABLE ROW LEVEL SECURITY;

INSERT INTO public.permissions (action, description) VALUES
('view:forecast_accuracy', 'View Forecast Accuracy Analysis Page')
ON CONFLICT (action) DO NOTHING;

ALTER TABLE public.permissions ENABLE ROW LEVEL SECURITY;

-- Step 3: Add translations
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
-- English
('en', 'forecast_accuracy', 'Forecast Accuracy'),
('en', 'forecast_accuracy_analysis', 'Forecast Accuracy Analysis'),
('en', 'overall_statistics', 'Overall Statistics'),
('en', 'total_forecasts', 'Total Forecasts'),
('en', 'hit_rate', 'Hit Rate'),
('en', 'accuracy_rate', 'Accuracy Rate'),
('en', 'average_error', 'Average Error'),
('en', 'average_confidence', 'Average Confidence'),
('en', 'by_stock_performance', 'By Stock Performance'),
('en', 'by_date_performance', 'Performance by Date'),
('en', 'by_confidence_level', 'By Confidence Level'),
('en', 'high_confidence', 'High Confidence (≥70%)'),
('en', 'medium_confidence', 'Medium Confidence (50-70%)'),
('en', 'low_confidence', 'Low Confidence (<50%)'),
('en', 'recent_forecasts', 'Recent Forecasts'),
('en', 'hit', 'Hit'),
('en', 'miss', 'Miss'),
('en', 'predicted_range', 'Predicted Range'),
('en', 'actual_range', 'Actual Range'),
('en', 'error_percentage', 'Error %'),
('en', 'date_range', 'Date Range'),
('en', 'select_date_range', 'Select Date Range'),
('en', 'forecast_date', 'Forecast Date'),
('en', 'confidence', 'Confidence'),
('en', 'forecasts', 'Forecasts'),
('en', 'result', 'Result'),
('en', 'no_data_available', 'No Data Available'),

-- Arabic
('ar', 'forecast_accuracy', 'دقة التوقعات'),
('ar', 'forecast_accuracy_analysis', 'تحليل دقة التوقعات'),
('ar', 'overall_statistics', 'الإحصائيات العامة'),
('ar', 'total_forecasts', 'إجمالي التوقعات'),
('ar', 'hit_rate', 'معدل الدقة'),
('ar', 'accuracy_rate', 'معدل الدقة'),
('ar', 'average_error', 'متوسط الخطأ'),
('ar', 'average_confidence', 'متوسط الثقة'),
('ar', 'by_stock_performance', 'الأداء حسب السهم'),
('ar', 'by_date_performance', 'الأداء حسب التاريخ'),
('ar', 'by_confidence_level', 'حسب مستوى الثقة'),
('ar', 'high_confidence', 'ثقة عالية (≥70%)'),
('ar', 'medium_confidence', 'ثقة متوسطة (50-70%)'),
('ar', 'low_confidence', 'ثقة منخفضة (<50%)'),
('ar', 'recent_forecasts', 'التوقعات الأخيرة'),
('ar', 'hit', 'نجح'),
('ar', 'miss', 'أخطأ'),
('ar', 'predicted_range', 'النطاق المتوقع'),
('ar', 'actual_range', 'النطاق الفعلي'),
('ar', 'error_percentage', 'نسبة الخطأ %'),
('ar', 'date_range', 'النطاق الزمني'),
('ar', 'select_date_range', 'اختر النطاق الزمني'),
('ar', 'forecast_date', 'تاريخ التوقع'),
('ar', 'confidence', 'الثقة'),
('ar', 'forecasts', 'التوقعات'),
('ar', 'result', 'النتيجة'),
('ar', 'no_data_available', 'لا توجد بيانات متاحة')
ON CONFLICT (lang_id, key) DO NOTHING;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

RAISE NOTICE 'SUCCESS: Forecast accuracy page setup completed.';

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Grant Forecast Accuracy Permission to Admin Role
-- #
-- # Purpose: Grant 'view:forecast_accuracy' permission to Admin role
-- # This script is safe to run multiple times (idempotent)
-- #
-- #############################################################################

BEGIN;

-- Temporarily disable RLS to update role permissions
ALTER TABLE public.role_permissions DISABLE ROW LEVEL SECURITY;

-- Grant permission to Admin role using DO block for safety
DO $$
DECLARE
    admin_role_id uuid;
    forecast_accuracy_perm_id uuid;
BEGIN
    -- Get Admin role ID
    SELECT id INTO admin_role_id 
    FROM public.roles 
    WHERE name = 'Admin';
    
    -- Get Forecast Accuracy permission ID
    SELECT id INTO forecast_accuracy_perm_id 
    FROM public.permissions 
    WHERE action = 'view:forecast_accuracy';
    
    -- Only proceed if both IDs exist
    IF admin_role_id IS NOT NULL AND forecast_accuracy_perm_id IS NOT NULL THEN
        -- Grant permission (ON CONFLICT ensures idempotency)
        INSERT INTO public.role_permissions (role_id, permission_id)
        VALUES (admin_role_id, forecast_accuracy_perm_id)
        ON CONFLICT (role_id, permission_id) DO NOTHING;
        
        RAISE NOTICE 'SUCCESS: Forecast accuracy permission granted to Admin role.';
    ELSE
        IF admin_role_id IS NULL THEN
            RAISE WARNING 'Admin role not found. Please ensure the role exists.';
        END IF;
        IF forecast_accuracy_perm_id IS NULL THEN
            RAISE WARNING 'view:forecast_accuracy permission not found. Please run migration_163_create_forecast_accuracy_page.sql.txt first.';
        END IF;
    END IF;
END $$;

-- Re-enable RLS
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;

COMMIT;

-- Verification Query (Optional - uncomment to verify)
-- SELECT 
--     r.name as role_name,
--     p.action as permission_action,
--     p.description as permission_description
-- FROM public.role_permissions rp
-- JOIN public.roles r ON r.id = rp.role_id
-- JOIN public.permissions p ON p.id = rp.permission_id
-- WHERE r.name = 'Admin' AND p.action = 'view:forecast_accuracy';

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Create Separate RPC Functions for Forecast Accuracy Page
-- #
-- # Purpose: Create individual RPC functions for each section of the forecast
-- # accuracy page. This allows better modularity and separation of concerns.
-- # The page will call these functions instead of accessing tables directly.
-- #
-- # Functions Created:
-- # 1. get_forecast_accuracy_overall - Overall statistics
-- # 2. get_forecast_accuracy_by_stock - Performance by stock
-- # 3. get_forecast_accuracy_by_date - Performance by date
-- # 4. get_forecast_accuracy_by_confidence - Analysis by confidence level
-- # 5. get_forecast_accuracy_recent - Recent forecasts list
-- #
-- #############################################################################

BEGIN;

-- Function 1: Get Overall Statistics
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_overall(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    -- Set default date range (last 90 days if not specified)
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'total_forecasts', COUNT(*)::integer,
            'hit_range_count', COUNT(*) FILTER (WHERE hit_range = true)::integer,
            'miss_range_count', COUNT(*) FILTER (WHERE hit_range = false)::integer,
            'hit_rate', CASE 
                WHEN COUNT(*) > 0 THEN 
                    ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                ELSE 0 
            END,
            'avg_abs_error', COALESCE(AVG(abs_error), 0),
            'avg_pct_error', COALESCE(AVG(pct_error), 0),
            'avg_confidence', COALESCE(AVG(confidence), 0)
        )
        FROM public.forecast_check_history
        WHERE forecast_date BETWEEN v_start_date AND v_end_date
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_accuracy_overall IS 'Returns overall forecast accuracy statistics for the given date range';

-- Function 2: Get Performance by Stock
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_by_stock(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    -- Set default date range (last 90 days if not specified)
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT COALESCE(json_agg(
            json_build_object(
                'stock_symbol', stock_symbol,
                'total_forecasts', total_forecasts::integer,
                'hit_count', hit_count::integer,
                'miss_count', miss_count::integer,
                'hit_rate', hit_rate,
                'avg_abs_error', avg_abs_error,
                'avg_pct_error', avg_pct_error,
                'avg_confidence', avg_confidence
            )
            ORDER BY hit_rate DESC, total_forecasts DESC
        ), '[]'::json)
        FROM (
            SELECT 
                stock_symbol,
                COUNT(*) as total_forecasts,
                COUNT(*) FILTER (WHERE hit_range = true) as hit_count,
                COUNT(*) FILTER (WHERE hit_range = false) as miss_count,
                CASE 
                    WHEN COUNT(*) > 0 THEN 
                        ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                    ELSE 0 
                END as hit_rate,
                COALESCE(AVG(abs_error), 0) as avg_abs_error,
                COALESCE(AVG(pct_error), 0) as avg_pct_error,
                COALESCE(AVG(confidence), 0) as avg_confidence
            FROM public.forecast_check_history
            WHERE forecast_date BETWEEN v_start_date AND v_end_date
            GROUP BY stock_symbol
            HAVING COUNT(*) >= 3  -- Only stocks with at least 3 forecasts
        ) stock_stats
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_accuracy_by_stock IS 'Returns forecast accuracy performance grouped by stock symbol';

-- Function 3: Get Performance by Date
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_by_date(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    -- Set default date range (last 90 days if not specified)
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT COALESCE(json_agg(
            json_build_object(
                'forecast_date', forecast_date::text,
                'total_forecasts', total_forecasts::integer,
                'hit_count', hit_count::integer,
                'hit_rate', hit_rate
            )
            ORDER BY forecast_date DESC
        ), '[]'::json)
        FROM (
            SELECT 
                forecast_date,
                COUNT(*) as total_forecasts,
                COUNT(*) FILTER (WHERE hit_range = true) as hit_count,
                CASE 
                    WHEN COUNT(*) > 0 THEN 
                        ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                    ELSE 0 
                END as hit_rate
            FROM public.forecast_check_history
            WHERE forecast_date BETWEEN v_start_date AND v_end_date
            GROUP BY forecast_date
            ORDER BY forecast_date DESC
            LIMIT 30
        ) date_stats
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_accuracy_by_date IS 'Returns forecast accuracy performance grouped by date (last 30 days)';

-- Function 4: Get Analysis by Confidence Level
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_by_confidence(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    -- Set default date range (last 90 days if not specified)
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'high_confidence', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND confidence >= 70
            ),
            'medium_confidence', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND confidence >= 50 AND confidence < 70
            ),
            'low_confidence', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND confidence < 50
            )
        )
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_accuracy_by_confidence IS 'Returns forecast accuracy analysis grouped by confidence level';

-- Function 5: Get Recent Forecasts
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_recent(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    -- Set default date range (last 90 days if not specified)
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT COALESCE(json_agg(
            json_build_object(
                'stock_symbol', rf.stock_symbol,
                'forecast_date', rf.forecast_date::text,
                'predicted_lo', rf.predicted_lo,
                'predicted_hi', rf.predicted_hi,
                'actual_low', rf.actual_low,
                'actual_high', rf.actual_high,
                'actual_close', rf.actual_close,
                'hit_range', rf.hit_range,
                'abs_error', rf.abs_error,
                'pct_error', rf.pct_error,
                'confidence', rf.confidence,
                'stock_name', rf.stock_name
            )
            ORDER BY rf.forecast_date DESC, rf.created_at DESC
        ), '[]'::json)
        FROM (
            SELECT 
                fch.stock_symbol,
                fch.forecast_date,
                fch.predicted_lo,
                fch.predicted_hi,
                fch.actual_low,
                fch.actual_high,
                fch.actual_close,
                fch.hit_range,
                fch.abs_error,
                fch.pct_error,
                fch.confidence,
                fch.created_at,
                s.name AS stock_name
            FROM public.forecast_check_history fch
            LEFT JOIN public.stocks s ON s.symbol = fch.stock_symbol
            WHERE fch.forecast_date BETWEEN v_start_date AND v_end_date
            ORDER BY fch.forecast_date DESC, fch.created_at DESC
            LIMIT 20
        ) rf
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_accuracy_recent IS 'Returns recent forecasts with details (last 20)';

COMMIT;

RAISE NOTICE 'SUCCESS: Forecast accuracy RPC functions created successfully.';

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Create RPC Functions for Forecast History Analysis Page
-- #
-- # Purpose: Create specialized RPC functions to analyze forecast_check_history
-- # with maximum visual insights and statistics
-- #
-- #############################################################################

BEGIN;

-- Function 1: Get comprehensive forecast history summary
CREATE OR REPLACE FUNCTION public.get_forecast_history_summary(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '365 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'total_records', COUNT(*)::integer,
            'unique_stocks', COUNT(DISTINCT stock_symbol)::integer,
            'date_range', json_build_object(
                'first_date', MIN(forecast_date)::text,
                'last_date', MAX(forecast_date)::text,
                'total_days', COUNT(DISTINCT forecast_date)::integer
            ),
            'hit_stats', json_build_object(
                'total_hits', COUNT(*) FILTER (WHERE hit_range = true)::integer,
                'total_misses', COUNT(*) FILTER (WHERE hit_range = false)::integer,
                'hit_rate', CASE 
                    WHEN COUNT(*) > 0 THEN 
                        ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                    ELSE 0 
                END
            ),
            'error_stats', json_build_object(
                'avg_abs_error', COALESCE(AVG(abs_error), 0),
                'max_abs_error', COALESCE(MAX(abs_error), 0),
                'min_abs_error', COALESCE(MIN(abs_error), 0),
                'avg_pct_error', COALESCE(AVG(pct_error), 0),
                'max_pct_error', COALESCE(MAX(pct_error), 0)
            ),
            'confidence_stats', json_build_object(
                'avg_confidence', COALESCE(AVG(confidence), 0),
                'max_confidence', COALESCE(MAX(confidence), 0),
                'min_confidence', COALESCE(MIN(confidence), 0),
                'high_confidence_count', COUNT(*) FILTER (WHERE confidence >= 70)::integer,
                'medium_confidence_count', COUNT(*) FILTER (WHERE confidence >= 50 AND confidence < 70)::integer,
                'low_confidence_count', COUNT(*) FILTER (WHERE confidence < 50)::integer
            )
        )
        FROM public.forecast_check_history
        WHERE forecast_date BETWEEN v_start_date AND v_end_date
    );
END;
$$;

-- Function 2: Get performance by month
CREATE OR REPLACE FUNCTION public.get_forecast_performance_by_month(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '365 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT COALESCE(json_agg(
            json_build_object(
                'year', year::integer,
                'month', month::integer,
                'month_name', TO_CHAR(DATE_TRUNC('month', forecast_date), 'Month'),
                'total_forecasts', total_forecasts::integer,
                'hits', hits::integer,
                'misses', misses::integer,
                'hit_rate', hit_rate,
                'avg_error', avg_error
            )
            ORDER BY year DESC, month DESC
        ), '[]'::json)
        FROM (
            SELECT 
                EXTRACT(YEAR FROM forecast_date)::integer as year,
                EXTRACT(MONTH FROM forecast_date)::integer as month,
                DATE_TRUNC('month', forecast_date) as forecast_date,
                COUNT(*) as total_forecasts,
                COUNT(*) FILTER (WHERE hit_range = true) as hits,
                COUNT(*) FILTER (WHERE hit_range = false) as misses,
                CASE 
                    WHEN COUNT(*) > 0 THEN 
                        ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                    ELSE 0 
                END as hit_rate,
                COALESCE(AVG(pct_error), 0) as avg_error
            FROM public.forecast_check_history
            WHERE forecast_date BETWEEN v_start_date AND v_end_date
            GROUP BY DATE_TRUNC('month', forecast_date)
        ) monthly_stats
    );
END;
$$;

-- Function 3: Get best and worst performing stocks
CREATE OR REPLACE FUNCTION public.get_forecast_stock_leaders(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_limit INTEGER DEFAULT 10
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '365 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'best_performers', (
                SELECT COALESCE(json_agg(
                    json_build_object(
                        'stock_symbol', stock_symbol,
                        'stock_name', stock_name,
                        'total_forecasts', total_forecasts::integer,
                        'hit_rate', hit_rate,
                        'avg_error', avg_error
                    )
                    ORDER BY hit_rate DESC, total_forecasts DESC
                ), '[]'::json)
                FROM (
                    SELECT 
                        fch.stock_symbol,
                        s.name as stock_name,
                        COUNT(*) as total_forecasts,
                        CASE 
                            WHEN COUNT(*) > 0 THEN 
                                ROUND((COUNT(*) FILTER (WHERE fch.hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                            ELSE 0 
                        END as hit_rate,
                        COALESCE(AVG(fch.pct_error), 0) as avg_error
                    FROM public.forecast_check_history fch
                    LEFT JOIN public.stocks s ON s.symbol = fch.stock_symbol
                    WHERE fch.forecast_date BETWEEN v_start_date AND v_end_date
                    GROUP BY fch.stock_symbol, s.name
                    HAVING COUNT(*) >= 5
                    ORDER BY hit_rate DESC, total_forecasts DESC
                    LIMIT p_limit
                ) best
            ),
            'worst_performers', (
                SELECT COALESCE(json_agg(
                    json_build_object(
                        'stock_symbol', stock_symbol,
                        'stock_name', stock_name,
                        'total_forecasts', total_forecasts::integer,
                        'hit_rate', hit_rate,
                        'avg_error', avg_error
                    )
                    ORDER BY hit_rate ASC, total_forecasts DESC
                ), '[]'::json)
                FROM (
                    SELECT 
                        fch.stock_symbol,
                        s.name as stock_name,
                        COUNT(*) as total_forecasts,
                        CASE 
                            WHEN COUNT(*) > 0 THEN 
                                ROUND((COUNT(*) FILTER (WHERE fch.hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                            ELSE 0 
                        END as hit_rate,
                        COALESCE(AVG(fch.pct_error), 0) as avg_error
                    FROM public.forecast_check_history fch
                    LEFT JOIN public.stocks s ON s.symbol = fch.stock_symbol
                    WHERE fch.forecast_date BETWEEN v_start_date AND v_end_date
                    GROUP BY fch.stock_symbol, s.name
                    HAVING COUNT(*) >= 5
                    ORDER BY hit_rate ASC, total_forecasts DESC
                    LIMIT p_limit
                ) worst
            )
        )
    );
END;
$$;

-- Function 4: Get forecast accuracy trends
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_trends(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '365 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'weekly_trend', (
                SELECT COALESCE(json_agg(
                    json_build_object(
                        'week', week::text,
                        'total_forecasts', total_forecasts::integer,
                        'hit_rate', hit_rate
                    )
                    ORDER BY week DESC
                ), '[]'::json)
                FROM (
                    SELECT 
                        DATE_TRUNC('week', forecast_date)::text as week,
                        COUNT(*) as total_forecasts,
                        CASE 
                            WHEN COUNT(*) > 0 THEN 
                                ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                            ELSE 0 
                        END as hit_rate
                    FROM public.forecast_check_history
                    WHERE forecast_date BETWEEN v_start_date AND v_end_date
                    GROUP BY DATE_TRUNC('week', forecast_date)
                    ORDER BY week DESC
                    LIMIT 52
                ) weekly
            ),
            'error_distribution', (
                SELECT json_build_object(
                    'very_low_error', COUNT(*) FILTER (WHERE pct_error <= 2)::integer,
                    'low_error', COUNT(*) FILTER (WHERE pct_error > 2 AND pct_error <= 5)::integer,
                    'medium_error', COUNT(*) FILTER (WHERE pct_error > 5 AND pct_error <= 10)::integer,
                    'high_error', COUNT(*) FILTER (WHERE pct_error > 10 AND pct_error <= 20)::integer,
                    'very_high_error', COUNT(*) FILTER (WHERE pct_error > 20)::integer
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND pct_error IS NOT NULL
            )
        )
    );
END;
$$;

-- Function 5: Get detailed forecast comparison
CREATE OR REPLACE FUNCTION public.get_forecast_detailed_comparison(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_limit INTEGER DEFAULT 50
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT COALESCE(json_agg(
            json_build_object(
                'stock_symbol', fch.stock_symbol,
                'stock_name', s.name,
                'forecast_date', fch.forecast_date::text,
                'predicted_range', json_build_object(
                    'low', fch.predicted_lo,
                    'high', fch.predicted_hi,
                    'range_size', (fch.predicted_hi - fch.predicted_lo)
                ),
                'actual_range', json_build_object(
                    'low', fch.actual_low,
                    'high', fch.actual_high,
                    'range_size', (fch.actual_high - fch.actual_low)
                ),
                'accuracy', json_build_object(
                    'hit_range', fch.hit_range,
                    'abs_error', fch.abs_error,
                    'pct_error', fch.pct_error
                ),
                'confidence', fch.confidence
            )
            ORDER BY fch.forecast_date DESC, fch.pct_error ASC
        ), '[]'::json)
        FROM public.forecast_check_history fch
        LEFT JOIN public.stocks s ON s.symbol = fch.stock_symbol
        WHERE fch.forecast_date BETWEEN v_start_date AND v_end_date
        ORDER BY fch.forecast_date DESC, fch.pct_error ASC
        LIMIT p_limit
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_history_summary IS 'Returns comprehensive summary statistics for forecast history analysis';
COMMENT ON FUNCTION public.get_forecast_performance_by_month IS 'Returns forecast performance grouped by month';
COMMENT ON FUNCTION public.get_forecast_stock_leaders IS 'Returns best and worst performing stocks';
COMMENT ON FUNCTION public.get_forecast_accuracy_trends IS 'Returns forecast accuracy trends over time';
COMMENT ON FUNCTION public.get_forecast_detailed_comparison IS 'Returns detailed forecast comparison data';

COMMIT;

RAISE NOTICE 'SUCCESS: Forecast history analysis RPC functions created successfully.';

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Permissions and Translations for Forecast History Analysis Page
-- #
-- #############################################################################

BEGIN;

-- Step 1: Add permission for forecast history analysis page
ALTER TABLE public.permissions DISABLE ROW LEVEL SECURITY;

INSERT INTO public.permissions (action, description) VALUES
('view:forecast_history_analysis', 'View Forecast History Analysis Page')
ON CONFLICT (action) DO NOTHING;

ALTER TABLE public.permissions ENABLE ROW LEVEL SECURITY;

-- Step 2: Add translations
ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
-- English
('en', 'forecast_history_analysis', 'Forecast History Analysis'),
('en', 'total_records', 'Total Records'),
('en', 'unique_stocks', 'Unique Stocks'),
('en', 'total_days', 'Days'),
('en', 'confidence_distribution', 'Confidence Distribution'),
('en', 'error_distribution', 'Error Distribution'),
('en', 'min_error', 'Min Error'),
('en', 'max_error', 'Max Error'),
('en', 'weekly_trend', 'Weekly Trend'),
('en', 'monthly_trend', 'Monthly Trend'),
('en', 'last', 'Last'),
('en', 'weeks', 'weeks'),
('en', 'months', 'months'),
('en', 'best_performers', 'Best Performers'),
('en', 'worst_performers', 'Worst Performers'),

-- Arabic
('ar', 'forecast_history_analysis', 'تحليل تاريخ التوقعات'),
('ar', 'total_records', 'إجمالي السجلات'),
('ar', 'unique_stocks', 'أسهم فريدة'),
('ar', 'total_days', 'أيام'),
('ar', 'confidence_distribution', 'توزيع الثقة'),
('ar', 'error_distribution', 'توزيع الخطأ'),
('ar', 'min_error', 'أقل خطأ'),
('ar', 'max_error', 'أعلى خطأ'),
('ar', 'weekly_trend', 'الاتجاه الأسبوعي'),
('ar', 'monthly_trend', 'الاتجاه الشهري'),
('ar', 'last', 'آخر'),
('ar', 'weeks', 'أسابيع'),
('ar', 'months', 'أشهر'),
('ar', 'best_performers', 'أفضل الأداء'),
('ar', 'worst_performers', 'أسوأ الأداء')
ON CONFLICT (lang_id, key) DO NOTHING;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

RAISE NOTICE 'SUCCESS: Forecast history analysis permissions and translations added.';

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Advanced Forecast Accuracy Analysis Functions
-- #
-- # Purpose: Create comprehensive RPC functions for advanced forecast accuracy
-- # statistics at both overall level and per-stock level
-- #
-- #############################################################################

BEGIN;

-- ==============================================================================
-- FUNCTION 1: Performance by Error Range (Overall)
-- ==============================================================================
CREATE OR REPLACE FUNCTION public.get_forecast_error_range_stats(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'very_low_error', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_pct_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND pct_error IS NOT NULL AND pct_error <= 2
            ),
            'low_error', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_pct_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND pct_error IS NOT NULL AND pct_error > 2 AND pct_error <= 5
            ),
            'medium_error', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_pct_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND pct_error IS NOT NULL AND pct_error > 5 AND pct_error <= 10
            ),
            'high_error', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_pct_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND pct_error IS NOT NULL AND pct_error > 10 AND pct_error <= 20
            ),
            'very_high_error', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_pct_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND pct_error IS NOT NULL AND pct_error > 20
            )
        )
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_error_range_stats IS 'Returns forecast performance grouped by error range (overall level)';

-- ==============================================================================
-- FUNCTION 2: Performance by Predicted Range Size (Overall)
-- ==============================================================================
CREATE OR REPLACE FUNCTION public.get_forecast_range_size_stats(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'narrow_range', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_range_size', ROUND(COALESCE(AVG((predicted_hi - predicted_lo)::numeric / NULLIF(predicted_lo, 0) * 100), 0::numeric)::numeric, 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_lo > 0
                AND ((predicted_hi - predicted_lo) / predicted_lo * 100) < 5
            ),
            'medium_range', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_range_size', ROUND(COALESCE(AVG((predicted_hi - predicted_lo)::numeric / NULLIF(predicted_lo, 0) * 100), 0::numeric)::numeric, 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_lo > 0
                AND ((predicted_hi - predicted_lo) / predicted_lo * 100) >= 5
                AND ((predicted_hi - predicted_lo) / predicted_lo * 100) <= 10
            ),
            'wide_range', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_range_size', ROUND(COALESCE(AVG((predicted_hi - predicted_lo)::numeric / NULLIF(predicted_lo, 0) * 100), 0::numeric)::numeric, 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_lo > 0
                AND ((predicted_hi - predicted_lo) / predicted_lo * 100) > 10
            )
        )
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_range_size_stats IS 'Returns forecast performance grouped by predicted range size (overall level)';

-- ==============================================================================
-- FUNCTION 3: Time Trends - Performance Comparison (Overall)
-- ==============================================================================
CREATE OR REPLACE FUNCTION public.get_forecast_time_trends(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
    v_mid_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);
    v_mid_date := v_start_date + ((v_end_date - v_start_date) / 2);

    RETURN (
        SELECT json_build_object(
            'first_period', (
                SELECT json_build_object(
                    'start_date', v_start_date::text,
                    'end_date', v_mid_date::text,
                    'total_forecasts', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_mid_date
            ),
            'second_period', (
                SELECT json_build_object(
                    'start_date', (v_mid_date + INTERVAL '1 day')::text,
                    'end_date', v_end_date::text,
                    'total_forecasts', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN (v_mid_date + INTERVAL '1 day') AND v_end_date
            ),
            'trend', (
                SELECT CASE 
                    WHEN 
                        (SELECT COUNT(*) FILTER (WHERE hit_range = true)::numeric / NULLIF(COUNT(*), 0) * 100
                         FROM public.forecast_check_history
                         WHERE forecast_date BETWEEN (v_mid_date + INTERVAL '1 day') AND v_end_date)
                        >
                        (SELECT COUNT(*) FILTER (WHERE hit_range = true)::numeric / NULLIF(COUNT(*), 0) * 100
                         FROM public.forecast_check_history
                         WHERE forecast_date BETWEEN v_start_date AND v_mid_date)
                    THEN 'improving'
                    WHEN 
                        (SELECT COUNT(*) FILTER (WHERE hit_range = true)::numeric / NULLIF(COUNT(*), 0) * 100
                         FROM public.forecast_check_history
                         WHERE forecast_date BETWEEN (v_mid_date + INTERVAL '1 day') AND v_end_date)
                        <
                        (SELECT COUNT(*) FILTER (WHERE hit_range = true)::numeric / NULLIF(COUNT(*), 0) * 100
                         FROM public.forecast_check_history
                         WHERE forecast_date BETWEEN v_start_date AND v_mid_date)
                    THEN 'declining'
                    ELSE 'stable'
                END
            )
        )
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_time_trends IS 'Returns performance comparison between first and second half of date range';

-- ==============================================================================
-- FUNCTION 4: Performance by Day of Week (Overall)
-- ==============================================================================
CREATE OR REPLACE FUNCTION public.get_forecast_day_of_week_stats(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT COALESCE(json_agg(
            json_build_object(
                'day_of_week', day_of_week,
                'day_name', day_name,
                'total_forecasts', total_forecasts::integer,
                'hit_rate', hit_rate,
                'avg_error', avg_error
            )
            ORDER BY day_of_week
        ), '[]'::json)
        FROM (
            SELECT 
                EXTRACT(DOW FROM forecast_date)::integer AS day_of_week,
                CASE EXTRACT(DOW FROM forecast_date)
                    WHEN 0 THEN 'Sunday'
                    WHEN 1 THEN 'Monday'
                    WHEN 2 THEN 'Tuesday'
                    WHEN 3 THEN 'Wednesday'
                    WHEN 4 THEN 'Thursday'
                    WHEN 5 THEN 'Friday'
                    WHEN 6 THEN 'Saturday'
                END AS day_name,
                COUNT(*) AS total_forecasts,
                CASE 
                    WHEN COUNT(*) > 0 THEN 
                        ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                    ELSE 0 
                END AS hit_rate,
                ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2) AS avg_error
            FROM public.forecast_check_history
            WHERE forecast_date BETWEEN v_start_date AND v_end_date
            GROUP BY EXTRACT(DOW FROM forecast_date)
        ) day_stats
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_day_of_week_stats IS 'Returns forecast performance grouped by day of week';

-- ==============================================================================
-- FUNCTION 5: Forecast Bias Analysis (Overall)
-- ==============================================================================
CREATE OR REPLACE FUNCTION public.get_forecast_bias_analysis(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'overestimated', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'percentage', CASE 
                        WHEN (SELECT COUNT(*) FROM public.forecast_check_history WHERE forecast_date BETWEEN v_start_date AND v_end_date) > 0 THEN
                            ROUND((COUNT(*)::numeric / (SELECT COUNT(*) FROM public.forecast_check_history WHERE forecast_date BETWEEN v_start_date AND v_end_date)::numeric) * 100, 2)
                        ELSE 0
                    END,
                    'avg_overestimate', ROUND(COALESCE(AVG((predicted_hi - actual_high)::numeric), 0), 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_hi > actual_high
            ),
            'underestimated', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'percentage', CASE 
                        WHEN (SELECT COUNT(*) FROM public.forecast_check_history WHERE forecast_date BETWEEN v_start_date AND v_end_date) > 0 THEN
                            ROUND((COUNT(*)::numeric / (SELECT COUNT(*) FROM public.forecast_check_history WHERE forecast_date BETWEEN v_start_date AND v_end_date)::numeric) * 100, 2)
                        ELSE 0
                    END,
                    'avg_underestimate', ROUND(COALESCE(AVG((actual_low - predicted_lo)::numeric), 0), 2)
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_lo < actual_low
            ),
            'within_range', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'percentage', CASE 
                        WHEN (SELECT COUNT(*) FROM public.forecast_check_history WHERE forecast_date BETWEEN v_start_date AND v_end_date) > 0 THEN
                            ROUND((COUNT(*)::numeric / (SELECT COUNT(*) FROM public.forecast_check_history WHERE forecast_date BETWEEN v_start_date AND v_end_date)::numeric) * 100, 2)
                        ELSE 0
                    END
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_lo <= actual_low AND predicted_hi >= actual_high
            )
        )
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_bias_analysis IS 'Returns forecast bias analysis (overestimated, underestimated, within range)';

-- ==============================================================================
-- FUNCTION 6: Extreme Forecasts Analysis (Overall)
-- ==============================================================================
CREATE OR REPLACE FUNCTION public.get_forecast_extreme_analysis(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_limit INTEGER DEFAULT 10
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'most_accurate', (
                SELECT COALESCE(json_agg(
                    json_build_object(
                        'stock_symbol', sub.stock_symbol,
                        'stock_name', sub.stock_name,
                        'forecast_date', sub.forecast_date,
                        'pct_error', sub.pct_error,
                        'hit_range', sub.hit_range
                    )
                ), '[]'::json)
                FROM (
                    SELECT 
                        fch.stock_symbol,
                        s.name AS stock_name,
                        fch.forecast_date::text AS forecast_date,
                        ROUND(fch.pct_error::numeric, 2) AS pct_error,
                        fch.hit_range
                    FROM public.forecast_check_history fch
                    LEFT JOIN public.stocks s ON s.symbol = fch.stock_symbol
                    WHERE fch.forecast_date BETWEEN v_start_date AND v_end_date
                    AND fch.pct_error IS NOT NULL
                    ORDER BY fch.pct_error ASC NULLS LAST
                    LIMIT p_limit
                ) sub
            ),
            'least_accurate', (
                SELECT COALESCE(json_agg(
                    json_build_object(
                        'stock_symbol', sub.stock_symbol,
                        'stock_name', sub.stock_name,
                        'forecast_date', sub.forecast_date,
                        'pct_error', sub.pct_error,
                        'hit_range', sub.hit_range
                    )
                ), '[]'::json)
                FROM (
                    SELECT 
                        fch.stock_symbol,
                        s.name AS stock_name,
                        fch.forecast_date::text AS forecast_date,
                        ROUND(fch.pct_error::numeric, 2) AS pct_error,
                        fch.hit_range
                    FROM public.forecast_check_history fch
                    LEFT JOIN public.stocks s ON s.symbol = fch.stock_symbol
                    WHERE fch.forecast_date BETWEEN v_start_date AND v_end_date
                    AND fch.pct_error IS NOT NULL
                    ORDER BY fch.pct_error DESC NULLS LAST
                    LIMIT p_limit
                ) sub
            )
        )
    );
END;
$$;

COMMENT ON FUNCTION public.get_forecast_extreme_analysis IS 'Returns most and least accurate forecasts';

-- ==============================================================================
-- PER-STOCK VERSIONS (Same functions but filtered by stock_symbol)
-- ==============================================================================

-- Function 7: Error Range Stats (Per Stock)
CREATE OR REPLACE FUNCTION public.get_forecast_error_range_stats_by_stock(
    p_stock_symbol TEXT,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'very_low_error', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_pct_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_end_date
                AND pct_error IS NOT NULL AND pct_error <= 2
            ),
            'low_error', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_pct_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_end_date
                AND pct_error IS NOT NULL AND pct_error > 2 AND pct_error <= 5
            ),
            'medium_error', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_pct_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_end_date
                AND pct_error IS NOT NULL AND pct_error > 5 AND pct_error <= 10
            ),
            'high_error', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_pct_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_end_date
                AND pct_error IS NOT NULL AND pct_error > 10 AND pct_error <= 20
            ),
            'very_high_error', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_pct_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_end_date
                AND pct_error IS NOT NULL AND pct_error > 20
            )
        )
    );
END;
$$;

-- Function 8: Range Size Stats (Per Stock)
CREATE OR REPLACE FUNCTION public.get_forecast_range_size_stats_by_stock(
    p_stock_symbol TEXT,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'narrow_range', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_range_size', ROUND(COALESCE(AVG((predicted_hi - predicted_lo)::numeric / NULLIF(predicted_lo, 0) * 100), 0::numeric)::numeric, 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_lo > 0
                AND ((predicted_hi - predicted_lo) / predicted_lo * 100) < 5
            ),
            'medium_range', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_range_size', ROUND(COALESCE(AVG((predicted_hi - predicted_lo)::numeric / NULLIF(predicted_lo, 0) * 100), 0::numeric)::numeric, 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_lo > 0
                AND ((predicted_hi - predicted_lo) / predicted_lo * 100) >= 5
                AND ((predicted_hi - predicted_lo) / predicted_lo * 100) <= 10
            ),
            'wide_range', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_range_size', ROUND(COALESCE(AVG((predicted_hi - predicted_lo)::numeric / NULLIF(predicted_lo, 0) * 100), 0::numeric)::numeric, 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_lo > 0
                AND ((predicted_hi - predicted_lo) / predicted_lo * 100) > 10
            )
        )
    );
END;
$$;

-- Function 9: Time Trends (Per Stock)
CREATE OR REPLACE FUNCTION public.get_forecast_time_trends_by_stock(
    p_stock_symbol TEXT,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
    v_mid_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);
    v_mid_date := v_start_date + ((v_end_date - v_start_date) / 2);

    RETURN (
        SELECT json_build_object(
            'first_period', (
                SELECT json_build_object(
                    'start_date', v_start_date::text,
                    'end_date', v_mid_date::text,
                    'total_forecasts', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_mid_date
            ),
            'second_period', (
                SELECT json_build_object(
                    'start_date', (v_mid_date + INTERVAL '1 day')::text,
                    'end_date', v_end_date::text,
                    'total_forecasts', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END,
                    'avg_error', ROUND(COALESCE(AVG(pct_error)::numeric, 0), 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN (v_mid_date + INTERVAL '1 day') AND v_end_date
            ),
            'trend', (
                SELECT CASE 
                    WHEN 
                        (SELECT COUNT(*) FILTER (WHERE hit_range = true)::numeric / NULLIF(COUNT(*), 0) * 100
                         FROM public.forecast_check_history
                         WHERE stock_symbol = p_stock_symbol
                         AND forecast_date BETWEEN (v_mid_date + INTERVAL '1 day') AND v_end_date)
                        >
                        (SELECT COUNT(*) FILTER (WHERE hit_range = true)::numeric / NULLIF(COUNT(*), 0) * 100
                         FROM public.forecast_check_history
                         WHERE stock_symbol = p_stock_symbol
                         AND forecast_date BETWEEN v_start_date AND v_mid_date)
                    THEN 'improving'
                    WHEN 
                        (SELECT COUNT(*) FILTER (WHERE hit_range = true)::numeric / NULLIF(COUNT(*), 0) * 100
                         FROM public.forecast_check_history
                         WHERE stock_symbol = p_stock_symbol
                         AND forecast_date BETWEEN (v_mid_date + INTERVAL '1 day') AND v_end_date)
                        <
                        (SELECT COUNT(*) FILTER (WHERE hit_range = true)::numeric / NULLIF(COUNT(*), 0) * 100
                         FROM public.forecast_check_history
                         WHERE stock_symbol = p_stock_symbol
                         AND forecast_date BETWEEN v_start_date AND v_mid_date)
                    THEN 'declining'
                    ELSE 'stable'
                END
            )
        )
    );
END;
$$;

-- Function 10: Bias Analysis (Per Stock)
CREATE OR REPLACE FUNCTION public.get_forecast_bias_analysis_by_stock(
    p_stock_symbol TEXT,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'overestimated', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'percentage', CASE 
                        WHEN (SELECT COUNT(*) FROM public.forecast_check_history WHERE stock_symbol = p_stock_symbol AND forecast_date BETWEEN v_start_date AND v_end_date) > 0 THEN
                            ROUND((COUNT(*)::numeric / (SELECT COUNT(*) FROM public.forecast_check_history WHERE stock_symbol = p_stock_symbol AND forecast_date BETWEEN v_start_date AND v_end_date)::numeric) * 100, 2)
                        ELSE 0
                    END,
                    'avg_overestimate', ROUND(COALESCE(AVG((predicted_hi - actual_high)::numeric), 0), 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_hi > actual_high
            ),
            'underestimated', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'percentage', CASE 
                        WHEN (SELECT COUNT(*) FROM public.forecast_check_history WHERE stock_symbol = p_stock_symbol AND forecast_date BETWEEN v_start_date AND v_end_date) > 0 THEN
                            ROUND((COUNT(*)::numeric / (SELECT COUNT(*) FROM public.forecast_check_history WHERE stock_symbol = p_stock_symbol AND forecast_date BETWEEN v_start_date AND v_end_date)::numeric) * 100, 2)
                        ELSE 0
                    END,
                    'avg_underestimate', ROUND(COALESCE(AVG((actual_low - predicted_lo)::numeric), 0), 2)
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_lo < actual_low
            ),
            'within_range', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'percentage', CASE 
                        WHEN (SELECT COUNT(*) FROM public.forecast_check_history WHERE stock_symbol = p_stock_symbol AND forecast_date BETWEEN v_start_date AND v_end_date) > 0 THEN
                            ROUND((COUNT(*)::numeric / (SELECT COUNT(*) FROM public.forecast_check_history WHERE stock_symbol = p_stock_symbol AND forecast_date BETWEEN v_start_date AND v_end_date)::numeric) * 100, 2)
                        ELSE 0
                    END
                )
                FROM public.forecast_check_history
                WHERE stock_symbol = p_stock_symbol
                AND forecast_date BETWEEN v_start_date AND v_end_date
                AND predicted_lo <= actual_low AND predicted_hi >= actual_high
            )
        )
    );
END;
$$;

COMMIT;

RAISE NOTICE 'SUCCESS: Advanced forecast accuracy functions created successfully.';

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translations for Advanced Forecast Accuracy Features
-- #
-- #############################################################################

BEGIN;

ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
-- English
('en', 'error_range_analysis', 'Error Range Analysis'),
('en', 'very_low_error', 'Very Low Error (≤2%)'),
('en', 'low_error_range', 'Low Error (2-5%)'),
('en', 'medium_error_range', 'Medium Error (5-10%)'),
('en', 'high_error_range', 'High Error (10-20%)'),
('en', 'very_high_error', 'Very High Error (>20%)'),
('en', 'range_size_analysis', 'Range Size Analysis'),
('en', 'narrow_range', 'Narrow Range (<5%)'),
('en', 'medium_range', 'Medium Range (5-10%)'),
('en', 'wide_range', 'Wide Range (>10%)'),
('en', 'time_trends', 'Time Trends'),
('en', 'first_period', 'First Period'),
('en', 'second_period', 'Second Period'),
('en', 'trend_improving', 'Improving'),
('en', 'trend_declining', 'Declining'),
('en', 'trend_stable', 'Stable'),
('en', 'day_of_week_analysis', 'Performance by Day of Week'),
('en', 'sunday', 'Sunday'),
('en', 'monday', 'Monday'),
('en', 'tuesday', 'Tuesday'),
('en', 'wednesday', 'Wednesday'),
('en', 'thursday', 'Thursday'),
('en', 'friday', 'Friday'),
('en', 'saturday', 'Saturday'),
('en', 'bias_analysis', 'Forecast Bias Analysis'),
('en', 'overestimated', 'Overestimated'),
('en', 'underestimated', 'Underestimated'),
('en', 'within_range', 'Within Range'),
('en', 'extreme_forecasts', 'Extreme Forecasts'),
('en', 'most_accurate', 'Most Accurate'),
('en', 'least_accurate', 'Least Accurate'),
('en', 'select_stock', 'Select Stock'),
('en', 'all_stocks', 'All Stocks'),
('en', 'avg_range_size', 'Avg Range Size'),
('en', 'avg_overestimate', 'Avg Overestimate'),
('en', 'avg_underestimate', 'Avg Underestimate'),
('en', 'forecasts_count', 'Forecasts Count'),
('en', 'advanced_statistics', 'Advanced Statistics'),
('en', 'trend', 'Trend'),
('en', 'not_available', 'Not Available'),
('en', 'invalid_date', 'Invalid Date'),
('en', 'of', 'of'),
('en', 'search', 'Search'),

-- Arabic
('ar', 'error_range_analysis', 'تحليل نطاق الخطأ'),
('ar', 'very_low_error', 'خطأ منخفض جداً (≤2%)'),
('ar', 'low_error_range', 'خطأ منخفض (2-5%)'),
('ar', 'medium_error_range', 'خطأ متوسط (5-10%)'),
('ar', 'high_error_range', 'خطأ عالي (10-20%)'),
('ar', 'very_high_error', 'خطأ عالي جداً (>20%)'),
('ar', 'range_size_analysis', 'تحليل حجم النطاق'),
('ar', 'narrow_range', 'نطاق ضيق (<5%)'),
('ar', 'medium_range', 'نطاق متوسط (5-10%)'),
('ar', 'wide_range', 'نطاق واسع (>10%)'),
('ar', 'time_trends', 'الاتجاهات الزمنية'),
('ar', 'first_period', 'الفترة الأولى'),
('ar', 'second_period', 'الفترة الثانية'),
('ar', 'trend_improving', 'يتحسن'),
('ar', 'trend_declining', 'يتدهور'),
('ar', 'trend_stable', 'مستقر'),
('ar', 'day_of_week_analysis', 'الأداء حسب يوم الأسبوع'),
('ar', 'sunday', 'الأحد'),
('ar', 'monday', 'الإثنين'),
('ar', 'tuesday', 'الثلاثاء'),
('ar', 'wednesday', 'الأربعاء'),
('ar', 'thursday', 'الخميس'),
('ar', 'friday', 'الجمعة'),
('ar', 'saturday', 'السبت'),
('ar', 'bias_analysis', 'تحليل التحيز في التوقعات'),
('ar', 'overestimated', 'مبالغ فيه'),
('ar', 'underestimated', 'مقدر بأقل'),
('ar', 'within_range', 'ضمن النطاق'),
('ar', 'extreme_forecasts', 'التوقعات المتطرفة'),
('ar', 'most_accurate', 'الأكثر دقة'),
('ar', 'least_accurate', 'الأقل دقة'),
('ar', 'select_stock', 'اختر السهم'),
('ar', 'all_stocks', 'جميع الأسهم'),
('ar', 'avg_range_size', 'متوسط حجم النطاق'),
('ar', 'avg_overestimate', 'متوسط المبالغة'),
('ar', 'avg_underestimate', 'متوسط التقليل'),
('ar', 'forecasts_count', 'عدد التوقعات'),
('ar', 'advanced_statistics', 'إحصائيات متقدمة'),
('ar', 'trend', 'الاتجاه'),
('ar', 'not_available', 'غير متاح'),
('ar', 'invalid_date', 'تاريخ غير صحيح'),
('ar', 'of', 'من'),
('ar', 'search', 'بحث')
ON CONFLICT (lang_id, key) DO NOTHING;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

RAISE NOTICE 'SUCCESS: Advanced forecast accuracy translations added.';

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Missing Translations for Forecast Accuracy Page
-- #
-- # Purpose: Add missing translation keys that are used in ForecastAccuracy.tsx
-- # but not present in the translations table
-- #
-- #############################################################################

BEGIN;

ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
-- English
('en', 'success_rate', 'Success Rate'),
('en', 'hit_count', 'Hit Count'),
('en', 'miss_count', 'Miss Count'),
('en', 'performance_by_stock', 'Performance by Stock'),

-- Arabic
('ar', 'success_rate', 'نسبة النجاح'),
('ar', 'hit_count', 'عدد التوقعات الصحيحة'),
('ar', 'miss_count', 'عدد التوقعات الخاطئة'),
('ar', 'performance_by_stock', 'الأداء حسب السهم')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

RAISE NOTICE 'SUCCESS: Missing forecast accuracy translations added.';




-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Translations for Advanced Visual Indicators
-- #
-- # Purpose: Add translation keys for new visual indicators added to Forecast Accuracy page
-- #
-- #############################################################################

BEGIN;

ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
-- English
('en', 'forecast_comparison', 'Forecast Comparison'),
('en', 'error_distribution', 'Error Distribution'),
('en', 'performance_indicators', 'Performance Indicators'),
('en', 'key_metrics', 'Key Metrics'),
('en', 'accuracy', 'Accuracy'),
('en', 'hit_ratio', 'Hit Ratio'),

-- Arabic
('ar', 'forecast_comparison', 'مقارنة التوقعات'),
('ar', 'error_distribution', 'توزيع الأخطاء'),
('ar', 'performance_indicators', 'مؤشرات الأداء'),
('ar', 'key_metrics', 'المؤشرات الرئيسية'),
('ar', 'accuracy', 'الدقة'),
('ar', 'hit_ratio', 'نسبة الإصابات')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

RAISE NOTICE 'SUCCESS: Advanced visual indicators translations added.';




-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Visual Indicators Explanations
-- #
-- # Purpose: Add translation keys for explanations of visual indicators
-- #          on the Forecast Accuracy page
-- #
-- #############################################################################

BEGIN;

ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
-- English
('en', 'total_forecasts_explanation', 'The total number of forecasts made during the selected period. This includes both correct and incorrect predictions.'),
('en', 'correct_forecasts_explanation', 'The number of forecasts where the actual stock price fell within the predicted price range. Higher numbers indicate better prediction accuracy.'),
('en', 'incorrect_forecasts_explanation', 'The number of forecasts where the actual stock price did not fall within the predicted price range. Lower numbers indicate better prediction accuracy.'),
('en', 'success_rate_explanation', 'The percentage of forecasts that were correct. This is calculated as (Correct Forecasts / Total Forecasts) × 100. Higher percentages indicate better overall prediction performance.'),
('en', 'forecast_comparison_explanation', 'A visual comparison showing the proportion of correct forecasts (green) versus incorrect forecasts (red). This helps quickly assess the overall prediction performance.'),
('en', 'average_error_explanation', 'The average percentage error across all forecasts. This measures how far off the predictions were on average. Lower percentages indicate more accurate predictions.'),
('en', 'average_confidence_explanation', 'The average confidence level of all forecasts. Confidence levels indicate how certain the prediction model was about each forecast.'),
('en', 'error_distribution_explanation', 'A breakdown showing how forecasts are distributed across different error ranges. This helps identify patterns in prediction accuracy and areas for improvement.'),
('en', 'by_confidence_level_explanation', 'Forecast performance analyzed by confidence level. This shows how prediction accuracy varies based on the model''s confidence in each forecast. Higher confidence forecasts typically show better accuracy.'),

-- Arabic
('ar', 'total_forecasts_explanation', 'إجمالي عدد التوقعات التي تم إجراؤها خلال الفترة المحددة. يتضمن هذا الرقم كلاً من التوقعات الصحيحة والخاطئة.'),
('ar', 'correct_forecasts_explanation', 'عدد التوقعات التي كانت فيها السعر الفعلي للسهم ضمن نطاق السعر المتوقع. الأرقام الأعلى تشير إلى دقة تنبؤ أفضل.'),
('ar', 'incorrect_forecasts_explanation', 'عدد التوقعات التي لم يكن فيها السعر الفعلي للسهم ضمن نطاق السعر المتوقع. الأرقام الأقل تشير إلى دقة تنبؤ أفضل.'),
('ar', 'success_rate_explanation', 'نسبة التوقعات التي كانت صحيحة. يتم حسابها على أنها (التوقعات الصحيحة / إجمالي التوقعات) × 100. النسب الأعلى تشير إلى أداء تنبؤي أفضل بشكل عام.'),
('ar', 'forecast_comparison_explanation', 'مقارنة بصرية توضح نسبة التوقعات الصحيحة (أخضر) مقابل التوقعات الخاطئة (أحمر). يساعد هذا في تقييم أداء التنبؤ بشكل عام بسرعة.'),
('ar', 'average_error_explanation', 'متوسط نسبة الخطأ عبر جميع التوقعات. يقيس هذا مدى بعد التوقعات في المتوسط. النسب الأقل تشير إلى توقعات أكثر دقة.'),
('ar', 'average_confidence_explanation', 'متوسط مستوى الثقة لجميع التوقعات. مستويات الثقة تشير إلى مدى يقين نموذج التنبؤ بكل توقع.'),
('ar', 'error_distribution_explanation', 'تحليل يوضح كيفية توزيع التوقعات عبر نطاقات أخطاء مختلفة. يساعد هذا في تحديد أنماط دقة التنبؤ والمناطق التي تحتاج إلى تحسين.'),
('ar', 'by_confidence_level_explanation', 'أداء التوقعات محلل حسب مستوى الثقة. يوضح هذا كيف تختلف دقة التنبؤ بناءً على ثقة النموذج في كل توقع. التوقعات ذات الثقة العالية عادة ما تُظهر دقة أفضل.')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

RAISE NOTICE 'SUCCESS: Visual indicators explanations translations added.';
-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add avg_error and avg_confidence Translations
-- #
-- # Purpose: Add missing translation keys for avg_error and avg_confidence
-- #          that are displayed on the Forecast Accuracy page
-- #
-- #############################################################################

BEGIN;

ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
-- English
('en', 'avg_error', 'Average Error'),
('en', 'avg_confidence', 'Average Confidence'),

-- Arabic
('ar', 'avg_error', 'متوسط الخطأ'),
('ar', 'avg_confidence', 'متوسط الثقة')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

RAISE NOTICE 'SUCCESS: avg_error and avg_confidence translations added.';





-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Security Fix - Add SET search_path to All Functions
-- #
-- # Purpose: This script adds SET search_path to all functions in the public
-- # schema to prevent search_path injection attacks and improve security.
-- #
-- # Based on: SECURITY_AUDIT_REPORT_ENHANCED.md
-- # Functions Fixed: 59 functions
-- # 
-- # IMPORTANT: This script runs in a single transaction with proper timeout.
-- # It preserves all function properties (ownership, permissions, triggers).
-- #
-- # Rollback: See rollback_security_fixes.sql
-- #
-- #############################################################################

-- Set statement timeout to 5 minutes for large migrations
SET statement_timeout = '5min';

BEGIN;

-- ============================================================================
-- SECTION 1: SQL Functions - SET search_path = public, pg_temp
-- ============================================================================

-- Function: get_active_announcements
CREATE OR REPLACE FUNCTION public.get_active_announcements()
RETURNS SETOF public.global_announcements
LANGUAGE sql
STABLE
SET search_path = public, pg_temp
AS $$
  SELECT *
  FROM public.global_announcements
  WHERE is_enabled = true
    AND now() >= start_date
    AND now() <= end_date
  ORDER BY created_at DESC;
$$;

-- Function: get_all_announcements
CREATE OR REPLACE FUNCTION public.get_all_announcements()
RETURNS SETOF public.global_announcements
LANGUAGE sql
STABLE
SET search_path = public, pg_temp
AS $$
  SELECT *
  FROM public.global_announcements
  ORDER BY start_date DESC;
$$;

-- Function: get_all_roles
CREATE OR REPLACE FUNCTION public.get_all_roles()
RETURNS SETOF public.roles
LANGUAGE sql
STABLE
SET search_path = public, pg_temp
AS $$
    SELECT id, name, description, created_at FROM public.roles;
$$;

-- Function: get_all_translations_for_management
CREATE OR REPLACE FUNCTION public.get_all_translations_for_management()
RETURNS TABLE (
    key text,
    value_en text,
    value_ar text
)
LANGUAGE sql STABLE
SET search_path = public, pg_temp
AS $$
SELECT
    t.key,
    MAX(CASE WHEN t.lang_id = 'en' THEN t.value ELSE NULL END) as value_en,
    MAX(CASE WHEN t.lang_id = 'ar' THEN t.value ELSE NULL END) as value_ar
FROM
    public.translations t
WHERE
    t.lang_id IN ('en', 'ar')
GROUP BY
    t.key
ORDER BY
    t.key;
$$;

-- Function: get_all_users_for_analysis
CREATE OR REPLACE FUNCTION public.get_all_users_for_analysis()
RETURNS json
LANGUAGE sql
STABLE
SET search_path = public, pg_temp
AS $$
    SELECT COALESCE(json_agg(
        json_build_object(
            'full_name', p.full_name,
            'email', p.email,
            'roles', json_build_object('name', r.name)
        )
    ), '[]'::json)
    FROM public.profiles p
    LEFT JOIN public.roles r on p.role_id = r.id;
$$;

-- Function: get_translations
CREATE OR REPLACE FUNCTION public.get_translations(p_lang_code TEXT)
RETURNS SETOF public.translations
LANGUAGE sql
STABLE
SET search_path = public, pg_temp
AS $$
  SELECT id, lang_id, key, value
  FROM public.translations
  WHERE lang_id = p_lang_code;
$$;

-- Function: get_translations_for_key (non-SECURITY DEFINER version)
CREATE OR REPLACE FUNCTION public.get_translations_for_key(p_key TEXT)
RETURNS SETOF public.translations
LANGUAGE sql
STABLE
SET search_path = public, pg_temp
AS $$
  SELECT id, lang_id, key, value
  FROM public.translations
  WHERE key = p_key AND (lang_id = 'en' OR lang_id = 'ar');
$$;

-- Function: get_user_profile_and_permissions
CREATE OR REPLACE FUNCTION public.get_user_profile_and_permissions(p_user_id UUID)
RETURNS json
LANGUAGE sql
STABLE
SET search_path = public, pg_temp
AS $$
SELECT
    json_build_object(
        'id', p.id,
        'full_name', p.full_name,
        'email', p.email,
        'role_id', p.role_id,
        'email_confirmed_at', p.email_confirmed_at,
        'preferred_language', p.preferred_language,
        'roles', (
            SELECT
                json_build_object(
                    'name', r.name,
                    'permissions', (
                        SELECT COALESCE(json_agg(json_build_object('action', perm.action)), '[]'::json)
                        FROM public.role_permissions rp
                        JOIN public.permissions perm ON rp.permission_id = perm.id
                        WHERE rp.role_id = p.role_id
                    )
                )
            FROM public.roles r
            WHERE r.id = p.role_id
        )
    )
FROM
    public.profiles p
WHERE
    p.id = p_user_id
LIMIT 1;
$$;

-- Function: get_dashboard_stats
CREATE OR REPLACE FUNCTION public.get_dashboard_stats()
RETURNS TABLE(user_count BIGINT, role_count BIGINT)
LANGUAGE sql
STABLE
SET search_path = public, pg_temp
AS $$
  SELECT
    (SELECT count(*) FROM public.profiles) AS user_count,
    (SELECT count(*) FROM public.roles) AS role_count;
$$;

-- Function: get_role_management_data
CREATE OR REPLACE FUNCTION public.get_role_management_data()
RETURNS json
LANGUAGE sql
STABLE
SET search_path = public, pg_temp
AS $$
SELECT json_build_object(
    'roles', (SELECT COALESCE(json_agg(r), '[]'::json) FROM public.roles r),
    'permissions', (
        SELECT COALESCE(json_agg(p), '[]'::json)
        FROM public.permissions p
        WHERE p.action != 'manage:advertisements'
    ),
    'role_permissions', (SELECT COALESCE(json_agg(rp), '[]'::json) FROM public.role_permissions rp)
);
$$;

-- Function: get_latest_forecast_date
CREATE OR REPLACE FUNCTION public.get_latest_forecast_date()
RETURNS date
LANGUAGE sql STABLE
SET search_path = public, pg_temp
AS $$
  SELECT max(forecast_date) FROM public.forecasts;
$$;

-- Function: get_daily_analysis_summary
CREATE OR REPLACE FUNCTION public.get_daily_analysis_summary(p_date date)
RETURNS json
LANGUAGE sql STABLE
SET search_path = public, pg_temp
AS $$
WITH daily_metrics AS (
    SELECT
        fch.hit_range,
        fch.predicted_price,
        fch.actual_close
    FROM public.forecast_check_history fch
    WHERE fch.forecast_date = p_date AND fch.actual_close IS NOT NULL
)
SELECT json_build_object(
    'forecast_date', p_date,
    'total_forecasts', (SELECT count(*) FROM daily_metrics),
    'hits', (SELECT count(*) FROM daily_metrics WHERE hit_range = true),
    'misses', (SELECT count(*) FROM daily_metrics WHERE hit_range = false),
    'hit_rate', (SELECT avg(CASE WHEN hit_range = true THEN 1 ELSE 0 END) FROM daily_metrics),
    'mape', (SELECT avg(abs(predicted_price - actual_close) / actual_close) FROM daily_metrics WHERE actual_close > 0)
);
$$;

-- Function: get_daily_forecast_results
CREATE OR REPLACE FUNCTION public.get_daily_forecast_results(p_date date)
RETURNS TABLE (
    stock_symbol text,
    stock_name text,
    predicted_price real,
    predicted_lo real,
    predicted_hi real,
    actual_close real,
    actual_low real,
    actual_high real,
    is_hit boolean
)
LANGUAGE sql STABLE
SET search_path = public, pg_temp
AS $$
SELECT
    fch.stock_symbol,
    s.name as stock_name,
    fch.predicted_price::real,
    fch.predicted_lo::real,
    fch.predicted_hi::real,
    fch.actual_close::real,
    fch.actual_low::real,
    fch.actual_high::real,
    fch.hit_range as is_hit
FROM
    public.forecast_check_history fch
JOIN
    public.stocks s ON fch.stock_symbol = s.symbol
WHERE
    fch.forecast_date = p_date
ORDER BY
    fch.stock_symbol;
$$;

-- ============================================================================
-- SECTION 2: plpgsql Functions - SET search_path = public, pg_temp
-- ============================================================================

-- Function: evaluate_and_save_forecasts
CREATE OR REPLACE FUNCTION public.evaluate_and_save_forecasts(p_date_filter date DEFAULT NULL)
RETURNS integer
LANGUAGE plpgsql
SET search_path = public, pg_temp
AS $$
DECLARE
    processed_count integer;
BEGIN
    WITH new_evaluations AS (
        SELECT
            f.stock_symbol,
            s.name AS stock_name,
            f.forecast_date,
            f.predicted_price,
            f.predicted_lo,
            f.predicted_hi,
            f.confidence,
            h.low AS actual_low,
            h.high AS actual_high,
            h.close AS actual_close,
            (f.predicted_lo <= h.high AND h.low <= f.predicted_hi) AS hit_range,
            ABS(f.predicted_price - h.close) AS abs_error,
            ABS(f.predicted_price - h.close) / NULLIF(h.close, 0) AS pct_error
        FROM
            public.forecasts f
        JOIN
            public.stocks s ON f.stock_symbol = s.symbol
        JOIN
            public.historical_data h ON f.stock_symbol = h.stock_symbol AND f.forecast_date = h.date
        WHERE (p_date_filter IS NULL OR f.forecast_date = p_date_filter)
    ),
    insert_history AS (
        INSERT INTO public.forecast_check_history (
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        )
        SELECT
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        FROM new_evaluations
        ON CONFLICT (stock_symbol, forecast_date) DO UPDATE SET
            predicted_price = EXCLUDED.predicted_price,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            actual_close = EXCLUDED.actual_close,
            hit_range = EXCLUDED.hit_range,
            abs_error = EXCLUDED.abs_error,
            pct_error = EXCLUDED.pct_error,
            confidence = EXCLUDED.confidence,
            created_at = NOW()
        RETURNING 1
    ),
    upsert_latest AS (
        INSERT INTO public.forecast_check_latest (
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        )
        SELECT DISTINCT ON (stock_symbol)
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        FROM new_evaluations
        ORDER BY stock_symbol, forecast_date DESC
        ON CONFLICT (stock_symbol) DO UPDATE SET
            forecast_date = EXCLUDED.forecast_date,
            predicted_price = EXCLUDED.predicted_price,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            actual_close = EXCLUDED.actual_close,
            hit_range = EXCLUDED.hit_range,
            abs_error = EXCLUDED.abs_error,
            pct_error = EXCLUDED.pct_error,
            confidence = EXCLUDED.confidence,
            created_at = NOW()
    ),
    insert_legacy AS (
        INSERT INTO public."Forcast_Result" (
            stock_symbol, stock_name, forecast_date, predicted_lo, predicted_hi,
            actual_low, actual_high, is_hit
        )
        SELECT
            stock_symbol, stock_name, forecast_date, predicted_lo, predicted_hi,
            actual_low, actual_high, hit_range
        FROM new_evaluations
        ON CONFLICT (stock_symbol, forecast_date) DO UPDATE SET
            stock_name = EXCLUDED.stock_name,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            is_hit = EXCLUDED.is_hit,
            created_at = NOW()
    )
    SELECT count(*) INTO processed_count FROM insert_history;
    
    RETURN processed_count;
END;
$$;

-- Function: trigger_forecast_evaluation
CREATE OR REPLACE FUNCTION public.trigger_forecast_evaluation()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = public, pg_temp
AS $$
DECLARE
    tracked_stock_count integer;
    forecast_count_for_date integer;
BEGIN
    SELECT count(*)
    INTO tracked_stock_count
    FROM public.stocks
    WHERE is_tracked = true;

    SELECT count(*)
    INTO forecast_count_for_date
    FROM public.forecasts
    WHERE forecast_date = NEW.forecast_date;

    IF forecast_count_for_date >= tracked_stock_count THEN
        PERFORM public.evaluate_and_save_forecasts(NEW.forecast_date);
    END IF;

    RETURN NEW;
END;
$$;

-- Function: fn_log_app_settings_change
CREATE OR REPLACE FUNCTION public.fn_log_app_settings_change()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = public, pg_temp
AS $$
BEGIN
    PERFORM public.log_activity(
      'APP_SETTING_CHANGED',
      jsonb_build_object(
        'setting_key', NEW.key,
        'old_value', OLD.value,
        'new_value', NEW.value
      )
    );
  RETURN NEW;
END;
$$;

-- Function: fn_log_profile_update
CREATE OR REPLACE FUNCTION public.fn_log_profile_update()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = public, pg_temp
AS $$
DECLARE
  old_role_name TEXT;
  new_role_name TEXT;
BEGIN
  IF OLD.role_id IS DISTINCT FROM NEW.role_id THEN
    SELECT name INTO old_role_name FROM public.roles WHERE id = OLD.role_id;
    SELECT name INTO new_role_name FROM public.roles WHERE id = NEW.role_id;
    PERFORM public.log_activity(
      'USER_ROLE_CHANGED',
      jsonb_build_object(
        'target_user_email', NEW.email,
        'old_role_name', old_role_name,
        'new_role_name', new_role_name
      )
    );
  END IF;
  RETURN NEW;
END;
$$;

-- Function: fn_log_role_permission_change
CREATE OR REPLACE FUNCTION public.fn_log_role_permission_change()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = public, pg_temp
AS $$
DECLARE
  action_type TEXT;
  details JSONB;
  role_name_text TEXT;
  permission_action_text TEXT;
BEGIN
  IF (TG_OP = 'INSERT') THEN
    action_type := 'ROLE_PERMISSION_ADDED';
    SELECT r.name, p.action INTO role_name_text, permission_action_text FROM public.roles r, public.permissions p WHERE r.id = NEW.role_id AND p.id = NEW.permission_id;
    details := jsonb_build_object('role_name', role_name_text, 'permission_action', permission_action_text);
    PERFORM public.log_activity(action_type, details);
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    action_type := 'ROLE_PERMISSION_REMOVED';
    SELECT r.name, p.action INTO role_name_text, permission_action_text FROM public.roles r, public.permissions p WHERE r.id = OLD.role_id AND p.id = OLD.permission_id;
    details := jsonb_build_object('role_name', role_name_text, 'permission_action', permission_action_text);
    PERFORM public.log_activity(action_type, details);
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$;

-- Function: sanitize_announcement_jsonb
CREATE OR REPLACE FUNCTION public.sanitize_announcement_jsonb()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = public, pg_temp
AS $$
BEGIN
    IF NEW.title IS NOT NULL THEN
        NEW.title := replace(NEW.title::text, '\u0000', '')::jsonb;
    END IF;

    IF NEW.message IS NOT NULL THEN
        NEW.message := replace(NEW.message::text, '\u0000', '')::jsonb;
    END IF;

    RETURN NEW;
END;
$$;

-- Function: save_trader_summary
CREATE OR REPLACE FUNCTION public.save_trader_summary(
    p_symbol text,
    p_date date,
    p_summary_en text,
    p_summary_ar text
)
RETURNS void
LANGUAGE plpgsql
SET search_path = public, pg_temp
AS $$
BEGIN
  INSERT INTO public.trader_summaries (stock_symbol, "date", summary_en, summary_ar)
  VALUES (p_symbol, p_date, p_summary_en, p_summary_ar)
  ON CONFLICT (stock_symbol, "date") DO UPDATE SET
    summary_en = p_summary_en,
    summary_ar = p_summary_ar,
    created_at = now();
END;
$$;

-- ============================================================================
-- SECTION 3: Functions Using auth - SET search_path = public, auth, pg_temp
-- ============================================================================

-- Function: submit_user_note
CREATE OR REPLACE FUNCTION public.submit_user_note(p_note_content TEXT)
RETURNS void
LANGUAGE plpgsql
SET search_path = public, auth, pg_temp
AS $$
BEGIN
  INSERT INTO public.user_notes (user_id, note_content)
  VALUES (auth.uid(), p_note_content);
END;
$$;

-- Function: manually_confirm_user
CREATE OR REPLACE FUNCTION public.manually_confirm_user(user_id_to_confirm uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth, pg_temp
AS $$
BEGIN
  IF NOT public.has_permission('manage:users') THEN
    RETURN;
  END IF;

  UPDATE auth.users
  SET email_confirmed_at = now()
  WHERE id = user_id_to_confirm;
END;
$$;

-- Function: sync_user_confirmation_to_profile
CREATE OR REPLACE FUNCTION public.sync_user_confirmation_to_profile()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth, pg_temp
AS $$
BEGIN
  UPDATE public.profiles
  SET email_confirmed_at = NEW.email_confirmed_at
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$;

-- ============================================================================
-- SECTION 4: Additional Functions - Explicit Fixes
-- ============================================================================

-- Function: get_daily_watchlist_data
CREATE OR REPLACE FUNCTION public.get_daily_watchlist_data()
RETURNS TABLE (
    symbol text,
    stock_name text,
    last_close real,
    last_updated timestamp with time zone,
    predicted_lo real,
    predicted_hi real,
    sma20 real,
    sma50 real,
    pattern_name text,
    bullish boolean,
    forecast_date date
)
LANGUAGE plpgsql STABLE
SET search_path = public, pg_temp
AS $$
DECLARE
    latest_forecast_date date;
    latest_indicator_date date;
BEGIN
    SELECT max(f.forecast_date) INTO latest_forecast_date FROM public.forecasts f;
    SELECT max(ti.date) INTO latest_indicator_date FROM public.technical_indicators ti WHERE ti.date < latest_forecast_date;

    RETURN QUERY
    SELECT
        s.symbol,
        s.name AS stock_name,
        s.price AS last_close,
        s.last_updated,
        f.predicted_lo,
        f.predicted_hi,
        ti.sma20,
        ti.sma50,
        cp.pattern_name,
        cp.bullish,
        f.forecast_date
    FROM
        public.forecasts f
    JOIN
        public.stocks s ON f.stock_symbol = s.symbol
    LEFT JOIN
        public.technical_indicators ti ON f.stock_symbol = ti.stock_symbol AND ti.date = latest_indicator_date
    LEFT JOIN
        (
            SELECT DISTINCT ON (cp_inner.stock_symbol) *
            FROM public.candle_patterns cp_inner
            WHERE cp_inner.date = latest_indicator_date
        ) cp ON f.stock_symbol = cp.stock_symbol
    WHERE
        f.forecast_date = latest_forecast_date
        AND s.is_tracked = true
    ORDER BY
        s.symbol;
END;
$$;

-- Function: get_the_coming_trend_data
CREATE OR REPLACE FUNCTION public.get_the_coming_trend_data()
RETURNS TABLE (
    symbol TEXT,
    stock_name TEXT,
    last_price REAL,
    daily_change REAL,
    daily_change_percent REAL,
    next_forecast_date DATE,
    next_predicted_lo REAL,
    next_predicted_hi REAL,
    indicator_date DATE,
    rsi REAL,
    macd REAL,
    macd_signal REAL,
    sma20 REAL,
    sma50 REAL,
    pattern_name TEXT,
    bullish BOOLEAN,
    actual_low REAL,
    actual_high REAL
)
LANGUAGE plpgsql STABLE
SET search_path = public, pg_temp
AS $$
DECLARE
    latest_forecast_date DATE;
    latest_indicator_date DATE;
    latest_historical_date DATE;
BEGIN
    SELECT MAX(f.forecast_date) INTO latest_forecast_date FROM public.forecasts f;
    SELECT MAX(ti.date) INTO latest_indicator_date 
    FROM public.technical_indicators ti 
    WHERE ti.date < latest_forecast_date;
    SELECT MAX(hd.date) INTO latest_historical_date FROM public.historical_data hd;

    RETURN QUERY
    SELECT
        s.symbol,
        s.name AS stock_name,
        s.price AS last_price,
        s.change AS daily_change,
        s.change_percent AS daily_change_percent,
        f.forecast_date AS next_forecast_date,
        f.predicted_lo AS next_predicted_lo,
        f.predicted_hi AS next_predicted_hi,
        ti.date AS indicator_date,
        ti.rsi::real,
        ti.macd::real,
        ti.macd_signal::real,
        ti.sma20::real,
        ti.sma50::real,
        cp.pattern_name,
        cp.bullish,
        hd.low::real AS actual_low,
        hd.high::real AS actual_high
    FROM
        public.forecasts f
    JOIN
        public.stocks s ON f.stock_symbol = s.symbol
    LEFT JOIN
        public.technical_indicators ti 
        ON f.stock_symbol = ti.stock_symbol 
        AND ti.date = latest_indicator_date
    LEFT JOIN
        (
            SELECT DISTINCT ON (cp_inner.stock_symbol) *
            FROM public.candle_patterns cp_inner
            WHERE cp_inner.date = latest_indicator_date
        ) cp ON f.stock_symbol = cp.stock_symbol
    LEFT JOIN public.historical_data hd 
        ON f.stock_symbol = hd.stock_symbol 
        AND hd.date = latest_historical_date
    WHERE
        f.forecast_date = latest_forecast_date
        AND s.is_tracked = true
    ORDER BY
        s.symbol;
END;
$$;

-- ============================================================================
-- SECTION 5: Forecast Accuracy Functions - SET search_path = public, pg_temp
-- ============================================================================

-- Function: get_forecast_accuracy_overall
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_overall(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
SET search_path = public, pg_temp
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'total_forecasts', COUNT(*)::integer,
            'hit_range_count', COUNT(*) FILTER (WHERE hit_range = true)::integer,
            'miss_range_count', COUNT(*) FILTER (WHERE hit_range = false)::integer,
            'hit_rate', CASE 
                WHEN COUNT(*) > 0 THEN 
                    ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                ELSE 0 
            END,
            'avg_abs_error', COALESCE(AVG(abs_error), 0),
            'avg_pct_error', COALESCE(AVG(pct_error), 0),
            'avg_confidence', COALESCE(AVG(confidence), 0)
        )
        FROM public.forecast_check_history
        WHERE forecast_date BETWEEN v_start_date AND v_end_date
    );
END;
$$;

-- Function: get_forecast_accuracy_by_stock
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_by_stock(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
SET search_path = public, pg_temp
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT COALESCE(json_agg(
            json_build_object(
                'stock_symbol', stock_symbol,
                'total_forecasts', total_forecasts::integer,
                'hit_count', hit_count::integer,
                'miss_count', miss_count::integer,
                'hit_rate', hit_rate,
                'avg_abs_error', avg_abs_error,
                'avg_pct_error', avg_pct_error,
                'avg_confidence', avg_confidence
            )
            ORDER BY hit_rate DESC, total_forecasts DESC
        ), '[]'::json)
        FROM (
            SELECT 
                stock_symbol,
                COUNT(*) as total_forecasts,
                COUNT(*) FILTER (WHERE hit_range = true) as hit_count,
                COUNT(*) FILTER (WHERE hit_range = false) as miss_count,
                CASE 
                    WHEN COUNT(*) > 0 THEN 
                        ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                    ELSE 0 
                END as hit_rate,
                COALESCE(AVG(abs_error), 0) as avg_abs_error,
                COALESCE(AVG(pct_error), 0) as avg_pct_error,
                COALESCE(AVG(confidence), 0) as avg_confidence
            FROM public.forecast_check_history
            WHERE forecast_date BETWEEN v_start_date AND v_end_date
            GROUP BY stock_symbol
            HAVING COUNT(*) >= 3
        ) stock_stats
    );
END;
$$;

-- Function: get_forecast_accuracy_by_date
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_by_date(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
SET search_path = public, pg_temp
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT COALESCE(json_agg(
            json_build_object(
                'forecast_date', forecast_date::text,
                'total_forecasts', total_forecasts::integer,
                'hit_count', hit_count::integer,
                'hit_rate', hit_rate
            )
            ORDER BY forecast_date DESC
        ), '[]'::json)
        FROM (
            SELECT 
                forecast_date,
                COUNT(*) as total_forecasts,
                COUNT(*) FILTER (WHERE hit_range = true) as hit_count,
                CASE 
                    WHEN COUNT(*) > 0 THEN 
                        ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                    ELSE 0 
                END as hit_rate
            FROM public.forecast_check_history
            WHERE forecast_date BETWEEN v_start_date AND v_end_date
            GROUP BY forecast_date
            ORDER BY forecast_date DESC
            LIMIT 30
        ) date_stats
    );
END;
$$;

-- Function: get_forecast_accuracy_by_confidence
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_by_confidence(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
SET search_path = public, pg_temp
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT json_build_object(
            'high_confidence', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND confidence >= 70
            ),
            'medium_confidence', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND confidence >= 50 AND confidence < 70
            ),
            'low_confidence', (
                SELECT json_build_object(
                    'count', COUNT(*)::integer,
                    'hit_rate', CASE 
                        WHEN COUNT(*) > 0 THEN 
                            ROUND((COUNT(*) FILTER (WHERE hit_range = true)::numeric / COUNT(*)::numeric) * 100, 2)
                        ELSE 0 
                    END
                )
                FROM public.forecast_check_history
                WHERE forecast_date BETWEEN v_start_date AND v_end_date
                AND confidence < 50
            )
        )
    );
END;
$$;

-- Function: get_forecast_accuracy_recent
CREATE OR REPLACE FUNCTION public.get_forecast_accuracy_recent(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
STABLE
SET search_path = public, pg_temp
AS $$
DECLARE
    v_start_date DATE;
    v_end_date DATE;
BEGIN
    v_start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '90 days');
    v_end_date := COALESCE(p_end_date, CURRENT_DATE);

    RETURN (
        SELECT COALESCE(json_agg(
            json_build_object(
                'stock_symbol', rf.stock_symbol,
                'forecast_date', rf.forecast_date::text,
                'predicted_lo', rf.predicted_lo,
                'predicted_hi', rf.predicted_hi,
                'actual_low', rf.actual_low,
                'actual_high', rf.actual_high,
                'actual_close', rf.actual_close,
                'hit_range', rf.hit_range,
                'abs_error', rf.abs_error,
                'pct_error', rf.pct_error,
                'confidence', rf.confidence,
                'stock_name', rf.stock_name
            )
            ORDER BY rf.forecast_date DESC, rf.created_at DESC
        ), '[]'::json)
        FROM (
            SELECT 
                fch.stock_symbol,
                fch.forecast_date,
                fch.predicted_lo,
                fch.predicted_hi,
                fch.actual_low,
                fch.actual_high,
                fch.actual_close,
                fch.hit_range,
                fch.abs_error,
                fch.pct_error,
                fch.confidence,
                fch.created_at,
                s.name AS stock_name
            FROM public.forecast_check_history fch
            LEFT JOIN public.stocks s ON s.symbol = fch.stock_symbol
            WHERE fch.forecast_date BETWEEN v_start_date AND v_end_date
            ORDER BY fch.forecast_date DESC, fch.created_at DESC
            LIMIT 20
        ) rf
    );
END;
$$;

-- ============================================================================
-- SECTION 6: Dynamic Fix for Remaining Functions
-- ============================================================================

-- Use dynamic approach for remaining functions that weren't explicitly fixed above
-- This ensures all functions get fixed even if we missed some
DO $$
DECLARE
    func_record RECORD;
    func_def TEXT;
    search_path_val TEXT;
    fixed_count INTEGER := 0;
    failed_count INTEGER := 0;
BEGIN
    FOR func_record IN 
        SELECT 
            p.proname as func_name,
            pg_get_functiondef(p.oid) as func_def,
            CASE 
                WHEN pg_get_functiondef(p.oid) LIKE '%auth.uid()%' 
                     OR pg_get_functiondef(p.oid) LIKE '%auth.users%'
                     OR pg_get_functiondef(p.oid) LIKE '%auth.role()%' THEN
                    'public, auth, pg_temp'
                ELSE
                    'public, pg_temp'
            END as search_path_needed
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        WHERE n.nspname = 'public'
            AND p.proname NOT LIKE 'pg_%'
            AND pg_get_functiondef(p.oid) NOT LIKE '%SET search_path%'
            AND p.proname NOT IN (
                -- Skip functions already fixed above
                'get_active_announcements', 'get_all_announcements', 'get_all_roles',
                'get_all_translations_for_management', 'get_all_users_for_analysis',
                'get_translations', 'get_translations_for_key', 'get_user_profile_and_permissions',
                'get_dashboard_stats', 'get_role_management_data', 'get_latest_forecast_date',
                'get_daily_analysis_summary', 'get_daily_forecast_results',
                'evaluate_and_save_forecasts', 'trigger_forecast_evaluation',
                'fn_log_app_settings_change', 'fn_log_profile_update',
                'fn_log_role_permission_change', 'sanitize_announcement_jsonb',
                'save_trader_summary', 'submit_user_note', 'manually_confirm_user',
                'sync_user_confirmation_to_profile', 'get_daily_watchlist_data',
                'get_the_coming_trend_data', 'get_forecast_accuracy_overall',
                'get_forecast_accuracy_by_stock', 'get_forecast_accuracy_by_date',
                'get_forecast_accuracy_by_confidence', 'get_forecast_accuracy_recent',
                -- Skip functions that already have search_path
                'admin_update_user_password', 'delete_activity_logs', 'export_activity_logs',
                'fn_log_user_login', 'get_activity_logs', 'get_all_app_settings',
                'get_all_user_notes', 'get_all_users_with_roles', 'get_distinct_log_actions',
                'get_user_favorite_stocks', 'toggle_favorite_stock', 'handle_new_user',
                'has_permission', 'is_first_user', 'log_activity'
            )
    LOOP
        BEGIN
            func_def := func_record.func_def;
            search_path_val := func_record.search_path_needed;
            
            -- For SQL functions: add after STABLE/IMMUTABLE/VOLATILE
            IF func_def ~* 'LANGUAGE\s+sql' THEN
                IF func_def ~* 'STABLE' THEN
                    func_def := regexp_replace(func_def, 
                        '(LANGUAGE\s+sql\s+STABLE)', 
                        E'\\1\nSET search_path = ' || search_path_val,
                        'gi');
                ELSIF func_def ~* 'IMMUTABLE' THEN
                    func_def := regexp_replace(func_def, 
                        '(LANGUAGE\s+sql\s+IMMUTABLE)', 
                        E'\\1\nSET search_path = ' || search_path_val,
                        'gi');
                ELSIF func_def ~* 'VOLATILE' THEN
                    func_def := regexp_replace(func_def, 
                        '(LANGUAGE\s+sql\s+VOLATILE)', 
                        E'\\1\nSET search_path = ' || search_path_val,
                        'gi');
                ELSE
                    func_def := regexp_replace(func_def, 
                        '(LANGUAGE\s+sql)', 
                        E'\\1\nSET search_path = ' || search_path_val,
                        'gi');
                END IF;
            -- For plpgsql functions
            ELSIF func_def ~* 'LANGUAGE\s+plpgsql' THEN
                IF func_def ~* 'SECURITY\s+DEFINER' THEN
                    -- Insert after SECURITY DEFINER
                    func_def := regexp_replace(func_def,
                        '(SECURITY\s+DEFINER\s+)',
                        E'\\1SET search_path = ' || search_path_val || E'\n',
                        'gi');
                ELSIF func_def ~* 'STABLE' THEN
                    func_def := regexp_replace(func_def,
                        '(LANGUAGE\s+plpgsql\s+STABLE)',
                        E'\\1\nSET search_path = ' || search_path_val,
                        'gi');
                ELSIF func_def ~* 'IMMUTABLE' THEN
                    func_def := regexp_replace(func_def,
                        '(LANGUAGE\s+plpgsql\s+IMMUTABLE)',
                        E'\\1\nSET search_path = ' || search_path_val,
                        'gi');
                ELSE
                    func_def := regexp_replace(func_def,
                        '(LANGUAGE\s+plpgsql\s*)',
                        E'\\1SET search_path = ' || search_path_val || E'\n',
                        'gi');
                END IF;
            END IF;
            
            -- Execute the modified function definition
            EXECUTE func_def;
            fixed_count := fixed_count + 1;
        EXCEPTION WHEN OTHERS THEN
            failed_count := failed_count + 1;
        END;
    END LOOP;
END $$;

COMMIT;

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Add Chart Titles Translations for Forecast Accuracy Page
-- #
-- # Purpose: Add missing translation keys for chart titles that are currently
-- # showing in English even when Arabic is selected
-- #
-- #############################################################################

BEGIN;

ALTER TABLE public.translations DISABLE ROW LEVEL SECURITY;

INSERT INTO public.translations (lang_id, key, value) VALUES
-- English
('en', 'area_trend', 'Area Trend'),
('en', 'hit_rate_trend', 'Hit Rate Trend'),
('en', 'line_trend', 'Line Trend'),
('en', 'radar', 'Radar Chart'),
('en', 'radial', 'Radial Chart'),
('en', 'scatter', 'Scatter Plot'),
('en', 'stacked', 'Stacked Bar'),
('en', 'composed', 'Composed Chart'),
('en', 'top_stocks', 'Top Stocks'),
('en', 'funnel', 'Funnel Chart'),
('en', 'reliability', 'Reliability'),
('en', 'coverage', 'Coverage'),
('en', 'avg_error', 'Average Error'),
('en', 'hits', 'Hits'),
('en', 'high_confidence_hits', 'High Confidence Hits'),
('en', 'candlestick_with_forecast_range', 'Candlestick with Forecast Range'),
('en', 'predicted_high', 'Predicted High'),
('en', 'predicted_low', 'Predicted Low'),
('en', 'actual_high', 'Actual High'),
('en', 'actual_low', 'Actual Low'),
('en', 'predicted', 'Predicted'),
('en', 'actual', 'Actual'),
('en', 'waterfall_daily_change', 'Daily Hit Rate Change'),
('en', 'hit_map', 'Hit Map'),
('en', 'top_10_stocks', 'Top 10 Stocks'),
('en', 'range_size_vs_hit_rate', 'Range Size vs Hit Rate'),
('en', 'range_size', 'Range Size'),
('en', 'overall_hit_rate', 'Overall Hit Rate'),
('en', 'total_hits', 'Total Hits'),
('en', 'total_misses', 'Total Misses'),
('en', 'successful_forecasts', 'Successful Forecasts'),
('en', 'failed_forecasts', 'Failed Forecasts'),
('en', 'forecast_accuracy_indicators_dashboard', 'Forecast Accuracy Indicators Dashboard'),
('en', 'within_range', 'Within Range'),
('en', 'range_width', 'Range Width'),
('en', 'mape', 'Mean Absolute Percentage Error (MAPE)'),
('en', 'accuracy_rate_global', 'Accuracy Rate (Global KPI)'),
('en', 'last_30_days_mape_trend', 'Last 30 Days - MAPE Trend'),
('en', 'last_30_days_hit_rate', 'Last 30 Days - Hit Rate'),
('en', 'error_distribution_absolute', 'Error Distribution (Absolute Error)'),
('en', 'within_range_weekly_cumulative', 'Within Range - Weekly Cumulative'),
('en', 'week', 'Week'),

-- Arabic
('ar', 'area_trend', 'اتجاه مساحي'),
('ar', 'hit_rate_trend', 'اتجاه نسبة النجاح'),
('ar', 'line_trend', 'اتجاه خطي'),
('ar', 'radar', 'مخطط رادار'),
('ar', 'radial', 'مخطط دائري'),
('ar', 'scatter', 'مخطط التشتت'),
('ar', 'stacked', 'أعمدة مكدسة'),
('ar', 'composed', 'مخطط مركب'),
('ar', 'top_stocks', 'أفضل الأسهم'),
('ar', 'funnel', 'مخطط قمعي'),
('ar', 'reliability', 'الموثوقية'),
('ar', 'coverage', 'التغطية'),
('ar', 'avg_error', 'متوسط الخطأ'),
('ar', 'hits', 'التوقعات الصحيحة'),
('ar', 'high_confidence_hits', 'التوقعات الصحيحة عالية الثقة'),
('ar', 'candlestick_with_forecast_range', 'الشموع مع نطاق التوقع'),
('ar', 'predicted_high', 'الحد الأعلى المتوقع'),
('ar', 'predicted_low', 'الحد الأدنى المتوقع'),
('ar', 'actual_high', 'الحد الأعلى الفعلي'),
('ar', 'actual_low', 'الحد الأدنى الفعلي'),
('ar', 'predicted', 'متوقع'),
('ar', 'actual', 'فعلي'),
('ar', 'waterfall_daily_change', 'تحليل التغيير اليومي'),
('ar', 'hit_map', 'خريطة نجاح التوقعات'),
('ar', 'top_10_stocks', 'أفضل 10 أسهم'),
('ar', 'range_size_vs_hit_rate', 'نطاق التوقع مقابل نسبة النجاح'),
('ar', 'range_size', 'حجم النطاق'),
('ar', 'overall_hit_rate', 'نسبة النجاح الإجمالية'),
('ar', 'total_hits', 'التوقعات الصحيحة'),
('ar', 'total_misses', 'التوقعات الخاطئة'),
('ar', 'successful_forecasts', 'توقعات ناجحة'),
('ar', 'failed_forecasts', 'توقعات فاشلة'),
('ar', 'forecast_accuracy_indicators_dashboard', 'لوحة مؤشرات دقة التوقعات'),
('ar', 'within_range', 'داخل النطاق'),
('ar', 'range_width', 'اتساع النطاق'),
('ar', 'mape', 'الخطأ المتوسط (MAPE)'),
('ar', 'accuracy_rate_global', 'نسبة الدقة (KPI Global)'),
('ar', 'last_30_days_mape_trend', 'آخر 30 يوم - MAPE Trend'),
('ar', 'last_30_days_hit_rate', 'آخر 30 يوم - Hit Rate'),
('ar', 'error_distribution_absolute', 'توزيع الخطأ (Absolute Error)'),
('ar', 'within_range_weekly_cumulative', 'داخل النطاق - تجميعي أسبوعي'),
('ar', 'week', 'أسبوع')
ON CONFLICT (lang_id, key) 
DO UPDATE SET value = EXCLUDED.value;

ALTER TABLE public.translations ENABLE ROW LEVEL SECURITY;

COMMIT;

-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix get_daily_analysis_summary and get_daily_forecast_results
-- #
-- # Purpose: This script fixes the functions that reference the deprecated
-- # audit_forecast_metrics table. These functions now use forecast_check_history
-- # which is the current table for storing forecast evaluation results.
-- #
-- # Issue: The functions were referencing audit_forecast_metrics which was
-- # dropped in migration_057 and replaced with forecast_check_history.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Function: get_daily_analysis_summary
-- Fixed: Changed from audit_forecast_metrics to forecast_check_history
CREATE OR REPLACE FUNCTION public.get_daily_analysis_summary(p_date date)
RETURNS json
LANGUAGE sql STABLE
SET search_path = public, pg_temp
AS $$
WITH daily_metrics AS (
    SELECT
        fch.hit_range,
        fch.predicted_price,
        fch.actual_close
    FROM public.forecast_check_history fch
    WHERE fch.forecast_date = p_date AND fch.actual_close IS NOT NULL
)
SELECT json_build_object(
    'forecast_date', p_date,
    'total_forecasts', (SELECT count(*) FROM daily_metrics),
    'hits', (SELECT count(*) FROM daily_metrics WHERE hit_range = true),
    'misses', (SELECT count(*) FROM daily_metrics WHERE hit_range = false),
    'hit_rate', (SELECT avg(CASE WHEN hit_range = true THEN 1 ELSE 0 END) FROM daily_metrics),
    'mape', (SELECT avg(abs(predicted_price - actual_close) / actual_close) FROM daily_metrics WHERE actual_close > 0)
);
$$;

-- Function: get_daily_forecast_results
-- Fixed: Changed from audit_forecast_metrics to forecast_check_history
-- Also removed unnecessary LEFT JOIN with historical_data since actual_low/actual_high are in forecast_check_history
CREATE OR REPLACE FUNCTION public.get_daily_forecast_results(p_date date)
RETURNS TABLE (
    stock_symbol text,
    stock_name text,
    predicted_price real,
    predicted_lo real,
    predicted_hi real,
    actual_close real,
    actual_low real,
    actual_high real,
    is_hit boolean
)
LANGUAGE sql STABLE
SET search_path = public, pg_temp
AS $$
SELECT
    fch.stock_symbol,
    s.name as stock_name,
    fch.predicted_price::real,
    fch.predicted_lo::real,
    fch.predicted_hi::real,
    fch.actual_close::real,
    fch.actual_low::real,
    fch.actual_high::real,
    fch.hit_range as is_hit
FROM
    public.forecast_check_history fch
JOIN
    public.stocks s ON fch.stock_symbol = s.symbol
WHERE
    fch.forecast_date = p_date
ORDER BY
    fch.stock_symbol;
$$;

COMMIT;







