-- #############################################################################
-- #
-- # MIGRATION SCRIPT: Fix 'evaluate_and_save_forecasts' Function Overload Conflict
-- #
-- # Purpose: This script resolves the "function is not unique" error that
-- # occurs when calling `evaluate_and_save_forecasts()`. The error is caused
-- # by having two versions of the function in the database: one with no arguments,
-- # and one with a single argument that has a default value.
-- #
-- # This script provides a definitive fix by:
-- # 1. Explicitly dropping the conflicting, no-argument version of the function.
-- # 2. Re-creating the correct version of the function, which takes an optional
-- #    date parameter, ensuring only one valid function definition exists.
-- #
-- # This script is safe to run multiple times.
-- #
-- #############################################################################

BEGIN;

-- Step 1: Drop the conflicting function with no arguments.
-- The empty parentheses are crucial to target the correct function signature.
-- Using `IF EXISTS` prevents an error if the function doesn't exist.
DROP FUNCTION IF EXISTS public.evaluate_and_save_forecasts();
RAISE NOTICE 'SUCCESS: Dropped conflicting no-argument version of "evaluate_and_save_forecasts".';

-- Step 2: Re-create the correct function with the date parameter.
-- This ensures the single, correct version of the function exists and is up-to-date.
CREATE OR REPLACE FUNCTION public.evaluate_and_save_forecasts(p_date_filter date DEFAULT NULL)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    processed_count integer;
BEGIN
    -- This single WITH clause performs all calculations and insertions atomically.
    WITH new_evaluations AS (
        -- Calculate the results for all forecasts that have matching historical data.
        SELECT
            f.stock_symbol,
            s.name AS stock_name,
            f.forecast_date,
            f.predicted_price,
            f.predicted_lo,
            f.predicted_hi,
            f.confidence,
            h.low AS actual_low,
            h.high AS actual_high,
            h.close AS actual_close,
            (f.predicted_lo <= h.high AND h.low <= f.predicted_hi) AS hit_range,
            ABS(f.predicted_price - h.close) AS abs_error,
            ABS(f.predicted_price - h.close) / NULLIF(h.close, 0) AS pct_error
        FROM
            public.forecasts f
        JOIN
            public.stocks s ON f.stock_symbol = s.symbol
        JOIN
            public.historical_data h ON f.stock_symbol = h.stock_symbol AND f.forecast_date = h.date
        WHERE (p_date_filter IS NULL OR f.forecast_date = p_date_filter)
    ),
    insert_history AS (
        INSERT INTO public.forecast_check_history (
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        )
        SELECT
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        FROM new_evaluations
        ON CONFLICT (stock_symbol, forecast_date) DO UPDATE SET
            predicted_price = EXCLUDED.predicted_price,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            actual_close = EXCLUDED.actual_close,
            hit_range = EXCLUDED.hit_range,
            abs_error = EXCLUDED.abs_error,
            pct_error = EXCLUDED.pct_error,
            confidence = EXCLUDED.confidence,
            created_at = NOW()
        RETURNING 1
    ),
    upsert_latest AS (
        INSERT INTO public.forecast_check_latest (
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        )
        SELECT DISTINCT ON (stock_symbol)
            stock_symbol, forecast_date, predicted_price, predicted_lo, predicted_hi,
            actual_low, actual_high, actual_close, hit_range, abs_error, pct_error, confidence
        FROM new_evaluations
        ORDER BY stock_symbol, forecast_date DESC
        ON CONFLICT (stock_symbol) DO UPDATE SET
            forecast_date = EXCLUDED.forecast_date,
            predicted_price = EXCLUDED.predicted_price,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            actual_close = EXCLUDED.actual_close,
            hit_range = EXCLUDED.hit_range,
            abs_error = EXCLUDED.abs_error,
            pct_error = EXCLUDED.pct_error,
            confidence = EXCLUDED.confidence,
            created_at = NOW()
    ),
    insert_legacy AS (
        INSERT INTO public."Forcast_Result" (
            stock_symbol, stock_name, forecast_date, predicted_lo, predicted_hi,
            actual_low, actual_high, is_hit
        )
        SELECT
            stock_symbol, stock_name, forecast_date, predicted_lo, predicted_hi,
            actual_low, actual_high, hit_range
        FROM new_evaluations
        ON CONFLICT (stock_symbol, forecast_date) DO UPDATE SET
            stock_name = EXCLUDED.stock_name,
            predicted_lo = EXCLUDED.predicted_lo,
            predicted_hi = EXCLUDED.predicted_hi,
            actual_low = EXCLUDED.actual_low,
            actual_high = EXCLUDED.actual_high,
            is_hit = EXCLUDED.is_hit,
            created_at = NOW()
    )
    SELECT count(*) INTO processed_count FROM insert_history;
        
    RAISE NOTICE '% forecast(s) evaluated and saved.', processed_count;
    
    RETURN processed_count;
END;
$$;

RAISE NOTICE 'SUCCESS: Function "evaluate_and_save_forecasts(date)" re-created to resolve conflict.';

COMMIT;
